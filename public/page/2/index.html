<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://lixuguang.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="学习 | 生活 | 一切">
<meta property="og:type" content="website">
<meta property="og:title" content="李旭光的技术博客">
<meta property="og:url" content="http://lixuguang.github.io/page/2/index.html">
<meta property="og:site_name" content="李旭光的技术博客">
<meta property="og:description" content="学习 | 生活 | 一切">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="李旭光">
<meta property="article:tag" content="李旭光">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://lixuguang.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>李旭光的技术博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">李旭光的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">求知若饥，虚心若愚。</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/lixuguang" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/05/FE-guide-currying/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/FE-guide-currying/" class="post-title-link" itemprop="url">前端常见知识点整理 ---- 柯里化 currying</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 17:59:22 / 修改时间：19:58:56" itemprop="dateCreated datePublished" datetime="2020-01-05T17:59:22+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<p>柯里化，可以理解为<strong><em>提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接受剩余参数的函数</em></strong>。因为这样的特性，也被称为部分计算函数。</p>
<p>通俗易懂的解释：用<strong><em>闭包</em></strong>把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。柯里化，是一个逐步接收参数的过程。在接下来的剖析中，你会深刻体会到这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function currying(fn)&#123;</span><br><span class="line">    var allArgs &#x3D; [];</span><br><span class="line"></span><br><span class="line">    return function next()&#123;</span><br><span class="line">        var args &#x3D; [].slice.call(arguments); &#x2F;&#x2F; 拆成数组元素</span><br><span class="line"></span><br><span class="line">        if(args.length &gt; 0)&#123;</span><br><span class="line">            allArgs &#x3D; allArgs.concat(args);</span><br><span class="line">            return next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return fn.apply(null, allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来一个简单的实例验证一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var add &#x3D; currying(function()&#123;</span><br><span class="line">    var sum &#x3D; 0;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        sum +&#x3D; arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(1)(2, 3)(4)() &#x2F;&#x2F; &#x3D;&gt; 10</span><br></pre></td></tr></table></figure>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function getUrl(domain, protocol, path) &#123;</span><br><span class="line">	return protocol + &quot;:&#x2F;&#x2F;&quot; + domain + &quot;&#x2F;&quot; + path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var page1 &#x3D; getUrl(&#39;http&#39;, &#39;lixuguang.github.io&#39;, &#39;page1.html&#39;);</span><br><span class="line">var page2 &#x3D; getUrl(&#39;http&#39;, &#39;lixuguang.github.io&#39;, &#39;page2.html&#39;);</span><br></pre></td></tr></table></figure>
<p>我们使用currying来简化它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var conardliSite &#x3D; currying(getUrl)</span><br><span class="line">var page1 &#x3D; conardliSite(&#39;page1.html&#39;)(&#39;http&#39;, &#39;lixuguang.github.io&#39;)();</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/05/FE-guide-about-reduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/FE-guide-about-reduce/" class="post-title-link" itemprop="url">reduce函数的妙用 ---- 实现map和filter</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 16:55:00 / 修改时间：16:53:53" itemprop="dateCreated datePublished" datetime="2020-01-05T16:55:00+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看了好多技术文章，好多的代码片段，突然发现好多的代码里都有 <code>reduce</code> ，感觉以前都没怎么关注过这个函数，为了弥补这个过失，打算专门写一篇文章说说它。</p>
<p><code>reduce</code> 函数在 MDN 中是这样介绍的</p>
<blockquote>
<p>reduce() 方法对数组中的<strong><em>每个元素</em></strong>执行一个由 <strong><em>您</em></strong> 提供的 <code>reducer</code> 函数(<strong><em>升序执行</em></strong>)，将其结果汇总为单个返回值。</p>
</blockquote>
<p>说实话看了一脸懵逼，这上面说的叫人话？后来耐着性子看了一些代码后感觉有所理解，如果理解不对，还请斧正。<br>首先看一下这里面几个关键词</p>
<p><strong>* 每个元素： *</strong> 这就是遍历咯，没啥好说的<br><strong><em>您</em></strong>提供的 <code>reducer</code> 函数：我哪有什么 <code>reducer</code> 函数呢，后来理解了，就是回调，有的地方呢叫 <code>handler</code> ，这里跟 <code>reduce</code> 配合就叫了 <code>reducer</code>。<br><strong><em>升序执行</em></strong>：就是说是0，1，2下标这样的顺序执行啦。<br>将其结果汇总为单个返回值：最后返回的是一个值，当然没说必须是什么类型。</p>
<p>这样解释完了以后，上面这句话就比较好懂了，简单说就是 <code>reduce</code> 里传一个回调函数，执行回调函数方法后返回一个值，就是这样。</p>
<blockquote>
<p>reducer 函数接收4个参数:</p>
</blockquote>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)<br>您的 <code>reducer</code> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<p>看上面的描述一定要注意，这些参数是 <code>reducer</code> 的参数，不是 <code>reduce</code> 的参数，一共有4个，通常用前两个情况比较多。</p>
<p>那么 <code>reduce</code> 函数呢实际上有两个参数，第二个还可以省略 <code>reducer</code> 和 <code>initialValue</code>，<code>initialValue</code>作为第一次调用 <code>reducer</code> 函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 <strong><em>在没有初始值的空数组上调用 <code>reduce</code> 将报错</em></strong>，这点切记。</p>
<p>终于把前置知识讲清楚了，接下来，我们就用 <code>reduce</code> 搞点事情。</p>
<h2 id="1-使用-reduce-实现-map"><a href="#1-使用-reduce-实现-map" class="headerlink" title="1. 使用 reduce 实现 map"></a>1. 使用 <code>reduce</code> 实现 <code>map</code></h2><p><code>map</code> 的话我不想再讲一遍，一句话带过，就是对回调函数中的元素进行加工后返回一个长度一样的新数组。<br>那么该如何实现呢，我们来想想原理吧，刚才上面说过了，reduce执行过后的返回值会作为下一次执行的第一个参数放进去，那么就可以先用一个空数组作为初始值来接受每次需要处理的元素的集合，并返回回去，作为下一次传入的第一个参数，这样每次操作完之后就可以push到这个数组中，那么剩下要做的就是处理数组中每一项的函数了，我们叫他 <code>handler</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Array.prototype.reduceToMap &#x3D; function (handler) &#123; &#x2F;&#x2F; 自定义 &#96;map&#96; 函数 &#96;reduceToMap&#96;</span><br><span class="line">  return this.reduce((target, current, index) &#x3D;&gt; &#123; &#x2F;&#x2F; this指向调用他的数组</span><br><span class="line">    target.push(handler.call(this, current, index)) &#x2F;&#x2F; 这里用了call方法，handler将接受两个参数 current和index</span><br><span class="line">    return target; &#x2F;&#x2F; 处理完成后返回新数组</span><br><span class="line">  &#125;, []) &#x2F;&#x2F; 初始化空的新数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就这样我们就用 <code>reduce</code>，实现了 <code>map</code> 的功能，是不是很好用？</p>
<h2 id="2-使用-reduce-实现-filter"><a href="#2-使用-reduce-实现-filter" class="headerlink" title="2. 使用 reduce 实现 filter"></a>2. 使用 <code>reduce</code> 实现 <code>filter</code></h2><p><code>filter</code> 也是数组常用的方法，同样传入一个回调函数，处理结果返回true或false，最终 <code>filter</code> 会返回一个过滤后的函数。<br>学会了上面的 <code>map</code> 的实现，实际上 <code>filter</code> 就会很简单</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Array.prototype.reduceToFilter &#x3D; function (handler) &#123; &#x2F;&#x2F; 还是自定义方法名</span><br><span class="line">  return this.reduce((target, current, index) &#x3D;&gt; &#123;</span><br><span class="line">    if (handler.call(this, current, index)) &#123; &#x2F;&#x2F; 这里注意 handler 要返回的是布尔类型的值</span><br><span class="line">      target.push(current); &#x2F;&#x2F; 符合条件就插入新数组</span><br><span class="line">    &#125; &#x2F;&#x2F; 不符合就什么都不做</span><br><span class="line">    return target; &#x2F;&#x2F; 最后返回新数组</span><br><span class="line">  &#125;, []) &#x2F;&#x2F; 初始化一个空数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>日后在看到 <code>reduce</code> 的妙用之后还会来补充这篇文章，如果实在懒得写，我也会链接一下新文章，希望大家长期关注。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/05/FE-guide-ArrayOprs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/05/FE-guide-ArrayOprs/" class="post-title-link" itemprop="url">数组常见操作 ---- 去重、扁平、取最大最小值</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-05 11:05:00 / 修改时间：15:47:21" itemprop="dateCreated datePublished" datetime="2020-01-05T11:05:00+08:00">2020-01-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><h2 id="1-利用-Object-的-Key-唯一特性"><a href="#1-利用-Object-的-Key-唯一特性" class="headerlink" title="1. 利用 Object 的 Key 唯一特性"></a>1. 利用 <code>Object</code> 的 <code>Key</code> 唯一特性</h2><p>开辟一个外部存储空间用于标示元素是否出现过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">    var container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-利用-indexOf-的返回值数值进行去重"><a href="#2-利用-indexOf-的返回值数值进行去重" class="headerlink" title="2. 利用 indexOf 的返回值数值进行去重"></a>2. 利用 <code>indexOf</code> 的返回值数值进行去重</h2><p>原理是 <code>indexOf</code> 获取元素时如果返回值不等于下标说明已经有了，配合 <code>filter</code> 更美味</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; arr.filter((e,i) &#x3D;&gt; </span><br><span class="line">  arr.indexOf(e) &#x3D;&#x3D;&#x3D; i &#x2F;&#x2F; 如果元素找到的当前下标和当前索引相同说明是同一个，不同说明不是唯一</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>还有一种变形方法利用 <code>lastIndexOf</code> 方法</p>
<blockquote>
<p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const filterNonUnique &#x3D; arr &#x3D;&gt; arr.filter(e &#x3D;&gt; </span><br><span class="line">  arr.indexOf(e) &#x3D;&#x3D;&#x3D; arr.lastIndexOf(e) &#x2F;&#x2F; 判断一个元素出现时的第一次下标和最后一次下标是否相同，如果相同那么就唯一</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="3-利用-Set-特性去重"><a href="#3-利用-Set-特性去重" class="headerlink" title="3. 利用 Set 特性去重"></a>3. 利用 <code>Set</code> 特性去重</h2><p><code>Set</code> 是 <code>ES6</code> 中新的数据类型，它的特点就是元素唯一性，且可以和数组进行转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; Array.from(new Set(arr)); &#x2F;&#x2F; Array.from 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 优化</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; [...new Set(arr)]; &#x2F;&#x2F; 利用 &#96;ES6&#96; 中展开操作</span><br></pre></td></tr></table></figure>
<h2 id="4-排序后判断前后两项是否相等去重"><a href="#4-排序后判断前后两项是否相等去重" class="headerlink" title="4. 排序后判断前后两项是否相等去重"></a>4. 排序后判断前后两项是否相等去重</h2><p>通过比较相邻数字是否重复，将排序后的数组进行去重。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  array.sort((a, b) &#x3D;&gt; a - b);</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  const result &#x3D; [];</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (!i || array[i] !&#x3D; array[pre]) &#123;</span><br><span class="line">      result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pre &#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扁平"><a href="#扁平" class="headerlink" title="扁平"></a>扁平</h1><h2 id="1-普通方法"><a href="#1-普通方法" class="headerlink" title="1. 普通方法"></a>1. 普通方法</h2><p>通过递归的方式判断数组中的项是否是数组，如果不是就加入到新的扁平数组，如果是就递归调用逐层判断，直到全部结束</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const flatten &#x3D; (array) &#x3D;&gt; &#123; &#x2F;&#x2F; array 原数组</span><br><span class="line">  let result &#x3D; []; &#x2F;&#x2F; 定义新的扁平数组</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(array[i])) &#123; &#x2F;&#x2F; 判断子元素是否是数组</span><br><span class="line">      result &#x3D; result.concat(flatten(array[i])); &#x2F;&#x2F; 递归判断</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(array[i]); &#x2F;&#x2F; 加入新数组</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用reduce简化上述方法"><a href="#2-使用reduce简化上述方法" class="headerlink" title="2. 使用reduce简化上述方法"></a>2. 使用reduce简化上述方法</h2><blockquote>
<p>reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。<br>reducer 函数接收4个参数:</p>
</blockquote>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)</li>
<li>您的 reducer 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<p>先看一段 reduce 的示例函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [1, 2, 3, 4];</span><br><span class="line">const reducer &#x3D; (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue; &#x2F;&#x2F; 定义一个累计器函数，作用是将数组前后累计值与当前值累加</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer)); &#x2F;&#x2F; 没有初始值用第一个元素</span><br><span class="line">&#x2F;&#x2F; expected output: 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5 + 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer, 5)); &#x2F;&#x2F; 有初始值从初始值开始</span><br><span class="line">&#x2F;&#x2F; expected output: 15</span><br></pre></td></tr></table></figure>
<p>这下大家应该对 reduce 函数认识了，接下来看看怎么简化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function flatten(array) &#123;</span><br><span class="line">  return array.reduce((newArray, current) &#x3D;&gt; &#x2F;&#x2F; 新数组，当前项</span><br><span class="line">    Array.isArray(current) ? &#x2F;&#x2F; 判断当前项是否为数组</span><br><span class="line">      newArray.concat(flatten(current)) : &#x2F;&#x2F; 是的话 递归调用</span><br><span class="line">      newArray.concat(current) &#x2F;&#x2F; 不是的话加进新数组</span><br><span class="line">  , []) &#x2F;&#x2F; 初始化新数组为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们再变一个形，增加一个变量，变成可指定深度操作数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function flattenByDeep(array, deep &#x3D; 1) &#123; &#x2F;&#x2F; 默认一层</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) &amp;&amp; deep &gt; 1 ?</span><br><span class="line">        target.concat(flattenByDeep(current, deep - 1)) : &#x2F;&#x2F; 下一次减一层</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h1><h2 id="利用-reduce"><a href="#利用-reduce" class="headerlink" title="利用 reduce"></a>利用 <code>reduce</code></h2><p><code>reduce</code> 函数真的是超级好用，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">array.reduce((c,n) &#x3D;&gt; Math.max(c,n))</span><br></pre></td></tr></table></figure>

<h2 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h2><p><code>Math.max</code> 参数原本是一组数字，只需要让他可以接收数组即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const array &#x3D; [3,2,1,4,5];</span><br><span class="line">Math.max.apply(null,array);</span><br><span class="line">Math.max(...array);</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/04/Algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/04/Algorithm/" class="post-title-link" itemprop="url">JavaScript实现经典排序算法</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-01-04 07:18:22" itemprop="dateCreated datePublished" datetime="2020-01-04T07:18:22+08:00">2020-01-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-05 09:48:48" itemprop="dateModified" datetime="2020-01-05T09:48:48+08:00">2020-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。<br>没有循环语句，记作O(1)，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O（n），也叫线性阶。<br>常见的时间复杂度有：</p>
<ul>
<li>O(1): Constant Complexity: Constant 常数复杂度</li>
<li>O(log n): Logarithmic Complexity: 对数复杂度</li>
<li>O(n): Linear Complexity: 线性时间复杂度</li>
<li>O(n^2): N square Complexity 平⽅方</li>
<li>O(n^3): N square Complexity ⽴立⽅方</li>
<li>O(2^n): Exponential Growth 指数</li>
<li>O(n!): Factorial 阶乘</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。</p>
<p>一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。</p>
<ul>
<li>稳定</li>
<li>不稳定<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><img src="https://i.loli.net/2020/01/04/TqaRjEJSnhtQ5vH.png" alt="十大经典排序.jpg"><h2 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h2>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。<br>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；<br>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序<br>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li>
</ul>
<h2 id="关于稳定性："><a href="#关于稳定性：" class="headerlink" title="关于稳定性："></a>关于稳定性：</h2><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。<br>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
<h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ul>
<li>n：数据规模</li>
<li>k：“桶”的个数</li>
<li>In-place：占用常数内存，不占用额外内存</li>
<li>Out-place：占用额外内存</li>
<li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li>
</ul>
<h1 id="1-冒泡排序（Bubble-Sort）-—-前后两两比较-—-气泡"><a href="#1-冒泡排序（Bubble-Sort）-—-前后两两比较-—-气泡" class="headerlink" title="1. 冒泡排序（Bubble Sort） — 前后两两比较 — 气泡"></a>1. 冒泡排序（Bubble Sort） — 前后两两比较 — 气泡</h1><p>冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，其优点是实现简单，排序数量较小时性能较好。</p>
<p>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h2 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1. 1 算法原理"></a>1. 1 算法原理</h2><p>相邻的数据进行两两比较，小数放在前面，大数放在后面，如果前面的数据比后面的数据大，就交换这两个数的位置。也可以实现大数放在前面，小数放在后面，如果前面的数据比后面的小，就交换两个的位置。要实现上述规则需要用到两层for循环。</p>
<h2 id="1-2-算法描述"><a href="#1-2-算法描述" class="headerlink" title="1. 2 算法描述"></a>1. 2 算法描述</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<h2 id="1-3-动图演示"><a href="#1-3-动图演示" class="headerlink" title="1. 3 动图演示"></a>1. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldB5VS.gif" alt="ldB5VS.gif"></p>
<h2 id="1-4-js代码实现"><a href="#1-4-js代码实现" class="headerlink" title="1. 4 js代码实现"></a>1. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">  var len &#x3D; arr.length;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    for (var j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F; 相邻元素两两对比</span><br><span class="line">      &#x2F;&#x2F; 元素交换</span><br><span class="line">      &#x2F;** 1.使用中间变量 **&#x2F; </span><br><span class="line">        var temp &#x3D; arr[j + 1]; </span><br><span class="line">        arr[j + 1] &#x3D; arr[j]</span><br><span class="line">        arr[j] &#x3D; temp</span><br><span class="line">        &#x2F;** 2.适用纯数字的数组排序 **&#x2F;</span><br><span class="line">        arr[j] &#x3D; arr[j] +  arr[j + 1]</span><br><span class="line">        arr[j + 1] &#x3D;  arr[j] - arr[j + 1]</span><br><span class="line">        arr[j] -&#x3D; arr[j + 1]</span><br><span class="line">        &#x2F;** 3.使用es6解构赋值 **&#x2F;</span><br><span class="line">        [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">  var len &#x3D; arr.length;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    var exchange&#x3D;false; &#x2F;&#x2F; 交换标志 </span><br><span class="line">    for (var j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F; 相邻元素两两对比</span><br><span class="line">        [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]] &#x2F;&#x2F; 元素交换</span><br><span class="line">        exchange&#x3D;true; &#x2F;&#x2F;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!exchange)&#123; &#x2F;&#x2F; 若本趟排序未发生交换，提前终止算法</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-选择排序（Selection-Sort）-—-面试挑简历，在剩下的里面挑最好的"><a href="#2-选择排序（Selection-Sort）-—-面试挑简历，在剩下的里面挑最好的" class="headerlink" title="2. 选择排序（Selection Sort） — 面试挑简历，在剩下的里面挑最好的"></a>2. 选择排序（Selection Sort） — 面试挑简历，在剩下的里面挑最好的</h1><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="2-1-算法原理"><a href="#2-1-算法原理" class="headerlink" title="2. 1 算法原理"></a>2. 1 算法原理</h2><p>先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h2 id="2-2-算法描述"><a href="#2-2-算法描述" class="headerlink" title="2. 2 算法描述"></a>2. 2 算法描述</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中</li>
<li>选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ol>
<h2 id="2-3-动图演示"><a href="#2-3-动图演示" class="headerlink" title="2. 3 动图演示"></a>2. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldDWW9.gif" alt="ldDWW9.gif"></p>
<h2 id="2-4-js代码实现"><a href="#2-4-js代码实现" class="headerlink" title="2. 4 js代码实现"></a>2. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex &#x3D; i;</span><br><span class="line">        for (var j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F;寻找最小的数</span><br><span class="line">                minIndex &#x3D; j;                 &#x2F;&#x2F;将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[minIndex];</span><br><span class="line">        arr[minIndex] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-插入排序（Insertion-Sort）—–-麻将-扑克"><a href="#3-插入排序（Insertion-Sort）—–-麻将-扑克" class="headerlink" title="3. 插入排序（Insertion Sort）—– 麻将/扑克"></a>3. 插入排序（Insertion Sort）—– 麻将/扑克</h1><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。</p>
<h2 id="3-1-算法原理"><a href="#3-1-算法原理" class="headerlink" title="3. 1 算法原理"></a>3. 1 算法原理</h2><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h2 id="3-2-算法描述"><a href="#3-2-算法描述" class="headerlink" title="3. 2 算法描述"></a>3. 2 算法描述</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<h2 id="3-3-动图演示"><a href="#3-3-动图演示" class="headerlink" title="3. 3 动图演示"></a>3. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldDfzR.gif" alt="ldDfzR.gif"></p>
<h2 id="3-4-js代码实现"><a href="#3-4-js代码实现" class="headerlink" title="3. 4 js代码实现"></a>3. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function insertSort(arr) &#123;</span><br><span class="line">  &#x2F;&#x2F; 从1位置开始遍历arr中每元素，同时声明空变量temp</span><br><span class="line">  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (arr[i] &lt; arr[i - 1]) &#123; &#x2F;&#x2F; 如果当前元素&lt;前一个元素</span><br><span class="line">      let temp &#x3D; arr[i] &#x2F;&#x2F; 将当前元素值临时保存在temp中</span><br><span class="line">      let p &#x3D; i - 1 &#x2F;&#x2F; 定义变量 p &#x3D; i- 1</span><br><span class="line">      &#x2F;&#x2F; 循环 条件：</span><br><span class="line">      &#x2F;&#x2F; 1. p&gt;&#x3D;0且temp小于p位置的元素</span><br><span class="line">      while (p &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[p]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 循环体： 将P位置的值赋值给p的后一个元素</span><br><span class="line">        arr[p + 1] &#x3D; arr[p]</span><br><span class="line">        p-- &#x2F;&#x2F; p向前移动一个</span><br><span class="line">      &#125;</span><br><span class="line">      arr[p + 1] &#x3D; temp &#x2F;&#x2F; 将temp的值赋值给p+1位置的元素</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-快速排序（Selection-Sort）"><a href="#4-快速排序（Selection-Sort）" class="headerlink" title="4. 快速排序（Selection Sort）"></a>4. 快速排序（Selection Sort）</h1><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<h2 id="4-1-算法原理"><a href="#4-1-算法原理" class="headerlink" title="4. 1 算法原理"></a>4. 1 算法原理</h2><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<h2 id="4-2-算法描述"><a href="#4-2-算法描述" class="headerlink" title="4. 2 算法描述"></a>4. 2 算法描述</h2><p>选基准：在数据结构中选择一个元素作为基准(pivot<br>划分区：参照基准元素值的大小，划分无序区，所有小于基准元素的数据放入一个区间，所有大于基准元素的数据放入另一区间，分区操作结束后，基准元素所处的位置就是最终排序后它应该所处的位置<br>递归：对初次划分出来的两个无序区间，递归调用第 1步和第 2步的算法，直到所有无序区间都只剩下一个元素为止。</p>
<p>简单理解就是，选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。</p>
<h2 id="4-3-动图演示"><a href="#4-3-动图演示" class="headerlink" title="4. 3 动图演示"></a>4. 3 动图演示</h2><p><img src="https://i.loli.net/2020/01/04/AtNahbZF9J1dTnS.gif" alt="快速排序.gif"></p>
<h2 id="4-4-js代码实现"><a href="#4-4-js代码实现" class="headerlink" title="4. 4 js代码实现"></a>4. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function quickSort(arr)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果arr.length&lt;&#x3D;1,则直接返回arr</span><br><span class="line">    if(arr.length&lt;&#x3D;1)&#123;return arr&#125;</span><br><span class="line">    &#x2F;&#x2F; arr的元素个数&#x2F;2，再下去整，将值保存在pivotIndex中</span><br><span class="line">    var pivotIndex&#x3D;Math.floor(arr.length&#x2F;2);</span><br><span class="line">    &#x2F;&#x2F; 将arr中pivotIndex位置的元素，保存在变量pivot中</span><br><span class="line">    var pivot&#x3D;arr[pivotIndex];</span><br><span class="line">    &#x2F;&#x2F;声明空数组left和right</span><br><span class="line">    var left&#x3D;[];</span><br><span class="line">    var right&#x3D;[];</span><br><span class="line">    for(var i&#x3D;0;i&lt;arr.length;i++)&#123;  &#x2F;&#x2F; 遍历arr中每个元素</span><br><span class="line">        if(i !&#x3D;&#x3D; pivotIndex)&#123; &#x2F;&#x2F; 如果i !&#x3D;&#x3D; pivotIndex</span><br><span class="line">            if(arr[i]&lt;&#x3D;pivot)&#123; &#x2F;&#x2F; 如果当前元素值&lt;pivot</span><br><span class="line">                left.push(arr[i]); &#x2F;&#x2F; 就将当前值压入left</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                right.push(arr[i]); &#x2F;&#x2F; 就将当前值压入right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;递归</span><br><span class="line">    return quickSort(left).concat(pivot, quickSort(right)); &#x2F;&#x2F; 链接多个数组到 left 从小到大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h1><h2 id="5-1-算法原理"><a href="#5-1-算法原理" class="headerlink" title="5. 1 算法原理"></a>5. 1 算法原理</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</li>
</ul>
<h2 id="5-2-算法描述"><a href="#5-2-算法描述" class="headerlink" title="5. 2 算法描述"></a>5. 2 算法描述</h2><ul>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h2 id="5-3-js代码实现"><a href="#5-3-js代码实现" class="headerlink" title="5.3 js代码实现"></a>5.3 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap &#x3D; 1;</span><br><span class="line">    while(gap &lt; len&#x2F;3) &#123;          &#x2F;&#x2F;动态定义间隔序列</span><br><span class="line">        gap &#x3D;gap*3+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (gap; gap &gt; 0; gap &#x3D; Math.floor(gap&#x2F;3)) &#123;</span><br><span class="line">        for (var i &#x3D; gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp &#x3D; arr[i];</span><br><span class="line">            for (var j &#x3D; i-gap; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j-&#x3D;gap) &#123;</span><br><span class="line">                arr[j+gap] &#x3D; arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h1><h2 id="6-1-算法原理"><a href="#6-1-算法原理" class="headerlink" title="6. 1 算法原理"></a>6. 1 算法原理</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；<blockquote>
<p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：<br>However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.<br>然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。</p>
</blockquote>
</li>
</ul>
<p>说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。</p>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<h2 id="6-2-算法描述"><a href="#6-2-算法描述" class="headerlink" title="6. 2 算法描述"></a>6. 2 算法描述</h2><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h2 id="6-3-动图演示"><a href="#6-3-动图演示" class="headerlink" title="6. 3 动图演示"></a>6. 3 动图演示</h2><p><img src="https://i.loli.net/2020/01/04/WMFo8Au4CGah6Kv.gif" alt="归并排序.gif"></p>
<h2 id="6-4-js代码实现"><a href="#6-4-js代码实现" class="headerlink" title="6. 4 js代码实现"></a>6. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function mergeSort(arr) &#123;  &#x2F;&#x2F; 采用自上而下的递归方法</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    if(len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle &#x3D; Math.floor(len &#x2F; 2),</span><br><span class="line">        left &#x3D; arr.slice(0, middle),</span><br><span class="line">        right &#x3D; arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    while (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        if (left[0] &lt;&#x3D; right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h1><h2 id="7-1-算法原理"><a href="#7-1-算法原理" class="headerlink" title="7. 1 算法原理"></a>7. 1 算法原理</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。</li>
</ul>
<h1 id="7-2-算法描述"><a href="#7-2-算法描述" class="headerlink" title="7. 2 算法描述"></a>7. 2 算法描述</h1><ol>
<li>将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li>
<li>重复步骤 2，直到堆的尺寸为 1。</li>
</ol>
<h2 id="7-3-动图演示"><a href="#7-3-动图演示" class="headerlink" title="7. 3 动图演示"></a>7. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/05/lBK9QH.gif" alt="堆排序.gif"></p>
<h2 id="7-4-js代码实现"><a href="#7-4-js代码实现" class="headerlink" title="7. 4 js代码实现"></a>7. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var len;    &#x2F;&#x2F; 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"></span><br><span class="line">function buildMaxHeap(arr) &#123;   &#x2F;&#x2F; 建立大顶堆</span><br><span class="line">    len &#x3D; arr.length;</span><br><span class="line">    for (var i &#x3D; Math.floor(len&#x2F;2); i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapify(arr, i) &#123;     &#x2F;&#x2F; 堆调整</span><br><span class="line">    var left &#x3D; 2 * i + 1,</span><br><span class="line">        right &#x3D; 2 * i + 2,</span><br><span class="line">        largest &#x3D; i;</span><br><span class="line"></span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (largest !&#x3D; i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp &#x3D; arr[i];</span><br><span class="line">    arr[i] &#x3D; arr[j];</span><br><span class="line">    arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; arr.length-1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h1><h2 id="8-1-算法原理"><a href="#8-1-算法原理" class="headerlink" title="8. 1 算法原理"></a>8. 1 算法原理</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h2 id="8-2-算法描述"><a href="#8-2-算法描述" class="headerlink" title="8. 2 算法描述"></a>8. 2 算法描述</h2><h2 id="8-3-动图演示"><a href="#8-3-动图演示" class="headerlink" title="8. 3 动图演示"></a>8. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/05/lBKq1g.gif" alt="计数排序.gif"></p>
<h2 id="8-4-js代码实现"><a href="#8-4-js代码实现" class="headerlink" title="8. 4 js代码实现"></a>8. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket &#x3D; new Array(maxValue+1),</span><br><span class="line">        sortedIndex &#x3D; 0;</span><br><span class="line">        arrLen &#x3D; arr.length,</span><br><span class="line">        bucketLen &#x3D; maxValue + 1;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var j &#x3D; 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] &#x3D; j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h1><h2 id="9-1-算法原理"><a href="#9-1-算法原理" class="headerlink" title="9. 1 算法原理"></a>9. 1 算法原理</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<h2 id="9-2-算法描述"><a href="#9-2-算法描述" class="headerlink" title="9. 2 算法描述"></a>9. 2 算法描述</h2><h3 id="1-什么时候最快"><a href="#1-什么时候最快" class="headerlink" title="1. 什么时候最快"></a>1. 什么时候最快</h3>当输入的数据可以均匀的分配到每一个桶中。<h3 id="2-什么时候最慢"><a href="#2-什么时候最慢" class="headerlink" title="2. 什么时候最慢"></a>2. 什么时候最慢</h3>当输入的数据被分配到了同一个桶中。<h2 id="9-3-动图演示"><a href="#9-3-动图演示" class="headerlink" title="9. 3 动图演示"></a>9. 3 动图演示</h2></li>
</ul>
<h2 id="9-4-js代码实现"><a href="#9-4-js代码实现" class="headerlink" title="9. 4 js代码实现"></a>9. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var i;</span><br><span class="line">    var minValue &#x3D; arr[0];</span><br><span class="line">    var maxValue &#x3D; arr[0];</span><br><span class="line">    for (i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE &#x3D; 5;            &#x2F;&#x2F; 设置桶的默认数量为5</span><br><span class="line">    bucketSize &#x3D; bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount &#x3D; Math.floor((maxValue - minValue) &#x2F; bucketSize) + 1;   </span><br><span class="line">    var buckets &#x3D; new Array(bucketCount);</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) &#x2F; bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.length &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      &#x2F;&#x2F; 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j &#x3D; 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h1><h2 id="10-1-算法原理"><a href="#10-1-算法原理" class="headerlink" title="10. 1 算法原理"></a>10. 1 算法原理</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h2 id="10-2-算法描述"><a href="#10-2-算法描述" class="headerlink" title="10. 2 算法描述"></a>10. 2 算法描述</h2><h3 id="1-基数排序-vs-计数排序-vs-桶排序"><a href="#1-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="1. 基数排序 vs 计数排序 vs 桶排序"></a>1. 基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有三种方法：<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；<h2 id="10-3-动图演示"><a href="#10-3-动图演示" class="headerlink" title="10. 3 动图演示"></a>10. 3 动图演示</h2></li>
</ul>
<ol start="2">
<li>LSD 基数排序动图演示<br><img src="https://s2.ax1x.com/2020/01/05/lBQkPf.gif" alt="基数排序.gif"><h2 id="10-4-js代码实现"><a href="#10-4-js代码实现" class="headerlink" title="10. 4 js代码实现"></a>10. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LSD Radix Sort</span><br><span class="line">var counter &#x3D; [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod &#x3D; 10;</span><br><span class="line">    var dev &#x3D; 1;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; maxDigit; i++, dev *&#x3D; 10, mod *&#x3D; 10) &#123;</span><br><span class="line">        for(var j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket &#x3D; parseInt((arr[j] % mod) &#x2F; dev);</span><br><span class="line">            if(counter[bucket]&#x3D;&#x3D;null) &#123;</span><br><span class="line">                counter[bucket] &#x3D; [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos &#x3D; 0;</span><br><span class="line">        for(var j &#x3D; 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value &#x3D; null;</span><br><span class="line">            if(counter[j]!&#x3D;null) &#123;</span><br><span class="line">                while ((value &#x3D; counter[j].shift()) !&#x3D; null) &#123;</span><br><span class="line">                      arr[pos++] &#x3D; value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.ax1x.com/2020/01/05/lBQTSS.png" alt="排序算法.png"><br>以上就是十大经典算法，算法对于前端来说并不是一个十分熟悉的领域，但是排序算法算是算法里比较入门的，还是需要掌握的，毕竟即使是为了面试也是要准备的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a><br>一本关于排序算法的 GitBook 在线书籍 《十大经典排序算法》，多语言实现。</p>
<p><a href="http://www.sohu.com/a/136157205_671058" target="_blank" rel="noopener">http://www.sohu.com/a/136157205_671058</a><br>技术面试宝典： 很全面的算法和数据结构知识（含代码实现）下篇</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/03/FE-guide-store/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/FE-guide-store/" class="post-title-link" itemprop="url">前端常见知识点整理 ---- 浏览器存储</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-03 12:37:22 / 修改时间：12:38:14" itemprop="dateCreated datePublished" datetime="2020-01-03T12:37:22+08:00">2020-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="cookie，localStorage，sessionStorage，indexDB"><a href="#cookie，localStorage，sessionStorage，indexDB" class="headerlink" title="cookie，localStorage，sessionStorage，indexDB"></a>cookie，localStorage，sessionStorage，indexDB</h1><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody><tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
<td>除非被清理，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
<td>无限制</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 header 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody></table>
<p>从上表可以看到， <code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p>
<p>对于 <code>cookie</code> ，我们还需要注意安全性。<br>| 属性      | 作用                                                           |<br>| ——— | ————————————————————– |<br>| value     | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |<br>| http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击                         |<br>| secure    | 只能在协议为 HTTPS 的请求中携带                                |<br>| same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击          |</p>
<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><blockquote>
<p>Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。</p>
</blockquote>
<p>目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.js</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(&#39;sw.js&#39;)</span><br><span class="line">    .then(function(registration) &#123;</span><br><span class="line">      console.log(&#39;service worker 注册成功&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(err) &#123;</span><br><span class="line">      console.log(&#39;servcie worker 注册失败&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; sw.js</span><br><span class="line">&#x2F;&#x2F; 监听 &#96;install&#96; 事件，回调中缓存所需文件</span><br><span class="line">self.addEventListener(&#39;install&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(&#39;my-cache&#39;).then(function(cache) &#123;</span><br><span class="line">      return cache.addAll([&#39;.&#x2F;index.html&#39;, &#39;.&#x2F;index.js&#39;])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拦截所有请求事件</span><br><span class="line">&#x2F;&#x2F; 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br><span class="line">self.addEventListener(&#39;fetch&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(function(response) &#123;</span><br><span class="line">      if (response) &#123;</span><br><span class="line">        return response</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#39;fetch source&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code> 已经启动了<br>在 <code>Cache</code> 中也可以发现我们所需的文件已被缓存</p>
<p>当我们重新刷新页面可以发现我们缓存的数据是从 <code>Service Worker</code> 中读取的</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/03/why-0.1-plus-0.2-not-equals-0.3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/why-0.1-plus-0.2-not-equals-0.3/" class="post-title-link" itemprop="url">为什么 0.1 + 0.2 != 0.3</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-03 12:10:00 / 修改时间：12:10:21" itemprop="dateCreated datePublished" datetime="2020-01-03T12:10:00+08:00">2020-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。</p>
<p>我们都知道计算机表示十进制是采用二进制表示的，所以 0.1 在二进制表示为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; (0011) 表示循环</span><br><span class="line">0.1 &#x3D; 2^-4 * 1.10011(0011)</span><br></pre></td></tr></table></figure>
<p>那么如何得到这个二进制的呢，我们可以来演算下</p>
<p>小数算二进制和整数不同。乘法计算时，只计算小数位，整数位用作每一位的二进制，并且得到的第一位为最高位。所以我们得出 <code>0.1 = 2^-4 * 1.10011(0011)</code>，那么 <code>0.2</code> 的演算也基本如上所示，只需要去掉第一步乘法，所以得出 <code>0.2 = 2^-3 * 1.10011(0011)</code>。</p>
<p>回来继续说 <code>IEEE 754</code> 双精度。六十四位中符号位占一位，整数位占十一位，其余五十二位都为小数位。因为 <code>0.1</code> 和 <code>0.2</code> 都是无限循环的二进制了，所以在小数位末尾处需要判断是否进位（就和十进制的四舍五入一样）。</p>
<p>所以 <code>2^-4 * 1.10011...001</code> 进位后就变成了 <code>2^-4 * 1.10011(0011 * 12次)010</code> 。那么把这两个二进制加起来会得出 <code>2^-2 * 1.0011(0011 * 11次)0100</code> , 这个值算成十进制就是 <code>0.30000000000000004</code></p>
<p>下面说一下原生解决办法，如下代码所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">parseFloat((0.1 + 0.2).toFixed(10))</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/03/FE-guide-async-Proxy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/FE-guide-async-Proxy/" class="post-title-link" itemprop="url">前端常见知识点整理 ---- Proxy</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-03 12:00:00 / 修改时间：12:00:55" itemprop="dateCreated datePublished" datetime="2020-01-03T12:00:00+08:00">2020-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p><code>Proxy</code> 是 <code>ES6</code> 中新增的功能，可以用来自定义对象中的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let p &#x3D; new Proxy(target, handler);</span><br><span class="line">&#x2F;&#x2F; &#96;target&#96; 代表需要添加代理的对象</span><br><span class="line">&#x2F;&#x2F; &#96;handler&#96; 用来自定义对象中的操作</span><br></pre></td></tr></table></figure>
<p>可以很方便的使用 <code>Proxy</code> 来实现一个数据绑定和监听</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">let onWatch &#x3D; (obj, setBind, getLogger) &#x3D;&gt; &#123;</span><br><span class="line">  let handler &#x3D; &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      return Reflect.get(target, property, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value);</span><br><span class="line">      return Reflect.set(target, property, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  return new Proxy(obj, handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123; a: 1 &#125;</span><br><span class="line">let value</span><br><span class="line">let p &#x3D; onWatch(obj, (v) &#x3D;&gt; &#123;</span><br><span class="line">  value &#x3D; v</span><br><span class="line">&#125;, (target, property) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;Get &#39;$&#123;property&#125;&#39; &#x3D; $&#123;target[property]&#125;&#96;);</span><br><span class="line">&#125;)</span><br><span class="line">p.a &#x3D; 2 &#x2F;&#x2F; bind &#96;value&#96; to &#96;2&#96;</span><br><span class="line">p.a &#x2F;&#x2F; -&gt; Get &#39;a&#39; &#x3D; 2</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/03/FE-guide-async-await/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/FE-guide-async-await/" class="post-title-link" itemprop="url">前端常见知识点整理 ---- async 和 await</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-03 11:52:00 / 修改时间：11:53:21" itemprop="dateCreated datePublished" datetime="2020-01-03T11:52:00+08:00">2020-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h1><p>一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">async function test() &#123;</span><br><span class="line">  return &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test()); &#x2F;&#x2F; -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>可以把 <code>async</code> 看成将函数返回值使用 <code>Promise.resolve()</code> 包裹了下。<br><code>await</code> 只能在 <code>async</code> 函数中使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function sleep() &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;finish&#39;)</span><br><span class="line">      resolve(&quot;sleep&quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">  let value &#x3D; await sleep();</span><br><span class="line">  console.log(&quot;object&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</p>
<p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>
<p>下面来看一个使用 <code>await</code> 的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var a &#x3D; 0</span><br><span class="line">var b &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  a &#x3D; a + await 10</span><br><span class="line">  console.log(&#39;2&#39;, a) &#x2F;&#x2F; -&gt; &#39;2&#39; 10</span><br><span class="line">  a &#x3D; (await 10) + a</span><br><span class="line">  console.log(&#39;3&#39;, a) &#x2F;&#x2F; -&gt; &#39;3&#39; 20</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line">console.log(&#39;1&#39;, a) &#x2F;&#x2F; -&gt; &#39;1&#39; 1</span><br></pre></td></tr></table></figure>
<p>对于以上代码你可能会有疑惑，这里说明下原理</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为在 <code>await</code> 内部实现了 <code>generators</code> ， <code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li>
<li>因为 <code>await</code> 是异步操作，遇到 <code>await</code> 就会立即返回一个 <code>pending</code> 状态的 <code>Promise</code> 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li>
<li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li>
<li>然后后面就是常规执行代码了</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/03/FE-guide-Map-FlatMap-Reduce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/FE-guide-Map-FlatMap-Reduce/" class="post-title-link" itemprop="url">前端常见知识点整理 ---- Map、FlatMap 和 Reduce</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-03 11:35:00 / 修改时间：11:35:18" itemprop="dateCreated datePublished" datetime="2020-01-03T11:35:00+08:00">2020-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Map、FlatMap-和-Reduce"><a href="#Map、FlatMap-和-Reduce" class="headerlink" title="Map、FlatMap 和 Reduce"></a>Map、FlatMap 和 Reduce</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><p><code>Map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 <code>append</code> 到新的数组中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">[1, 2, 3].map((v) &#x3D;&gt; v + 1) &#x2F;&#x2F; -&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure>
<p><code>Map</code> 有三个参数，分别是<strong><em>当前索引元素</em></strong>，<strong><em>索引</em></strong>，<strong><em>原数组</em></strong></p>
<h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a><code>FlatMap</code></h2><p><code>FlatMap</code> 和 <code>map</code> 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 <code>FlatMap</code> 看成是 <code>map + flatten</code> ，目前该函数在浏览器中还不支持。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">[1, [2], 3].flatMap((v) &#x3D;&gt; v + 1) &#x2F;&#x2F; -&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>如果想将一个多维数组彻底的降维，可以这样实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const flattenDeep &#x3D; (arr) &#x3D;&gt; Array.isArray(arr)</span><br><span class="line">  ? arr.reduce( (a, b) &#x3D;&gt; [...a, ...flattenDeep(b)] , [])</span><br><span class="line">  : [arr]</span><br><span class="line"></span><br><span class="line">flattenDeep([1, [[2], [3, [4]], 5]])</span><br></pre></td></tr></table></figure>

<h2 id="Reduce-升序执行"><a href="#Reduce-升序执行" class="headerlink" title="Reduce 升序执行"></a>Reduce 升序执行</h2><p><code>Reduce</code> 作用是数组中的值组合起来，最终得到一个值<br><code>reduce()</code> 方法对数组中的每个元素执行一个由您提供的 <code>reducer</code> 函数(升序执行)，将其结果汇总为单个返回值。</p>
<p><code>reducer</code> 函数接收4个参数:</p>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)<br>您的 <code>reducer</code> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[a, b].reduce((a, b) &#x3D;&gt; a(b()))</span><br><span class="line">&#x2F;&#x2F; -&gt; 2 1</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://lixuguang.github.io/2020/01/03/FE-guide-Generator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="李旭光">
      <meta itemprop="description" content="学习 | 生活 | 一切">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="李旭光的技术博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/01/03/FE-guide-Generator/" class="post-title-link" itemprop="url">前端常见知识点整理 ---- Generator 生成器</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-01-03 11:05:00 / 修改时间：11:05:25" itemprop="dateCreated datePublished" datetime="2020-01-03T11:05:00+08:00">2020-01-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index">
                    <span itemprop="name">前端技术</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a><code>Generator</code> 实现</h1><p><code>Generator</code> 是 <code>ES6</code> 中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 * 表示这是一个 Generator 函数</span><br><span class="line">&#x2F;&#x2F; 内部可以通过 yield 暂停代码</span><br><span class="line">&#x2F;&#x2F; 通过调用 next 恢复执行</span><br><span class="line">function* test() &#123;</span><br><span class="line">  let a &#x3D; 1 + 2;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; test();</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: 3, done: false &#125;</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cb 也就是编译过的 test 函数</span><br><span class="line">function generator(cb) &#123;</span><br><span class="line">  return (function() &#123;</span><br><span class="line">    var object &#x3D; &#123;</span><br><span class="line">      next: 0,</span><br><span class="line">      stop: function() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      next: function() &#123;</span><br><span class="line">        var ret &#x3D; cb(object);</span><br><span class="line">        if (ret &#x3D;&#x3D;&#x3D; undefined) return &#123; value: undefined, done: true &#125;;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: false</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果你使用 babel 编译后可以发现 test 函数变成了这样</span><br><span class="line">function test() &#123;</span><br><span class="line">  var a;</span><br><span class="line">  return generator(function(_context) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      switch ((_context.prev &#x3D; _context.next)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可以发现通过 yield 将代码分割成几块</span><br><span class="line">        &#x2F;&#x2F; 每次执行 next 函数就执行一块代码</span><br><span class="line">        &#x2F;&#x2F; 并且表明下次需要执行哪块代码</span><br><span class="line">        case 0:</span><br><span class="line">          a &#x3D; 1 + 2;</span><br><span class="line">          _context.next &#x3D; 4;</span><br><span class="line">          return 2;</span><br><span class="line">        case 4:</span><br><span class="line">          _context.next &#x3D; 6;</span><br><span class="line">          return 3;</span><br><span class="line">		&#x2F;&#x2F; 执行完毕</span><br><span class="line">        case 6:</span><br><span class="line">        case &quot;end&quot;:</span><br><span class="line">          return _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="李旭光"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">李旭光</p>
  <div class="site-description" itemprop="description">学习 | 生活 | 一切</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">45</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lixuguang" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lixuguang" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:lixuguang316@gmail.com" title="E-Mail → mailto:lixuguang316@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title">
      <i class="fa fa-fw fa-link"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://he8hepeng.github.io/" title="http:&#x2F;&#x2F;he8hepeng.github.io" rel="noopener" target="_blank">何鹏</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">李旭光</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.6.0
  </div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body>
</html>
