<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript 设计模式 Design Pattern</title>
    <url>/2020/01/13/Javascript-Design-Pattern/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在整理自己的知识体系，一方面为了夯实基础，另一方面夜查缺补漏、重新理解，设计模式之前看过大概三四次，从最开始一点都不懂，到后面看了几遍以后慢慢理解，今天再次整理一下，希望这一遍下来之后能更加透彻的理解什么是设计模式。</p>
<a id="more"></a>

<h1 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h1><blockquote>
<p>设计模式的定义：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案<br>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p>
</blockquote>
<blockquote>
<p>　　使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。   —- 百度百科</p>
</blockquote>
<p>不知道大家看了上面的定义以后是什么感受，说实话我第一次看到这句话并没有什么深刻的认识，什么面向对象的软件设计，什么针对特定问题，什么优雅的解决方案，这都说的是什么，后来我看了几遍之后，上面这句话用我的理解翻译如下：</p>
<blockquote>
<p>软件开发过程中，解决某一类问题用到的一系列套路</p>
</blockquote>
<p>这就是我对设计模式的认识。当然这也不仅仅是我自己的认识，在跟其他的一些开发人员交流时，很多人都是这么认为的。</p>
<p>这些解决问题的方案实在是太好用了，所以大神就把它们抽象出来，然后起了个名字-就叫做设计模式了。</p>
<p>这么说大家可能还是不太明白，举个开发过程中可能遇到的实际例子吧。</p>
<blockquote>
<p>当系统中某个接口的结构已经无法满足我们现在的业务需求，但又不能改动这个接口，因为可能原来的系统很多功能都依赖于这个接口，改动接口会牵扯到太多文件。那么这种场景下我们该如何解决这个问题呢？通常我们需要新增一个接口，兼容原来的接口和新的业务需求参数。<br>因此应对这种场景，我们可以很快地想到可以用适配器模式来解决这个问题。</p>
</blockquote>
<p>这就是设计模式的应用，实际上也许你还不知道设计模式这个词，但是你已经在工作中频繁的用到了设计模式，下面我们就来看看到底有哪些设计模式。</p>
<p>哦，对了，设计模式并不依赖于语言，它本身更像是一种软件的设计思想，因为我是一个前端，所以接下来具体实现的时候我会使用js来实现设计模式的用法。</p>
<h1 id="学习设计模式"><a href="#学习设计模式" class="headerlink" title="学习设计模式"></a>学习设计模式</h1><p>目前被普遍接受的经典的设计模式共有 <strong>23</strong> 种，而这23种设计模式又分为了 <strong>3大类</strong> ，看过一张图这里拿过来镇贴。<br><img src="https://s2.ax1x.com/2020/01/13/lHgD4H.jpg" alt="lHgD4H.jpg"><br>他们分别是</p>
<ul>
<li>创建型模式</li>
<li>结构型模式</li>
<li>行为型模式</li>
</ul>
<p>接下来，我将会将这23种，3大类设计模式一个个的拆解开来，跟大家一起学习一下，设计模式有哪些内容。</p>
<h2 id="创建型模式-5个"><a href="#创建型模式-5个" class="headerlink" title="创建型模式 5个"></a>创建型模式 5个</h2><p>这类模式用于<strong>对象的生成</strong>和<strong>生命周期的管理</strong>。<br>创建型模式可以决定生成哪些对象，提高了程序的灵活性。具体属于此类的模式清单如下，共有 <strong>5</strong> 个：</p>
<ul>
<li>抽象工厂模式（Abstract Factory）</li>
<li>构建者模式（Builder）</li>
<li>工厂方法模式（Factory Method）</li>
<li>原型模式（Prototype）</li>
<li>单例模式（Singleton）</li>
</ul>
<h3 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h3><p>抽象工厂模式究竟是什么？</p>
<h3 id="构建者模式（Builder）"><a href="#构建者模式（Builder）" class="headerlink" title="构建者模式（Builder）"></a>构建者模式（Builder）</h3><h3 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h3><h3 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h3><h3 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h3><h2 id="结构型模式-7个"><a href="#结构型模式-7个" class="headerlink" title="结构型模式 7个"></a>结构型模式 7个</h2><ul>
<li>适配器模式（Adapter）</li>
<li>桥接模式（Bridge）</li>
<li>组合模式（Compositor）</li>
<li>装饰着模式（Decorator）</li>
<li>外观模式（Facade）</li>
<li>享元模式（Flyweight）</li>
<li>代理模式（Proxy）</li>
</ul>
<h2 id="行为型模式-11个"><a href="#行为型模式-11个" class="headerlink" title="行为型模式 11个"></a>行为型模式 11个</h2><ul>
<li>职责链模式（Chian of Responsibility）</li>
<li>命名模式（Command）</li>
<li>解释器模式（Interpreter）</li>
<li>迭代器模式（Iterator）</li>
<li>中介者模式（Mediator）</li>
<li>备忘录模式（Memento）</li>
<li>观察者模式（Observer）</li>
<li>状态模式（State）</li>
<li>策略模式（Strategy）</li>
<li>模板方法模式（Template Method）</li>
<li>访问者模式（Visitor）</li>
</ul>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Design Pattern</tag>
        <tag>套路</tag>
      </tags>
  </entry>
  <entry>
    <title>给我的Hexo博客添加文章内容搜索功能</title>
    <url>/2020/01/13/hexo-search/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年我下定决心一定要好好地写博客，完善博客的内容，所以最近把原来记在各种笔记中的文章内容都一一转移到了博客，内容一多想找一篇文章时就变得很麻烦，我得去归档中或者分类中一篇篇的找，所以我觉得是时候该给我的博客添加搜索的功能了，我看了博客的config文件，其中并没有搜索相关的配置，我又看了主题的配置文件，这下让我找到了，有个local_search的选项，于是我就开始了博客搜索的研究。</p>
<a id="more"></a>
<h2 id="主题里的搜索配置"><a href="#主题里的搜索配置" class="headerlink" title="主题里的搜索配置"></a>主题里的搜索配置</h2><p>这段代码是这样的，实际上我只需要把 <code>enable</code> 从 <code>false</code> 变成 <code>true</code> 就好了</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>然后我又看了一下上面提供的依赖地址，这里还需要做两步，一个是安装搜索的依赖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb</span><br></pre></td></tr></table></figure>
<p>接着就是在博客系统的配置最下方加入下面这段话</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">content:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br></pre></td></tr></table></figure>
<p>到这里如果没什么问题，那么搜索功能就加上了，怎么样简单吧。如果你遇到什么问题，可以到上面的地址看一下，上面有详细的说明，我这里就不贴代码了。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>希望大家都能丰富自己的技术博客，拥有属于自己的一片技术天地。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>blog - hexo - next - search</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 继承类型</title>
    <url>/2020/01/13/FE-guide-inherit2/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<p>有下面两个类，下面实现Man继承People：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = <span class="string">'prople'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">People.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'吃东西啦'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="string">'black'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><blockquote>
<p>将父类指向子类的原型。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">Man.prototype = <span class="keyword">new</span> People();</span><br></pre></td></tr></table></figure>
<p>缺点：原型是所有子类实例共享的，改变一个其他也会改变。</p>
<h2 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h2><blockquote>
<p>在子类构造函数中调用父类构造函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    People.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：不能继承父类原型，函数在构造函数中，每个子类实例不能共享函数，浪费内存。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote>
<p>使用构造继承继承父类参数，使用原型继承继承父类函数</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    People.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.prototype = People.prototype;</span><br></pre></td></tr></table></figure>
<p>缺点：父类原型和子类原型是同一个对象，无法区分子类真正是由谁构造。</p>
<h2 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h2><blockquote>
<p>在组合继承的基础上，子类继承一个由父类原型生成的空对象。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    People.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Man.prototype = <span class="built_in">Object</span>.create(People.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">        value: Man</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="inherits函数"><a href="#inherits函数" class="headerlink" title="inherits函数"></a>inherits函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">ctor, superCtor</span>) </span>&#123;</span><br><span class="line">  ctor.super_ = superCtor;</span><br><span class="line">  ctor.prototype = <span class="built_in">Object</span>.create(superCtor.prototype, &#123;</span><br><span class="line">    <span class="keyword">constructor</span>: &#123;</span><br><span class="line">      value: ctor,</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Man</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  People.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">inherits(Man, People);</span><br><span class="line"></span><br><span class="line">Man.prototype.fun = ...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- promise</title>
    <url>/2020/01/13/do-it-yourselfery-promise/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试中时常会出现需要手动实现某个功能的要求，所以我准备整理一个自己动手实现系列文章，这一次呢就是自己动手实现 <code>promise</code></p>
<h2 id="实现-promise-思路"><a href="#实现-promise-思路" class="headerlink" title="实现 promise 思路"></a>实现 <code>promise</code> 思路</h2><p><strong>基础步骤</strong></p>
<ol>
<li>设定三个状态 <code>PENDING</code> 、 <code>FULFILLED</code> 、 <code>REJECTED</code>  ，只能由 <code>PENDING</code> 改变为 <code>FULFILLED</code> 、 <code>REJECTED</code> ，并且只能改变一次</li>
<li><code>MyPromise</code> 接收一个函数 <code>executor</code> ， <code>executor</code> 有两个参数 <code>resolve</code> 方法和 <code>reject</code> 方法</li>
<li><code>resolve</code> 将 <code>PENDING</code> 改变为 <code>FULFILLED</code></li>
<li><code>reject</code> 将 <code>PENDING</code> 改变为 <code>FULFILLED</code></li>
<li><code>promise</code> 变为 <code>FULFILLED</code> 状态后具有一个唯一的 <code>value</code></li>
<li><code>promise</code> 变为 <code>REJECTED</code> 状态后具有一个唯一的 <code>reason</code></li>
</ol>
<p>** <code>then</code> 方法**</p>
<ol>
<li><code>then</code> 方法接受两个参数 <code>onFulfilled</code> 、 <code>onRejected</code> ，它们分别在状态由 <code>PENDING</code> 改变为 <code>FULFILLED</code> 、 <code>REJECTED</code> 后调用</li>
<li>一个 <code>promise</code> 可绑定多个 <code>then</code> 方法</li>
<li><code>then</code> 方法可以同步调用也可以异步调用</li>
<li>同步调用：状态已经改变，直接调用 <code>onFulfilled</code> 方法</li>
<li>异步调用：状态还是 <code>PENDING</code> ，将 <code>onFulfilled</code> 、 <code>onRejected</code> 分别加入两个函数数组 <code>onFulfilledCallbacks</code> 、 <code>onRejectedCallbacks</code> ，当异步调用 <code>resolve</code> 和 <code>reject</code> 时，将两个数组中绑定的事件循环执行。</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义MyPromise模拟Promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;func&#125;</span> </span>executor 接收函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.state = PENDING; <span class="comment">// 默认状态为 pending</span></span><br><span class="line">	<span class="keyword">this</span>.value = <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">this</span>.reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义成功失败的函数数组</span></span><br><span class="line">	<span class="keyword">this</span>.onFulfilledCallbacks = [];</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义成功回调</span></span><br><span class="line">	<span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">			<span class="keyword">this</span>.state = FULFILLED;</span><br><span class="line">			<span class="keyword">this</span>.value = value;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.onFulfilledCallbacks.forEach(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">				func();</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义失败回调</span></span><br><span class="line">	<span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">			<span class="keyword">this</span>.state = REJECTED;</span><br><span class="line">			<span class="keyword">this</span>.reason = reason;</span><br><span class="line">			<span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">func</span> =&gt;</span> &#123;</span><br><span class="line">				func();</span><br><span class="line">			&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		executor(resolve, reject);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">		reject(reason);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">		<span class="keyword">case</span> FULFILLED:</span><br><span class="line">			onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> REJECTED:</span><br><span class="line">			onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PENDING:</span><br><span class="line">			<span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="then方法异步调用"><a href="#then方法异步调用" class="headerlink" title="then方法异步调用"></a>then方法异步调用</h2><p>如下面的代码：输入顺序是：1、2、ConardLi</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="string">'ConardLi'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>虽然 <code>resolve</code> 是同步执行的，我们必须保证 <code>then</code> 是异步调用的，我们用 <code>setTimeout</code> 来模拟异步调用（并不能实现微任务和宏任务的执行机制，只是保证异步调用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled != <span class="string">'function'</span>) &#123;</span><br><span class="line">		onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected != <span class="string">'function'</span>) &#123;</span><br><span class="line">		onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> reason;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">		<span class="keyword">case</span> FULFILLED:</span><br><span class="line">			setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">			&#125;, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> REJECTED:</span><br><span class="line">			setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">			&#125;, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> PENDING:</span><br><span class="line">			<span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">				&#125;, <span class="number">0</span>);</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">				&#125;, <span class="number">0</span>);</span><br><span class="line">			&#125;)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="then方法链式调用"><a href="#then方法链式调用" class="headerlink" title="then方法链式调用"></a>then方法链式调用</h2><p>保证链式调用，即 <code>then</code> 方法中要返回一个新的 <code>promise</code> ，并将 <code>then</code> 方法的返回值进行 <code>resolve</code> 。</p>
<p><em>注意：这种实现并不能保证 <code>then</code> 方法中返回一个新的 <code>promise</code> ，只能保证链式调用</em>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> onFulfilled != <span class="string">'function'</span>) &#123;</span><br><span class="line">		onFulfilled = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> value;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">typeof</span> onRejected != <span class="string">'function'</span>) &#123;</span><br><span class="line">		onRejected = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">			<span class="keyword">throw</span> reason;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个新的MyPromise对象</span></span><br><span class="line">	<span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">			<span class="keyword">case</span> FULFILLED:</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">						resolve(x);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">						reject(reason);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> REJECTED:</span><br><span class="line">				setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">						resolve(x);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">						reject(reason);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> PENDING:</span><br><span class="line">				<span class="keyword">this</span>.onFulfilledCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">const</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">							resolve(x);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">							reject(reason);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, <span class="number">0</span>);</span><br><span class="line">				&#125;)</span><br><span class="line">				<span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">					setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">const</span> x = onRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">							resolve(x);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">							reject(reason);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, <span class="number">0</span>);</span><br><span class="line">				&#125;)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="catch方法"><a href="#catch方法" class="headerlink" title="catch方法"></a>catch方法</h2><p>若上面没有定义 <code>reject</code> 方法，所有的异常会走向 <code>catch</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line">MyPromise.prototype.catch = <span class="function"><span class="keyword">function</span>(<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="finally方法"><a href="#finally方法" class="headerlink" title="finally方法"></a>finally方法</h2><p>不管是 <code>resolve</code> 还是 <code>reject</code> 都会调用 <code>finally</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line">MyPromise.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">		fn();</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;, reason =&gt; &#123;</span><br><span class="line">		fn();</span><br><span class="line">		<span class="keyword">throw</span> reason;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h2><p><code>Promise.resolve</code> 用来生成一个直接处于 <code>FULFILLED</code> 状态的 <code>Promise</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h2><p><code>Promise.reject</code> 用来生成一个直接处于 <code>REJECTED</code> 状态的 <code>Promise</code> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.reject = <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="all方法"><a href="#all方法" class="headerlink" title="all方法"></a>all方法</h2><p>接受一个 <code>promise</code> 数组，当所有 <code>promise</code> 状态 <code>resolve</code> 后，执行 <code>resolve</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">			resolve([]);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> result = [];</span><br><span class="line">			<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">				promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">					result[i] = data;</span><br><span class="line">					<span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">						resolve(result);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;, err =&gt; &#123;</span><br><span class="line">					reject(err);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="race方法"><a href="#race方法" class="headerlink" title="race方法"></a>race方法</h2><p>接受一个 <code>promise</code> 数组，当有一个 <code>promise</code> 状态 <code>resolve</code> 后，执行 <code>resolve</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line">MyPromise.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">			resolve();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">				promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">					resolve(data);</span><br><span class="line">				&#125;, err =&gt; &#123;</span><br><span class="line">					reject(err);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如此一个自定义的 <code>promise</code> 就实现了，怎么样学回来吗？</p>
]]></content>
      <categories>
        <category>自己动手实现系列</category>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title>自己动手实现系列 ---- jsonp</title>
    <url>/2020/01/09/do-it-yourselfery-jsonp/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>面试中时常会出现需要手动实现某个功能的要求，所以我准备整理一个自己动手实现系列文章，第一个呢就是自己动手实现 <code>jsonp</code></p>
<h2 id="实现-jsonp-思路"><a href="#实现-jsonp-思路" class="headerlink" title="实现 jsonp 思路"></a>实现 <code>jsonp</code> 思路</h2><ol>
<li>将传入的data数据转化为url字符串形式</li>
<li>处理url中的回调函数</li>
<li>创建一个script标签并插入到页面中</li>
<li>挂载回调函数</li>
</ol>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">(function (window,document) &#123;</span><br><span class="line">	&quot;use strict&quot;;</span><br><span class="line">	var jsonp &#x3D; function (url,data,callback) &#123;</span><br><span class="line">		&#x2F;&#x2F; 1.将传入的data数据转化为url字符串形式</span><br><span class="line">		&#x2F;&#x2F; &#123;id:1,name:&#39;jack&#39;&#125; &#x3D;&gt; id&#x3D;1&amp;name&#x3D;jack</span><br><span class="line">		var dataString &#x3D; url.indexof(&#39;?&#39;) &#x3D;&#x3D; -1? &#39;?&#39;: &#39;&amp;&#39;;</span><br><span class="line">		for(var key in data)&#123;</span><br><span class="line">			dataString +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 2 处理url中的回调函数</span><br><span class="line">		&#x2F;&#x2F; cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span><br><span class="line">		var cbFuncName &#x3D; &#39;my_json_cb_&#39; + Math.random().toString().replace(&#39;.&#39;,&#39;&#39;);</span><br><span class="line">		dataString +&#x3D; &#39;callback&#x3D;&#39; + cbFuncName;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 3.创建一个script标签并插入到页面中</span><br><span class="line">		var scriptEle &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">		scriptEle.src &#x3D; url + dataString;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; 4.挂载回调函数</span><br><span class="line">		window[cbFuncName] &#x3D; function (data) &#123;</span><br><span class="line">			callback(data); &#x2F;&#x2F; 处理完回调函数的数据之后，删除jsonp的script标签</span><br><span class="line">			document.body.removeChild(scriptEle);</span><br><span class="line">		&#125;</span><br><span class="line">		document.body.appendChild(scriptEle);</span><br><span class="line">	&#125;</span><br><span class="line">	window.$jsonp &#x3D; jsonp;</span><br><span class="line">&#125;)(window,document)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>自己动手实现系列</category>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确使用时间[转载]</title>
    <url>/2020/01/09/career/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近各种技术博客，各种技术文章，各种牛人前辈的学习心得都在看，最近看了一个不错的文章叫做《如何正确使用时间》<br>感觉还是很不错的，特别适合年轻的程序员看一下。下面将全文贴在下方，如果需要也可以去原文查看。</p>
<p><a href="http://caibaojian.com/interview-map/career/" target="_blank" rel="noopener">原文</a></p>
<p>你是否时常会焦虑时间过的很快，没时间学习，本文将会分享一些个人的见解。</p>
<h2 id="花时间补基础，读文档"><a href="#花时间补基础，读文档" class="headerlink" title="花时间补基础，读文档"></a>花时间补基础，读文档</h2><p>在工作中我们时常会花很多时间去 debug，但是你是否发现很多问题最终只是你基础不扎实或者文档没有仔细看。</p>
<p>基础是你技术的基石，一定要花时间打好基础，而不是追各种新的技术。一旦你的基础扎实，学习各种新的技术也肯定不在话下，因为新的技术，究其根本都是相通的。</p>
<p>文档同样也是一门技术的基础。一个优秀的库，开发人员肯定已经把如何使用这个库都写在文档中了，仔细阅读文档一定会是少写 bug 的最省事路子。</p>
<h2 id="学会搜索"><a href="#学会搜索" class="headerlink" title="学会搜索"></a>学会搜索</h2><p>如果你还在使用百度搜索编程问题，请尽快抛弃这个垃圾搜索引擎。同样一个关键字，使用百度和谷歌，谷歌基本完胜的。即使你使用中文在谷歌中搜索，得到的结果也往往是谷歌占优，所以如果你想迅速的通过搜索引擎来解决问题，那一定是谷歌。</p>
<h2 id="学点英语"><a href="#学点英语" class="headerlink" title="学点英语"></a>学点英语</h2><p>说到英语，一定是大家所最不想听的。其实我一直认为程序员学习英语是简单的，因为我们工作中是一直接触着英语，并且看懂技术文章，文档所需要的单词量是极少的。我时常在群里看到大家发出一个问题的截图问什么原因，其实在截图中英语已经很明白的说明了问题的所在，如果你的英语过关，完全不需要浪费时间来提问和搜索。所以我认为学点英语也是节省时间中很重要的一点。</p>
<p>那么如何去学习呢，chrome 装个翻译插件，直接拿英文文档或文章读，不会的就直接划词翻译，然后记录下这个单词并背诵。每天花半小时看点英文文档和文章，坚持两个月，你的英语水平不说别的，看文档和文章绝对不会有难题了。这一定是一个很划算的个人时间投资，花点时间学习英语，能为你将来的技术之路铺平很多坎。</p>
<h2 id="画个图，想一想再做"><a href="#画个图，想一想再做" class="headerlink" title="画个图，想一想再做"></a>画个图，想一想再做</h2><p>你是否遇到过这种问题，需求一下来，看一眼，然后马上就按照设计稿开始做了，可能中间出个问题导致你需要返工。</p>
<p>如果你存在这样的问题，我很推荐在看到设计稿和需求的时候花点时间想一想，画一画。考虑一下设计稿中是否可以找到可以拆分出来的复用组件，是否存在之前写过的组件。该如何组织这个界面，数据的流转是怎么样的。然后画一下这个页面的需求，最后再动手做。</p>
<h2 id="利用好下班时间学习"><a href="#利用好下班时间学习" class="headerlink" title="利用好下班时间学习"></a>利用好下班时间学习</h2><p>说到下班时间，那可能就有人说了公司很迟下班，这其实是国内很普遍的情况。但是我认为正常的加班是可以的，但是强制的加班就是在损耗你的身体和前途。</p>
<p>可以这么说，大部分的 996 公司，加班的这些时间并不会增加你的技术，无非就是在写一些重复的业务逻辑。也许你可以拿到更多的钱，但是代价是身体还有前途。程序员是靠技术吃饭的，如果你长久呆在一个长时间加班的公司，不能增长你的技术还要吞噬你的下班学习时间，那么你一定会废掉的。如果你遇到了这种情况，只能推荐尽快跳槽到非 996 的公司。</p>
<p>那么如果你有足够的下班时间，一定要花上 1， 2 小时去学习，上班大家基本都一样，技术的精进就是看下班以后的那几个小时了。如果你能利用好下班时间来学习，坚持下去，时间一定会给你很好的答复。</p>
<h2 id="列好-ToDo"><a href="#列好-ToDo" class="headerlink" title="列好 ToDo"></a>列好 ToDo</h2><p>我喜欢规划好一段时间内要做的事情，并且要把事情拆分为小点。给 ToDo 列好优先级，紧急的优先级最高。相同优先级的我喜欢先做简单的，因为这样一旦完成就能划掉一个，提高成就感。</p>
<h2 id="反思和整理"><a href="#反思和整理" class="headerlink" title="反思和整理"></a>反思和整理</h2><p>每周末都会花上点时间整理下本周记录的笔记和看到的不错文章。然后考虑下本周完成的工作和下周准备要完成的工作。</p>
]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>职业</tag>
        <tag>学习</tag>
        <tag>进步</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 网络</title>
    <url>/2020/01/09/FE-guide-Net/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络相关的知识虽然平时在编码阶段很少遇到，但是并不是说它不重要，尤其是前端优化层面，能从网络传输过程优化的点有很多，所以，我们需要好好掌握网络相关的知识，接下来，我将会将我了解到的网络相关的知识点进行一一整理</p>
<h1 id="UDP-User-Datagram-Protocol-用户数据报协议"><a href="#UDP-User-Datagram-Protocol-用户数据报协议" class="headerlink" title="UDP - User Datagram Protocol - 用户数据报协议"></a>UDP - User Datagram Protocol - 用户数据报协议</h1><h2 id="面向报文"><a href="#面向报文" class="headerlink" title="面向报文"></a>面向报文</h2><p>UDP 是一个面向报文（报文可以理解为一段段的数据）的协议。意思就是 UDP 只是报文的搬运工，不会对报文进行任何拆分和拼接操作。</p>
<p>具体来说</p>
<ul>
<li>在<strong>发送端</strong>，应用层将数据传递给传输层的 <code>UDP</code> 协议， <code>UDP</code> 只会给数据增加一个 <code>UDP</code> 头标识下是 <code>UDP</code> 协议，然后就传递给网络层了</li>
<li>在<strong>接收端</strong>，网络层将数据传递给传输层， <code>UDP</code> 只去除 <code>IP</code> 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<h2 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h2><ol>
<li><code>UDP</code> 是无连接的，也就是说通信不需要建立和断开连接。</li>
<li><code>UDP</code> 也是不可靠的。协议收到什么数据就传递什么数据，并且也不会备份数据，对方能不能收到是不关心的</li>
<li><code>UDP</code> 没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 <code>UDP</code> 而不是 <code>TCP</code> 。</li>
</ol>
<h2 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h2><p>因为 <code>UDP</code> 没有 <code>TCP</code> 那么复杂，需要保证数据不丢失且有序到达。所以 <code>UDP</code> 的头部开销小，只有八字节，相比 <code>TCP</code> 的至少二十字节要少得多，在传输数据报文时是很高效的。</p>
<p>头部包含了以下几个数据</p>
<ul>
<li>两个十六位的端口号，分别为<strong>源端口</strong>（可选字段）和<strong>目标端口</strong></li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（ <code>IPv4</code> 可选 字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p><code>UDP</code> 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 <code>UDP</code> 提供了单播，多播，广播的功能。</p>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h2><p>TCP 头部比 UDP 头部复杂的多</p>
<p>对于 TCP 头部来说，以下几个字段是很重要的</p>
<ul>
<li><code>Sequence number</code>（序号），它保证了 <code>TCP</code> 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li>
<li><code>Acknowledgement Number</code>（确认编号），它表示数据接收端期望接收的下一个字节的编号是多少，同时也表示上一个序号的数据已经收到</li>
<li><code>Window Size</code>（窗口大小），它表示还能接收多少字节的数据，用于流量控制</li>
<li>标识符<ul>
<li><code>URG=1</code>：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指针标明了紧急数据的尾部。</li>
<li><code>ACK=1</code>：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须把 ACK 置为一。</li>
<li><code>PSH=1</code>：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交。</li>
<li><code>RST=1</code>：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立 TCP 连接，也可以用于拒绝非法的报文段和拒绝连接请求。</li>
<li><code>SYN=1</code>：当SYN=1，ACK=0时，表示当前报文段是一个连接请求报文。当SYN=1，ACK=1时，表示当前报文段是一个同意建立连接的应答报文。</li>
<li><code>FIN=1</code>：该字段为一表示此报文段是一个释放连接的请求报文。</li>
</ul>
</li>
</ul>
<h2 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h2><p><code>HTTP</code> 是无连接的，所以作为下层的 <code>TCP</code> 协议也是无连接的，虽然看似 <code>TCP</code> 将两端连接了起来，但是其实只是两端共同维护了一个状态</p>
<p><code>TCP</code> 的状态机是很复杂的，并且与建立断开连接时的握手息息相关，接下来就来详细描述下两种握手。<br>在这之前需要了解一个重要的性能指标 <code>RTT</code> 。该指标表示发送端发送数据到接收到对端数据所需的往返时间。</p>
<h3 id="建立连接三次握手"><a href="#建立连接三次握手" class="headerlink" title="建立连接三次握手"></a>建立连接三次握手</h3><p>在 TCP 协议中，主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 也是一个全双工的协议。</p>
<p>起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后遍进入 LISTEN 状态，此时开始等待客户端发送数据。</p>
<h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态，x 表示客户端的数据通信初始序号。</p>
<h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p>
<h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</p>
<p>PS：第三次握手可以包含数据，通过 TCP 快速打开（TFO）技术。其实只要涉及到握手的协议，都可以使用类似 TFO 的方式，客户端和服务端存储相同 cookie，下次握手时发出 cookie 达到减少 RTT 的目的。</p>
<p><strong><em>你是否有疑惑明明两次握手就可以建立起连接，为什么还需要第三次应答？</em></strong></p>
<p>因为这是为了防止失效的连接请求报文段被服务端接收，从而产生错误。</p>
<p>可以想象如下场景。客户端发送了一个连接请求 A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求 B。此时请求顺利到达服务端，服务端应答完就建立了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端又需要建立 TCP 连接，从而应答了该请求并进入 ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p>
<p>PS：在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试五次，在建立连接中可能会遇到 SYN FLOOD 攻击。遇到这种情况你可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p>
<h3 id="断开链接四次握手"><a href="#断开链接四次握手" class="headerlink" title="断开链接四次握手"></a>断开链接四次握手</h3><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。</p>
<h4 id="第一次握手-1"><a href="#第一次握手-1" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p>
<h4 id="第二次握手-1"><a href="#第二次握手-1" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p>
<h4 id="第三次握手-1"><a href="#第三次握手-1" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。</p>
<p>PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。</p>
<h4 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h4><p>A 收到释放请求后，向 B 发送确认应答，此时 A 进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。</p>
<p><strong><em>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后才进入 CLOSED 状态？</em></strong></p>
<p>为了保证 B 能收到 A 的确认应答。若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭。</p>
<h3 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h3><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ</p>
<h4 id="停止等待-ARQ"><a href="#停止等待-ARQ" class="headerlink" title="停止等待 ARQ"></a>停止等待 ARQ</h4><h4 id="正常传输过程"><a href="#正常传输过程" class="headerlink" title="正常传输过程"></a>正常传输过程</h4><p>只要 A 向 B 发送一段报文，都要停止发送并启动一个定时器，等待对端回应，在定时器时间内接收到对端应答就取消定时器并发送下一段报文。</p>
<h4 id="报文丢失或出错"><a href="#报文丢失或出错" class="headerlink" title="报文丢失或出错"></a>报文丢失或出错</h4><p>在报文传输的过程中可能会出现丢包。这时候超过定时器设定的时间就会再次发送丢包的数据直到对端响应，所以需要每次都备份发送的数据。</p>
<p>即使报文正常的传输到对端，也可能出现在传输过程中报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传。</p>
<p>PS：一般定时器设定的时间都会大于一个 RTT 的平均时间。</p>
<h4 id="ACK-超时或丢失"><a href="#ACK-超时或丢失" class="headerlink" title="ACK 超时或丢失"></a>ACK 超时或丢失</h4><p>对端传输的应答也可能出现丢失或超时的情况。那么超过定时器时间 A 端照样会重传报文。这时候 B 端收到相同序号的报文会丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p>
<p>在超时的情况下也可能出现应答很迟到达，这时 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p>
<p><strong><em>这个协议的缺点就是传输效率低，在良好的网络环境下每次发送报文都得等待对端的 ACK 。</em></strong></p>
<h4 id="连续-ARQ"><a href="#连续-ARQ" class="headerlink" title="连续 ARQ"></a>连续 ARQ</h4><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率。</p>
<h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>连续 ARQ 中，接收端会持续不断收到报文。如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号 + 1的数据。</p>
<p>但是累计确认也有一个弊端。在连续接收报文时，可能会遇到接收到序号 5 的报文后，并未接到序号 6 的报文，然而序号 7 以后的报文已经接收。遇到这种情况时，ACK 只能回复 6，这样会造成发送端重复发送数据，这种情况下可以通过 Sack 来解决，这个会在下文说到。</p>
<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>在上面小节中讲到了发送窗口。在 TCP 中，两端都维护着窗口：分别为发送端窗口和接收端窗口。</p>
<p>发送端窗口包含已发送但未收到应答的数据和可以发送但是未发送的数据。</p>
<p>发送端窗口是由接收窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p>
<p>当发送端接收到应答报文后，会随之将窗口进行滑动</p>
<p>滑动窗口实现了流量控制。接收方通过报文告知发送方还可以发送多少数据，从而保证接收方能够来得及接收数据。</p>
<h4 id="Zero-窗口"><a href="#Zero-窗口" class="headerlink" title="Zero 窗口"></a>Zero 窗口</h4><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况。在该情况下，发送端会停止发送数据，并启动 persistent timer 。该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p>
<h3 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h3><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p>
<p>拥塞处理包括了四个算法，分别为：<strong>慢开始</strong>，<strong>拥塞避免</strong>，<strong>快速重传</strong>，<strong>快速恢复</strong>。</p>
<h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>慢开始算法，顾名思义，就是在传输开始时将发送窗口慢慢指数级扩大，从而避免一开始就传输大量数据导致网络拥塞。</p>
<p>慢开始算法步骤具体如下</p>
<ol>
<li>连接初始设置拥塞窗口（Congestion Window） 为 1 MSS（一个分段的最大数据量）</li>
<li>每过一个 RTT 就将窗口大小乘二</li>
<li>指数级增长肯定不能没有限制的，所以有一个阈值限制，当窗口大小大于阈值时就会启动拥塞避免算法。</li>
</ol>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样能够避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值。</p>
<p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞了，会马上进行以下步骤：</p>
<ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>启动拥塞避免算法</li>
</ul>
<h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号（没有 Sack 的情况下）。如果收到三个重复的 ACK，无需等待定时器超时再重发而是启动快速重传。具体算法分为两种：</p>
<h4 id="TCP-Taho-实现如下"><a href="#TCP-Taho-实现如下" class="headerlink" title="TCP Taho 实现如下"></a>TCP Taho 实现如下</h4><ul>
<li>将阈值设为当前拥塞窗口的一半</li>
<li>将拥塞窗口设为 1 MSS</li>
<li>重新开始慢开始算法</li>
</ul>
<h4 id="TCP-Reno-实现如下"><a href="#TCP-Reno-实现如下" class="headerlink" title="TCP Reno 实现如下"></a>TCP Reno 实现如下</h4><ul>
<li>拥塞窗口减半</li>
<li>将阈值设为当前拥塞窗口</li>
<li>进入快恢复阶段（重发对端需要的包，一旦收到一个新的 ACK 答复就退出该阶段）</li>
<li>使用拥塞避免算法</li>
</ul>
<h4 id="TCP-New-Ren-改进后的快恢复"><a href="#TCP-New-Ren-改进后的快恢复" class="headerlink" title="TCP New Ren 改进后的快恢复"></a>TCP New Ren 改进后的快恢复</h4><p>TCP New Reno 算法改进了之前 TCP Reno 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p>
<p>在 TCP New Reno 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p>
<p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收并会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP 协议是个无状态协议，不会保存状态。</p>
<h2 id="Post-和-Get-的区别"><a href="#Post-和-Get-的区别" class="headerlink" title="Post 和 Get 的区别"></a><code>Post</code> 和 <code>Get</code> 的区别</h2><p>先引入<code>副作用</code>和<code>幂等</code>的概念。</p>
<blockquote>
<p><strong><em>副作用</em></strong>指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。</p>
</blockquote>
<blockquote>
<p><strong>幂等</strong>指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。</p>
</blockquote>
<p>在规范的应用场景上说， <code>Get</code> 多用于无副作用，幂等的场景，例如搜索关键字。 <code>Post</code> 多用于副作用，不幂等的场景，例如注册。</p>
<p>在技术上说：</p>
<ul>
<li>Get 请求能缓存，Post 不能</li>
<li>Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。</li>
<li>Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术</li>
<li>URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的</li>
<li>Post 支持更多的编码类型且不对数据类型限制</li>
</ul>
<h2 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h2><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><p>200 OK，表示从客户端发来的请求在服务器端被正确处理<br>204 No content，表示请求成功，但响应报文不含实体的主体部分<br>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容<br>206 Partial Content，进行范围请求</p>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><p>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL<br>302 found，临时性重定向，表示资源临时被分配了新的 URL<br>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源<br>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况<br>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</p>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><p>400 bad request，请求报文存在语法错误<br>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息<br>403 forbidden，表示对请求资源的访问被服务器拒绝<br>404 not found，表示在服务器上没有找到请求的资源</p>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>500 internal sever error，表示服务器端在执行请求时发生了错误<br>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能<br>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</p>
<h2 id="HTTP-首部"><a href="#HTTP-首部" class="headerlink" title="HTTP 首部"></a>HTTP 首部</h2><table>
<thead>
<tr>
<th>通用字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>浏览器想要优先使用的连接类型，比如 keep-alive</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器相关信息</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求客户端升级协议</td>
</tr>
<tr>
<td>Warning</td>
<td>在内容中可能存在错误</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>请求字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>能正确接收的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>能正确接收的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>能正确接收的编码格式列表</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>能正确接收的语言列表</td>
</tr>
<tr>
<td>Expect</td>
<td>期待服务端的指定行为</td>
</tr>
<tr>
<td>From</td>
<td>请求方邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>服务器的域名</td>
</tr>
<tr>
<td>If-Match</td>
<td>两端资源标记比较</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>本地资源未修改返回 304（比较时间）</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>本地资源未修改返回 304（比较标记）</td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端信息</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制可被代理及网关转发的次数</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>向代理服务器发送验证信息</td>
</tr>
<tr>
<td>Range</td>
<td>请求某个内容的一部分</td>
</tr>
<tr>
<td>Referer</td>
<td>表示浏览器所访问的前一个页面</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码方式</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>响应字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Accept-Ranges</td>
<td>是否支持某些种类的范围</td>
</tr>
<tr>
<td>Age</td>
<td>资源在代理缓存中存在的时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源标识</td>
</tr>
<tr>
<td>Location</td>
<td>客户端重定向到某个 URL</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>向代理服务器发送验证信息</td>
</tr>
<tr>
<td>Server</td>
<td>服务器名字</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>获取资源需要的验证信息</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>实体字段</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>资源的正确请求方式</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>内容的编码格式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>内容使用的语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>request body 长度</td>
</tr>
<tr>
<td>Content-Location</td>
<td>返回数据的备用地址</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>Base64加密格式的内容 MD5检验值</td>
</tr>
<tr>
<td>Content-Range</td>
<td>内容的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>内容的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>内容的过期时间</td>
</tr>
<tr>
<td>Last_modified</td>
<td>内容的最后修改时间</td>
</tr>
</tbody></table>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p><code>HTTPS</code> 还是通过了 <code>HTTP</code> 来传输信息，但是信息通过 <code>TLS</code> 协议进行了加密。</p>
<h2 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h2><p><code>TLS</code> 协议位于传输层之上，应用层之下。首次进行 <code>TLS</code> 协议传输需要两个 <code>RTT</code> ，接下来可以通过 <code>Session Resumption</code> 减少到一个 <code>RTT</code> 。</p>
<p>在 <code>TLS</code> 中使用了两种加密技术，分别为：<strong><em>对称加密</em></strong>和<strong><em>非对称加密</em></strong>。</p>
<p><strong>对称加密：</strong><br>对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。</p>
<p><strong>非对称加密：</strong><br>有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p>
<p><strong>TLS 握手过程如下图：</strong></p>
<ol>
<li>客户端发送一个随机值，需要的协议和加密方式</li>
<li>服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）</li>
<li>客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li>
<li>服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密</li>
</ol>
<p>通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。</p>
<p>PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。</p>
<h1 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h1><p>HTTP 2.0 相比于 HTTP 1.X，可以说是大幅度提高了 web 的性能。</p>
<p>在 HTTP 1.X 中，为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p>
<p>你可以通过 该链接 感受下 HTTP 2.0 比 HTTP 1.X 到底快了多少。</p>
<p>在 HTTP 1.X 中，因为队头阻塞的原因，你会发现请求是这样的<br><img src="https://s2.ax1x.com/2020/01/09/lWJGkt.png" alt="lWJGkt.png"><br>在 HTTP 2.0 中，因为引入了多路复用，你会发现请求是这样的<br><img src="https://s2.ax1x.com/2020/01/09/lWJa6g.png" alt="lWJa6g.png"></p>
<h2 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h2><p>HTTP 2.0 中所有加强性能的核心点在于此。在之前的 HTTP 版本中，我们是通过文本的方式传输数据。在 HTTP 2.0 中引入了新的编码机制，所有传输的数据都会被分割，并采用二进制格式编码。</p>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在 HTTP 2.0 中，有两个非常重要的概念，分别是<strong>帧（frame）</strong>和<strong>流（stream）</strong>。<br>帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。</p>
<p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。</p>
<h2 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h2><p>在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。</p>
<p>在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。</p>
<h2 id="服务端-Push"><a href="#服务端-Push" class="headerlink" title="服务端 Push"></a>服务端 Push</h2><p>在 HTTP 2.0 中，服务端可以在客户端某个请求后，主动推送其他资源。</p>
<p>可以想象以下情况，某些资源客户端是一定会请求的，这时就可以采取服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下你也可以使用 prefetch 。</p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>这是一个谷歌出品的基于 UDP 实现的同为传输层的协议，目标很远大，希望替代 TCP 协议。</p>
<ul>
<li>该协议支持多路复用，虽然 HTTP 2.0 也支持多路复用，但是下层仍是 TCP，因为 TCP 的重传机制，只要一个包丢失就得判断丢失包并且重传，导致发生队头阻塞的问题，但是 UDP 没有这个机制</li>
<li>实现了自己的加密协议，通过类似 TCP 的 TFO 机制可以实现 0-RTT，当然 TLS 1.3 已经实现了 0-RTT 了</li>
<li>支持重传和纠错机制（向前恢复），在只丢失一个包的情况下不需要重传，使用纠错机制恢复丢失的包<ul>
<li>纠错机制：通过异或的方式，算出发出去的数据的异或值并单独发出一个包，服务端在发现有一个包丢失的情况下，通过其他数据包和异或值包算出丢失包</li>
<li>在丢失两个包或以上的情况就使用重传机制，因为算不出来了</li>
</ul>
</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS 的作用就是通过域名查询到具体的 IP。</p>
<p>因为 IP 存在数字和英文的组合（IPv6），很不利于人类记忆，所以就出现了域名。你可以把域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。</p>
<p>在 TCP 握手之前就已经进行了 DNS 查询，这个查询是操作系统自己做的。当你在浏览器中想访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 时，会进行一下操作：</p>
<ol>
<li>操作系统会首先在本地缓存中查询</li>
<li>没有的话会去系统配置的 DNS 服务器中查询</li>
<li>如果这时候还没得话，会直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器</li>
<li>然后去该服务器查询 google 这个二级域名</li>
<li>接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP</li>
</ol>
<p>以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。</p>
<p>PS：DNS 是基于 UDP 做的查询。</p>
<h2 id="从输入-URL-到页面加载完成的过程"><a href="#从输入-URL-到页面加载完成的过程" class="headerlink" title="从输入 URL 到页面加载完成的过程"></a>从输入 URL 到页面加载完成的过程</h2><p>这是一个很经典的面试题，在这题中可以将本文讲得内容都串联起来。</p>
<ol>
<li>首先做 <code>DNS</code> 查询，如果这一步做了智能 <code>DNS</code> 解析的话，会提供访问速度最快的 <code>IP</code> 地址回来</li>
<li>接下来是 <code>TCP</code> 握手，应用层会下发数据给传输层，这里 <code>TCP</code> 协议会指明两端的端口号，然后下发给网络层。网络层中的 <code>IP</code> 协议会确定 <code>IP</code> 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</li>
<li><code>TCP</code> 握手结束后会进行 <code>TLS</code> 握手，然后就开始正式的传输数据</li>
<li>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 <code>HTML</code> 文件</li>
<li>首先浏览器会判断状态码是什么，如果是 <code>200</code> 那就继续解析，如果 <code>400</code> 或 <code>500</code> 的话就会报错，如果 <code>300</code> 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</li>
<li>浏览器开始解析文件，如果是 <code>gzip</code> 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</li>
<li>文件解码成功后会正式开始渲染流程，先会根据 <code>HTML</code> 构建 <code>DOM</code> 树，有 <code>CSS</code> 的话会去构建 <code>CSSOM</code> 树。如果遇到 <code>script</code> 标签的话，会判断是否存在 <code>async</code> 或者 <code>defer</code> ，前者会并行进行下载并执行 <code>JS</code> ，后者会先下载文件，然后等待 <code>HTML</code> 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 <code>JS</code> 执行完毕。遇到文件下载的会去下载文件，这里如果使用 <code>HTTP 2.0</code> 协议的话会极大的提高多图的下载效率。</li>
<li>初始的 <code>HTML</code> 被完全加载和解析后会触发 <code>DOMContentLoaded</code> 事件</li>
<li><code>CSSOM</code> 树和 <code>DOM</code> 树构建完成后会开始生成 <code>Render</code> 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</li>
<li>在生成 <code>Render</code> 树的过程中，浏览器就开始调用 <code>GPU</code> 绘制，合成图层，将内容显示在屏幕上了</li>
</ol>
]]></content>
      <categories>
        <category>前端技术</category>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机通识 ---- 数据结构</title>
    <url>/2020/01/09/FE-guide-data-structure/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>网络相关的知识虽然平时在编码阶段很少遇到，但是并不是说它不重要，尤其是前端优化层面，能从网络传输过程优化的点有很多，所以，我们需要好好掌握网络相关的知识，接下来，我将会将我了解到的网络相关的知识点进行一一整理</p>
<h1 id="栈-Heap"><a href="#栈-Heap" class="headerlink" title="栈 Heap"></a>栈 Heap</h1><blockquote>
<p>栈是一个线性结构，在计算机中是一个相当常见的数据结构。<br>栈的特点是只能在某一端添加或删除数据，遵循<strong>先进后出(FILO)</strong>的原则</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">class Stack &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.stack &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line">  push(item) &#123;</span><br><span class="line">    this.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  pop() &#123;</span><br><span class="line">    this.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line">  peek() &#123; &#x2F;&#x2F; 取最后一项</span><br><span class="line">    return this.stack[this.getCount() - 1]</span><br><span class="line">  &#125;</span><br><span class="line">  getCount() &#123;</span><br><span class="line">    return this.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.getCount() &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>选取了 <a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">LeetCode 上序号为 20 的题目</a></p>
<p>题意是匹配括号，可以通过栈的特性来完成这道题目</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var isValid &#x3D; function(str) &#123;</span><br><span class="line">  let map &#x3D; &#123;</span><br><span class="line">    &#39;(&#39;: -1,</span><br><span class="line">    &#39;)&#39;: 1,</span><br><span class="line">    &#39;[&#39;: -2,</span><br><span class="line">    &#39;]&#39;: 2,</span><br><span class="line">    &#39;&#123;&#39;: -3,</span><br><span class="line">    &#39;&#125;&#39;: 3</span><br><span class="line">  &#125;</span><br><span class="line">  let stack &#x3D; [] &#x2F;&#x2F; 空数组</span><br><span class="line">  for (let i &#x3D; 0; i &lt; str.length; i++) &#123; &#x2F;&#x2F; 遍历字符串每个字符</span><br><span class="line">    if (map[str[i]] &lt; 0) &#123; &#x2F;&#x2F; 如果是左边括号，入栈</span><br><span class="line">      stack.push(str[i])</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 否则出栈，判断左右括号加到一起是不是0</span><br><span class="line">      let last &#x3D; stack.pop()</span><br><span class="line">      if (map[last] + map[str[i]] !&#x3D; 0) return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (stack.length &gt; 0) return false &#x2F;&#x2F; 循环完成后，判断数组中时候还有剩下的，有剩下的说明括号没闭合</span><br><span class="line">  return true &#x2F;&#x2F; 否则没剩下的，都闭合了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><blockquote>
<p>队列一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循<strong>先进先出(FIFO)</strong>的原则。</p>
</blockquote>
<h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>这里会讲解两种实现队列的方式，分别是<strong>单链队列</strong>和<strong>循环队列</strong>。</p>
<ul>
<li>链队列即队列的链式存储结构，结构上就是一个单链表，但数据只能是头进尾出。链式结构更加的灵活，特别是在存储空间上，基本不会出现溢出的情况，所以不用像循环队列一样判断队列是否已满，且空间的利用率相对较高。<ul>
<li>链队列front指向头结点，头结点不存储数据，rear指向队尾结点。</li>
</ul>
</li>
</ul>
<ul>
<li><p>循环队列即为头尾相接的队列，它的最大存储空间和顺序队列一样由数组界定，但队列的长度并不一定等同于数组的长度；循环队列的队首和队尾分别由两个指针front、rear标识，于是这样就能做到首尾相接。</p>
</li>
<li><p>链队列：为操作方便，给链队列添加一个头结点</p>
</li>
<li><p>循环队列：附设两个指针front和rear分别指示队列头元素及尾元素的位置，每当插入新的队尾元素是，尾指针加1；每当删除队列头元素是，头指针加1</p>
<ul>
<li>如果用循环队列，则必须设定一个最大队列长度；若无法确定最大长度，则宜采用链队列。</li>
</ul>
</li>
</ul>
<h3 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Queue &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.queue &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    this.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    return this.queue.shift()</span><br><span class="line">  &#125;</span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    return this.queue[0]</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    return this.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.getLength() &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。<br>循环队列的出队操作平均是 O(1) 的时间复杂度。</p>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class SqQueue &#123;</span><br><span class="line">  constructor(length) &#123;</span><br><span class="line">    this.queue &#x3D; new Array(length + 1)</span><br><span class="line">    &#x2F;&#x2F; 队头</span><br><span class="line">    this.first &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 队尾</span><br><span class="line">    this.last &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 当前队列大小</span><br><span class="line">    this.size &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    &#x2F;&#x2F; 判断队尾 + 1 是否为队头</span><br><span class="line">    &#x2F;&#x2F; 如果是就代表需要扩容数组</span><br><span class="line">    &#x2F;&#x2F; % this.queue.length 是为了防止数组越界</span><br><span class="line">    if (this.first &#x3D;&#x3D;&#x3D; (this.last + 1) % this.queue.length) &#123;</span><br><span class="line">      this.resize(this.getLength() * 2 + 1)</span><br><span class="line">    &#125;</span><br><span class="line">    this.queue[this.last] &#x3D; item</span><br><span class="line">    this.size++</span><br><span class="line">    this.last &#x3D; (this.last + 1) % this.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    if (this.isEmpty()) &#123;</span><br><span class="line">      throw Error(&#39;Queue is empty&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    let r &#x3D; this.queue[this.first]</span><br><span class="line">    this.queue[this.first] &#x3D; null</span><br><span class="line">    this.first &#x3D; (this.first + 1) % this.queue.length</span><br><span class="line">    this.size--</span><br><span class="line">    &#x2F;&#x2F; 判断当前队列大小是否过小</span><br><span class="line">    &#x2F;&#x2F; 为了保证不浪费空间，在队列空间等于总长度四分之一时</span><br><span class="line">    &#x2F;&#x2F; 且不为 2 时缩小总长度为当前的一半</span><br><span class="line">    if (this.size &#x3D;&#x3D;&#x3D; this.getLength() &#x2F; 4 &amp;&amp; this.getLength() &#x2F; 2 !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      this.resize(this.getLength() &#x2F; 2)</span><br><span class="line">    &#125;</span><br><span class="line">    return r</span><br><span class="line">  &#125;</span><br><span class="line">  getHeader() &#123;</span><br><span class="line">    if (this.isEmpty()) &#123;</span><br><span class="line">      throw Error(&#39;Queue is empty&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">    return this.queue[this.first]</span><br><span class="line">  &#125;</span><br><span class="line">  getLength() &#123;</span><br><span class="line">    return this.queue.length - 1</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.first &#x3D;&#x3D;&#x3D; this.last</span><br><span class="line">  &#125;</span><br><span class="line">  resize(length) &#123;</span><br><span class="line">    let q &#x3D; new Array(length)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] &#x3D; this.queue[(i + this.first) % this.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    this.queue &#x3D; q</span><br><span class="line">    this.first &#x3D; 0</span><br><span class="line">    this.last &#x3D; this.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><blockquote>
<p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>
</blockquote>
<h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><p>单向链表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(v, next) &#123;</span><br><span class="line">    this.value &#x3D; v</span><br><span class="line">    this.next &#x3D; next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class LinkList &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 链表长度</span><br><span class="line">    this.size &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 虚拟头部</span><br><span class="line">    this.dummyNode &#x3D; new Node(null, null)</span><br><span class="line">  &#125;</span><br><span class="line">  find(header, index, currentIndex) &#123;</span><br><span class="line">    if (index &#x3D;&#x3D;&#x3D; currentIndex) return header</span><br><span class="line">    return this.find(header.next, index, currentIndex + 1)</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v, index) &#123;</span><br><span class="line">    this.checkIndex(index)</span><br><span class="line">    &#x2F;&#x2F; 当往链表末尾插入时，prev.next 为空</span><br><span class="line">    &#x2F;&#x2F; 其他情况时，因为要插入节点，所以插入的节点</span><br><span class="line">    &#x2F;&#x2F; 的 next 应该是 prev.next</span><br><span class="line">    &#x2F;&#x2F; 然后设置 prev.next 为插入的节点</span><br><span class="line">    let prev &#x3D; this.find(this.dummyNode, index, 0)</span><br><span class="line">    prev.next &#x3D; new Node(v, prev.next)</span><br><span class="line">    this.size++</span><br><span class="line">    return prev.next</span><br><span class="line">  &#125;</span><br><span class="line">  insertNode(v, index) &#123;</span><br><span class="line">    return this.addNode(v, index)</span><br><span class="line">  &#125;</span><br><span class="line">  addToFirst(v) &#123;</span><br><span class="line">    return this.addNode(v, 0)</span><br><span class="line">  &#125;</span><br><span class="line">  addToLast(v) &#123;</span><br><span class="line">    return this.addNode(v, this.size)</span><br><span class="line">  &#125;</span><br><span class="line">  removeNode(index, isLast) &#123;</span><br><span class="line">    this.checkIndex(index)</span><br><span class="line">    index &#x3D; isLast ? index - 1 : index</span><br><span class="line">    let prev &#x3D; this.find(this.dummyNode, index, 0)</span><br><span class="line">    let node &#x3D; prev.next</span><br><span class="line">    prev.next &#x3D; node.next</span><br><span class="line">    node.next &#x3D; null</span><br><span class="line">    this.size--</span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">  removeFirstNode() &#123;</span><br><span class="line">    return this.removeNode(0)</span><br><span class="line">  &#125;</span><br><span class="line">  removeLastNode() &#123;</span><br><span class="line">    return this.removeNode(this.size, true)</span><br><span class="line">  &#125;</span><br><span class="line">  checkIndex(index) &#123;</span><br><span class="line">    if (index &lt; 0 || index &gt; this.size) throw Error(&#39;Index error&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  getNode(index) &#123;</span><br><span class="line">    this.checkIndex(index)</span><br><span class="line">    if (this.isEmpty()) return</span><br><span class="line">    return this.find(this.dummyNode, index, 0).next</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.size &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    return this.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构。</p>
<p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶数量数量为满时，该树可以称之为满二叉树。</p>
<h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别在于二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小。</p>
<p>这种存储方式很适合于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。</p>
<h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.left &#x3D; null</span><br><span class="line">    this.right &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class BST &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.root &#x3D; null</span><br><span class="line">    this.size &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  getSize() &#123;</span><br><span class="line">    return this.size</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    return this.size &#x3D;&#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    this.root &#x3D; this._addChild(this.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 添加节点时，需要比较添加的节点值和当前</span><br><span class="line">  &#x2F;&#x2F; 节点值的大小</span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    if (!node) &#123;</span><br><span class="line">      this.size++</span><br><span class="line">      return new Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.value &gt; v) &#123;</span><br><span class="line">      node.left &#x3D; this._addChild(node.left, v)</span><br><span class="line">    &#125; else if (node.value &lt; v) &#123;</span><br><span class="line">      node.right &#x3D; this._addChild(node.right, v)</span><br><span class="line">    &#125;</span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是最基本的二分搜索树实现，接下来实现树的遍历。</p>
<p>对于树的遍历来说，有三种遍历方法，分别是<strong>先序遍历</strong>、<strong>中序遍历</strong>、<strong>后序遍历</strong>。</p>
<p>三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。</p>
<p>以下都是递归实现.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 先序遍历可用于打印树的结构</span><br><span class="line">&#x2F;&#x2F; 先序遍历先访问根节点，然后访问左节点，最后访问右节点。</span><br><span class="line">preTraversal() &#123;</span><br><span class="line">  this._pre(this.root)</span><br><span class="line">&#125;</span><br><span class="line">_pre(node) &#123;</span><br><span class="line">  if (node) &#123;</span><br><span class="line">    console.log(node.value)</span><br><span class="line">    this._pre(node.left)</span><br><span class="line">    this._pre(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 中序遍历可用于排序</span><br><span class="line">&#x2F;&#x2F; 对于 BST 来说，中序遍历可以实现一次遍历就</span><br><span class="line">&#x2F;&#x2F; 得到有序的值</span><br><span class="line">&#x2F;&#x2F; 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。</span><br><span class="line">midTraversal() &#123;</span><br><span class="line">  this._mid(this.root)</span><br><span class="line">&#125;</span><br><span class="line">_mid(node) &#123;</span><br><span class="line">  if (node) &#123;</span><br><span class="line">    this._mid(node.left)</span><br><span class="line">    console.log(node.value)</span><br><span class="line">    this._mid(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 后序遍历可用于先操作子节点</span><br><span class="line">&#x2F;&#x2F; 再操作父节点的场景</span><br><span class="line">&#x2F;&#x2F; 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。</span><br><span class="line">backTraversal() &#123;</span><br><span class="line">  this._back(this.root)</span><br><span class="line">&#125;</span><br><span class="line">_back(node) &#123;</span><br><span class="line">  if (node) &#123;</span><br><span class="line">    this._back(node.left)</span><br><span class="line">    this._back(node.right)</span><br><span class="line">    console.log(node.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">breadthTraversal() &#123;</span><br><span class="line">  if (!this.root) return null</span><br><span class="line">  let q &#x3D; new Queue()</span><br><span class="line">  &#x2F;&#x2F; 将根节点入队</span><br><span class="line">  q.enQueue(this.root)</span><br><span class="line">  &#x2F;&#x2F; 循环判断队列是否为空，为空</span><br><span class="line">  &#x2F;&#x2F; 代表树遍历完毕</span><br><span class="line">  while (!q.isEmpty()) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将队首出队，判断是否有左右子树</span><br><span class="line">    &#x2F;&#x2F; 有的话，就先左后右入队</span><br><span class="line">    let n &#x3D; q.deQueue()</span><br><span class="line">    console.log(n.value)</span><br><span class="line">    if (n.left) q.enQueue(n.left)</span><br><span class="line">    if (n.right) q.enQueue(n.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">getMin() &#123;</span><br><span class="line">  return this._getMin(this.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMin(node) &#123;</span><br><span class="line">  if (!node.left) return node</span><br><span class="line">  return this._getMin(node.left)</span><br><span class="line">&#125;</span><br><span class="line">getMax() &#123;</span><br><span class="line">  return this._getMax(this.root).value</span><br><span class="line">&#125;</span><br><span class="line">_getMax(node) &#123;</span><br><span class="line">  if (!node.right) return node</span><br><span class="line">  return this._getMin(node.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>向上取整和向下取整</strong>，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">floor(v) &#123;</span><br><span class="line">  let node &#x3D; this._floor(this.root, v)</span><br><span class="line">  return node ? node.value : null</span><br><span class="line">&#125;</span><br><span class="line">_floor(node, v) &#123;</span><br><span class="line">  if (!node) return null</span><br><span class="line">  if (node.value &#x3D;&#x3D;&#x3D; v) return v</span><br><span class="line">  &#x2F;&#x2F; 如果当前节点值还比需要的值大，就继续递归</span><br><span class="line">  if (node.value &gt; v) &#123;</span><br><span class="line">    return this._floor(node.left, v)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 判断当前节点是否拥有右子树</span><br><span class="line">  let right &#x3D; this._floor(node.right, v)</span><br><span class="line">  if (right) return right</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.left &#x3D; null</span><br><span class="line">    this.right &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 修改代码</span><br><span class="line">    this.size &#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 新增代码</span><br><span class="line">_getSize(node) &#123;</span><br><span class="line">  return node ? node.size : 0</span><br><span class="line">&#125;</span><br><span class="line">_addChild(node, v) &#123;</span><br><span class="line">  if (!node) &#123;</span><br><span class="line">    return new Node(v)</span><br><span class="line">  &#125;</span><br><span class="line">  if (node.value &gt; v) &#123;</span><br><span class="line">    &#x2F;&#x2F; 修改代码</span><br><span class="line">    node.size++</span><br><span class="line">    node.left &#x3D; this._addChild(node.left, v)</span><br><span class="line">  &#125; else if (node.value &lt; v) &#123;</span><br><span class="line">    &#x2F;&#x2F; 修改代码</span><br><span class="line">    node.size++</span><br><span class="line">    node.right &#x3D; this._addChild(node.right, v)</span><br><span class="line">  &#125;</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br><span class="line">select(k) &#123;</span><br><span class="line">  let node &#x3D; this._select(this.root, k)</span><br><span class="line">  return node ? node.value : null</span><br><span class="line">&#125;</span><br><span class="line">_select(node, k) &#123;</span><br><span class="line">  if (!node) return null</span><br><span class="line">  &#x2F;&#x2F; 先获取左子树下有几个节点</span><br><span class="line">  let size &#x3D; node.left ? node.left.size : 0</span><br><span class="line">  &#x2F;&#x2F; 判断 size 是否大于 k</span><br><span class="line">  &#x2F;&#x2F; 如果大于 k，代表所需要的节点在左节点</span><br><span class="line">  if (size &gt; k) return this._select(node.left, k)</span><br><span class="line">  &#x2F;&#x2F; 如果小于 k，代表所需要的节点在右节点</span><br><span class="line">  &#x2F;&#x2F; 注意这里需要重新计算 k，减去根节点除了右子树的节点数量</span><br><span class="line">  if (size &lt; k) return this._select(node.right, k - size - 1)</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况</p>
<ul>
<li>需要删除的节点没有子树</li>
<li>需要删除的节点只有一条子树</li>
<li>需要删除的节点有左右两条树</li>
</ul>
<p>对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">delectMin() &#123;</span><br><span class="line">  this.root &#x3D; this._delectMin(this.root)</span><br><span class="line">  console.log(this.root)</span><br><span class="line">&#125;</span><br><span class="line">_delectMin(node) &#123;</span><br><span class="line">  &#x2F;&#x2F; 一直递归左子树</span><br><span class="line">  &#x2F;&#x2F; 如果左子树为空，就判断节点是否拥有右子树</span><br><span class="line">  &#x2F;&#x2F; 有右子树的话就把需要删除的节点替换为右子树</span><br><span class="line">  if ((node !&#x3D; null) &amp; !node.left) return node.right</span><br><span class="line">  node.left &#x3D; this._delectMin(node.left)</span><br><span class="line">  &#x2F;&#x2F; 最后需要重新维护下节点的 &#96;size&#96;</span><br><span class="line">  node.size &#x3D; this._getSize(node.left) + this._getSize(node.right) + 1</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。</p>
<p>当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。</p>
<p>你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">delect(v) &#123;</span><br><span class="line">  this.root &#x3D; this._delect(this.root, v)</span><br><span class="line">&#125;</span><br><span class="line">_delect(node, v) &#123;</span><br><span class="line">  if (!node) return null</span><br><span class="line">  &#x2F;&#x2F; 寻找的节点比当前节点小，去左子树找</span><br><span class="line">  if (node.value &lt; v) &#123;</span><br><span class="line">    node.right &#x3D; this._delect(node.right, v)</span><br><span class="line">  &#125; else if (node.value &gt; v) &#123;</span><br><span class="line">    &#x2F;&#x2F; 寻找的节点比当前节点大，去右子树找</span><br><span class="line">    node.left &#x3D; this._delect(node.left, v)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 进入这个条件说明已经找到节点</span><br><span class="line">    &#x2F;&#x2F; 先判断节点是否拥有拥有左右子树中的一个</span><br><span class="line">    &#x2F;&#x2F; 是的话，将子树返回出去，这里和 &#96;_delectMin&#96; 的操作一样</span><br><span class="line">    if (!node.left) return node.right</span><br><span class="line">    if (!node.right) return node.left</span><br><span class="line">    &#x2F;&#x2F; 进入这里，代表节点拥有左右子树</span><br><span class="line">    &#x2F;&#x2F; 先取出当前节点的后继结点，也就是取当前节点右子树的最小值</span><br><span class="line">    let min &#x3D; this._getMin(node.right)</span><br><span class="line">    &#x2F;&#x2F; 取出最小值后，删除最小值</span><br><span class="line">    &#x2F;&#x2F; 然后把删除节点后的子树赋值给最小值节点</span><br><span class="line">    min.right &#x3D; this._delectMin(node.right)</span><br><span class="line">    &#x2F;&#x2F; 左子树不动</span><br><span class="line">    min.left &#x3D; node.left</span><br><span class="line">    node &#x3D; min</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 维护 size</span><br><span class="line">  node.size &#x3D; this._getSize(node.left) + this._getSize(node.right) + 1</span><br><span class="line">  return node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h2><blockquote>
<p>二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况。</p>
</blockquote>
<blockquote>
<p>AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都不大于 1，这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡。</p>
</blockquote>
<h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><p>因为 AVL 树是改进了二分搜索树，所以部分代码是于二分搜索树重复的，对于重复内容不作再次解析。</p>
<p>对于 AVL 树来说，添加节点会有四种情况<br><img src="https://s2.ax1x.com/2020/01/09/lWB0nf.png" alt="lWB0nf.png"></p>
<p>对于左左情况来说，新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。</p>
<p>旋转之前：new &lt; 2 &lt; C &lt; 3 &lt; B &lt; 5 &lt; A，右旋之后节点 3 为根节点，这时候需要将节点 3 的右节点加到节点 5 的左边，最后还需要更新节点的高度。</p>
<p>对于右右情况来说，相反于左左情况，所以不再赘述。</p>
<p>对于左右情况来说，新增加的节点位于节点 4 的右侧。对于这种情况，需要通过两次旋转来达到目的。</p>
<p>首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class Node &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line">    this.value &#x3D; value</span><br><span class="line">    this.left &#x3D; null</span><br><span class="line">    this.right &#x3D; null</span><br><span class="line">    this.height &#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AVL &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.root &#x3D; null</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v) &#123;</span><br><span class="line">    this.root &#x3D; this._addChild(this.root, v)</span><br><span class="line">  &#125;</span><br><span class="line">  _addChild(node, v) &#123;</span><br><span class="line">    if (!node) &#123;</span><br><span class="line">      return new Node(v)</span><br><span class="line">    &#125;</span><br><span class="line">    if (node.value &gt; v) &#123;</span><br><span class="line">      node.left &#x3D; this._addChild(node.left, v)</span><br><span class="line">    &#125; else if (node.value &lt; v) &#123;</span><br><span class="line">      node.right &#x3D; this._addChild(node.right, v)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      node.value &#x3D; v</span><br><span class="line">    &#125;</span><br><span class="line">    node.height &#x3D;</span><br><span class="line">      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))</span><br><span class="line">    let factor &#x3D; this._getBalanceFactor(node)</span><br><span class="line">    &#x2F;&#x2F; 当需要右旋时，根节点的左树一定比右树高度高</span><br><span class="line">    if (factor &gt; 1 &amp;&amp; this._getBalanceFactor(node.left) &gt;&#x3D; 0) &#123;</span><br><span class="line">      return this._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 当需要左旋时，根节点的左树一定比右树高度矮</span><br><span class="line">    if (factor &lt; -1 &amp;&amp; this._getBalanceFactor(node.right) &lt;&#x3D; 0) &#123;</span><br><span class="line">      return this._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 左右情况</span><br><span class="line">    &#x2F;&#x2F; 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高</span><br><span class="line">    if (factor &gt; 1 &amp;&amp; this._getBalanceFactor(node.left) &lt; 0) &#123;</span><br><span class="line">      node.left &#x3D; this._leftRotate(node.left)</span><br><span class="line">      return this._rightRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 右左情况</span><br><span class="line">    &#x2F;&#x2F; 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮</span><br><span class="line">    if (factor &lt; -1 &amp;&amp; this._getBalanceFactor(node.right) &gt; 0) &#123;</span><br><span class="line">      node.right &#x3D; this._rightRotate(node.right)</span><br><span class="line">      return this._leftRotate(node)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return node</span><br><span class="line">  &#125;</span><br><span class="line">  _getHeight(node) &#123;</span><br><span class="line">    if (!node) return 0</span><br><span class="line">    return node.height</span><br><span class="line">  &#125;</span><br><span class="line">  _getBalanceFactor(node) &#123;</span><br><span class="line">    return this._getHeight(node.left) - this._getHeight(node.right)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 节点右旋</span><br><span class="line">  &#x2F;&#x2F;           5                    2</span><br><span class="line">  &#x2F;&#x2F;         &#x2F;   \                &#x2F;   \</span><br><span class="line">  &#x2F;&#x2F;        2     6   &#x3D;&#x3D;&gt;       1      5</span><br><span class="line">  &#x2F;&#x2F;       &#x2F;  \               &#x2F;       &#x2F;  \</span><br><span class="line">  &#x2F;&#x2F;      1    3             new     3    6</span><br><span class="line">  &#x2F;&#x2F;     &#x2F;</span><br><span class="line">  &#x2F;&#x2F;    new</span><br><span class="line">  _rightRotate(node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 旋转后新根节点</span><br><span class="line">    let newRoot &#x3D; node.left</span><br><span class="line">    &#x2F;&#x2F; 需要移动的节点</span><br><span class="line">    let moveNode &#x3D; newRoot.right</span><br><span class="line">    &#x2F;&#x2F; 节点 2 的右节点改为节点 5</span><br><span class="line">    newRoot.right &#x3D; node</span><br><span class="line">    &#x2F;&#x2F; 节点 5 左节点改为节点 3</span><br><span class="line">    node.left &#x3D; moveNode</span><br><span class="line">    &#x2F;&#x2F; 更新树的高度</span><br><span class="line">    node.height &#x3D;</span><br><span class="line">      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))</span><br><span class="line">    newRoot.height &#x3D;</span><br><span class="line">      1 +</span><br><span class="line">      Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    return newRoot</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 节点左旋</span><br><span class="line">  &#x2F;&#x2F;           4                    6</span><br><span class="line">  &#x2F;&#x2F;         &#x2F;   \                &#x2F;   \</span><br><span class="line">  &#x2F;&#x2F;        2     6   &#x3D;&#x3D;&gt;       4      7</span><br><span class="line">  &#x2F;&#x2F;             &#x2F;  \         &#x2F;   \      \</span><br><span class="line">  &#x2F;&#x2F;            5     7      2     5      new</span><br><span class="line">  &#x2F;&#x2F;                   \</span><br><span class="line">  &#x2F;&#x2F;                    new</span><br><span class="line">  _leftRotate(node) &#123;</span><br><span class="line">    &#x2F;&#x2F; 旋转后新根节点</span><br><span class="line">    let newRoot &#x3D; node.right</span><br><span class="line">    &#x2F;&#x2F; 需要移动的节点</span><br><span class="line">    let moveNode &#x3D; newRoot.left</span><br><span class="line">    &#x2F;&#x2F; 节点 6 的左节点改为节点 4</span><br><span class="line">    newRoot.left &#x3D; node</span><br><span class="line">    &#x2F;&#x2F; 节点 4 右节点改为节点 5</span><br><span class="line">    node.right &#x3D; moveNode</span><br><span class="line">    &#x2F;&#x2F; 更新树的高度</span><br><span class="line">    node.height &#x3D;</span><br><span class="line">      1 + Math.max(this._getHeight(node.left), this._getHeight(node.right))</span><br><span class="line">    newRoot.height &#x3D;</span><br><span class="line">      1 +</span><br><span class="line">      Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right))</span><br><span class="line"></span><br><span class="line">    return newRoot</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h1><blockquote>
<p>在计算机科学，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。<br>简单点来说，这个结构的作用大多是为了方便搜索字符串，该树有以下几个特点</p>
</blockquote>
<ul>
<li>根节点代表空字符串，每个节点都有 N（假如搜索英文字符，就有 26 条） 条链接，每条链接代表一个字符</li>
<li>节点不存储字符，只有路径才存储，这点和其他的树结构不同</li>
<li>从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串</li>
</ul>
<h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><p>总得来说 Trie 的实现相比别的树结构来说简单的很多，实现就以搜索英文字符为例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class TrieNode &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 代表每个字符经过节点的次数</span><br><span class="line">    this.path &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 代表到该节点的字符串有几个</span><br><span class="line">    this.end &#x3D; 0</span><br><span class="line">    &#x2F;&#x2F; 链接</span><br><span class="line">    this.next &#x3D; new Array(26).fill(null)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Trie &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    &#x2F;&#x2F; 根节点，代表空字符</span><br><span class="line">    this.root &#x3D; new TrieNode()</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 插入字符串</span><br><span class="line">  insert(str) &#123;</span><br><span class="line">    if (!str) return</span><br><span class="line">    let node &#x3D; this.root</span><br><span class="line">    for (let i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">      &#x2F;&#x2F; 获得字符先对应的索引</span><br><span class="line">      let index &#x3D; str[i].charCodeAt() - &#39;a&#39;.charCodeAt()</span><br><span class="line">      &#x2F;&#x2F; 如果索引对应没有值，就创建</span><br><span class="line">      if (!node.next[index]) &#123;</span><br><span class="line">        node.next[index] &#x3D; new TrieNode()</span><br><span class="line">      &#125;</span><br><span class="line">      node.path +&#x3D; 1</span><br><span class="line">      node &#x3D; node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.end +&#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 搜索字符串出现的次数</span><br><span class="line">  search(str) &#123;</span><br><span class="line">    if (!str) return</span><br><span class="line">    let node &#x3D; this.root</span><br><span class="line">    for (let i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">      let index &#x3D; str[i].charCodeAt() - &#39;a&#39;.charCodeAt()</span><br><span class="line">      &#x2F;&#x2F; 如果索引对应没有值，代表没有需要搜素的字符串</span><br><span class="line">      if (!node.next[index]) &#123;</span><br><span class="line">        return 0</span><br><span class="line">      &#125;</span><br><span class="line">      node &#x3D; node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    return node.end</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 删除字符串</span><br><span class="line">  delete(str) &#123;</span><br><span class="line">    if (!this.search(str)) return</span><br><span class="line">    let node &#x3D; this.root</span><br><span class="line">    for (let i &#x3D; 0; i &lt; str.length; i++) &#123;</span><br><span class="line">      let index &#x3D; str[i].charCodeAt() - &#39;a&#39;.charCodeAt()</span><br><span class="line">      &#x2F;&#x2F; 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串</span><br><span class="line">      &#x2F;&#x2F; 已经一个，直接删除即可</span><br><span class="line">      if (--node.next[index].path &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        node.next[index] &#x3D; null</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      node &#x3D; node.next[index]</span><br><span class="line">    &#125;</span><br><span class="line">    node.end -&#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h1><blockquote>
<p>并查集是一种特殊的树结构，用于处理一些不交集的合并及查询问题。该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己。<br>这个结构中有两个重要的操作，分别是：</p>
</blockquote>
<ul>
<li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li>
<li>Union：将两个子集合并成同一个集合。</li>
</ul>
<h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class DisjointSet &#123;</span><br><span class="line">  &#x2F;&#x2F; 初始化样本</span><br><span class="line">  constructor(count) &#123;</span><br><span class="line">    &#x2F;&#x2F; 初始化时，每个节点的父节点都是自己</span><br><span class="line">    this.parent &#x3D; new Array(count)</span><br><span class="line">    &#x2F;&#x2F; 用于记录树的深度，优化搜索复杂度</span><br><span class="line">    this.rank &#x3D; new Array(count)</span><br><span class="line">    for (let i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">      this.parent[i] &#x3D; i</span><br><span class="line">      this.rank[i] &#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  find(p) &#123;</span><br><span class="line">    &#x2F;&#x2F; 寻找当前节点的父节点是否为自己，不是的话表示还没找到</span><br><span class="line">    &#x2F;&#x2F; 开始进行路径压缩优化</span><br><span class="line">    &#x2F;&#x2F; 假设当前节点父节点为 A</span><br><span class="line">    &#x2F;&#x2F; 将当前节点挂载到 A 节点的父节点上，达到压缩深度的目的</span><br><span class="line">    while (p !&#x3D; this.parent[p]) &#123;</span><br><span class="line">      this.parent[p] &#x3D; this.parent[this.parent[p]]</span><br><span class="line">      p &#x3D; this.parent[p]</span><br><span class="line">    &#125;</span><br><span class="line">    return p</span><br><span class="line">  &#125;</span><br><span class="line">  isConnected(p, q) &#123;</span><br><span class="line">    return this.find(p) &#x3D;&#x3D;&#x3D; this.find(q)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 合并</span><br><span class="line">  union(p, q) &#123;</span><br><span class="line">    &#x2F;&#x2F; 找到两个数字的父节点</span><br><span class="line">    let i &#x3D; this.find(p)</span><br><span class="line">    let j &#x3D; this.find(q)</span><br><span class="line">    if (i &#x3D;&#x3D;&#x3D; j) return</span><br><span class="line">    &#x2F;&#x2F; 判断两棵树的深度，深度小的加到深度大的树下面</span><br><span class="line">    &#x2F;&#x2F; 如果两棵树深度相等，那就无所谓怎么加</span><br><span class="line">    if (this.rank[i] &lt; this.rank[j]) &#123;</span><br><span class="line">      this.parent[i] &#x3D; j</span><br><span class="line">    &#125; else if (this.rank[i] &gt; this.rank[j]) &#123;</span><br><span class="line">      this.parent[j] &#x3D; i</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.parent[i] &#x3D; j</span><br><span class="line">      this.rank[j] +&#x3D; 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>堆通常是一个可以被看做一棵树的数组对象。<br>堆的实现通过构造<strong>二叉堆</strong>，实为二叉树的一种。这种数据结构具有以下性质。</p>
<ul>
<li>任意节点小于（或大于）它的所有子节点</li>
<li>堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入。<br>将根节点最大的堆叫做<strong>最大堆</strong>或<strong>大根堆</strong>，根节点最小的堆叫做<strong>最小堆</strong>或<strong>小根堆</strong>。<br>优先队列也完全可以用堆来实现，操作是一模一样的。</li>
</ul>
<h2 id="实现大根堆"><a href="#实现大根堆" class="headerlink" title="实现大根堆"></a>实现大根堆</h2><p>堆的每个节点的左边子节点索引是 i * 2 + 1，右边是 i * 2 + 2，父节点是 (i - 1) /2。<br>堆有两个核心的操作，分别是 shiftUp 和 shiftDown 。前者用于添加元素，后者用于删除根节点。<br>shiftUp 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。<br>shiftDown 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class MaxHeap &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.heap &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    return this.heap.length</span><br><span class="line">  &#125;</span><br><span class="line">  empty() &#123;</span><br><span class="line">    return this.size() &#x3D;&#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line">  add(item) &#123;</span><br><span class="line">    this.heap.push(item)</span><br><span class="line">    this._shiftUp(this.size() - 1)</span><br><span class="line">  &#125;</span><br><span class="line">  removeMax() &#123;</span><br><span class="line">    this._shiftDown(0)</span><br><span class="line">  &#125;</span><br><span class="line">  getParentIndex(k) &#123;</span><br><span class="line">    return parseInt((k - 1) &#x2F; 2)</span><br><span class="line">  &#125;</span><br><span class="line">  getLeftIndex(k) &#123;</span><br><span class="line">    return k * 2 + 1</span><br><span class="line">  &#125;</span><br><span class="line">  _shiftUp(k) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果当前节点比父节点大，就交换</span><br><span class="line">    while (this.heap[k] &gt; this.heap[this.getParentIndex(k)]) &#123;</span><br><span class="line">      this._swap(k, this.getParentIndex(k))</span><br><span class="line">      &#x2F;&#x2F; 将索引变成父节点</span><br><span class="line">      k &#x3D; this.getParentIndex(k)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _shiftDown(k) &#123;</span><br><span class="line">    &#x2F;&#x2F; 交换首位并删除末尾</span><br><span class="line">    this._swap(k, this.size() - 1)</span><br><span class="line">    this.heap.splice(this.size() - 1, 1)</span><br><span class="line">    &#x2F;&#x2F; 判断节点是否有左孩子，因为二叉堆的特性，有右必有左</span><br><span class="line">    while (this.getLeftIndex(k) &lt; this.size()) &#123;</span><br><span class="line">      let j &#x3D; this.getLeftIndex(k)</span><br><span class="line">      &#x2F;&#x2F; 判断是否有右孩子，并且右孩子是否大于左孩子</span><br><span class="line">      if (j + 1 &lt; this.size() &amp;&amp; this.heap[j + 1] &gt; this.heap[j]) j++</span><br><span class="line">      &#x2F;&#x2F; 判断父节点是否已经比子节点都大</span><br><span class="line">      if (this.heap[k] &gt;&#x3D; this.heap[j]) break</span><br><span class="line">      this._swap(k, j)</span><br><span class="line">      k &#x3D; j</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  _swap(left, right) &#123;</span><br><span class="line">    let rightValue &#x3D; this.heap[right]</span><br><span class="line">    this.heap[right] &#x3D; this.heap[left]</span><br><span class="line">    this.heap[left] &#x3D; rightValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>解决get请求过长的问题小记</title>
    <url>/2020/01/09/solve-get-params-so-long-problem/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就在前天，公司里一位新入职的前端小伙伴找到我说遇到了一个问题，自己写的vue代码本地运行是好用的，但是打包后提给后台就访问不了接口了，刚开始我以为是代理配置的有问题，但是经过检查也没什么问题，因为是个<code>get</code>方法，所以我就直接在浏览器地址里敲了api地址，也能正常获取到数据，那么这么看就不是代理或者接口的问题，后来我又看了下调试工具，network中根本就没发出请求，我怀疑是直接前台就拦截了，最后我发现他这个api参数超级长，长的相当吓人，可以看一下下图。<br><img src="https://s2.ax1x.com/2020/01/09/lROUMt.png" alt="lROUMt.png"><br>我记得url是有长度限制的，于是我就把url变短再次请求，虽然因为参数不全，接口报了错，但是发出去了，由此我定位应该是url超长，因为vue中配置了什么导致的访问被拦截了。于是我就开始了搜索引擎查找解决方案之旅，接下来就把我了解到的信息一一整理。</p>
<a id="more"></a>

<h2 id="URL-限制"><a href="#URL-限制" class="headerlink" title="URL 限制"></a>URL 限制</h2><p>首先我在网上找到了一份资料介绍了URL长度的相关资料，从下面可以看出，从HTTP协议层面以及Get请求层面都没有什么限制，这个限制来自于<strong><em>浏览器或者服务器的限制</em></strong>。</p>
<blockquote>
<p>Microsoft Internet Explorer (Browser)<br>IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。<br>Firefox (Browser)<br>对于Firefox浏览器URL的长度限制为65,536个字符。<br>Safari (Browser)<br>URL最大长度限制为 80,000个字符。<br>Opera (Browser)<br>URL最大长度限制为190,000个字符。<br>Google (Browser)<br>URL最大长度限制为8182个字符。<br>Apache (Server)<br>能接受最大url长度为8,192个字符。<br>Microsoft Internet Information Server(IIS)<br>能接受最大url的长度为16,384个字符。</p>
</blockquote>
<p>而且，中文会进行编码，一个汉字编码后会生成9个字符，这样算来，IE下最多也就能输入231个中文，再多就完蛋了，那么通过get请求传递参数就会显得很麻烦。</p>
<p>通常情况下，这种超长参数的请求我们都会用post，有些地方也会说post请求没有长度限制，但是前面说了，实际上HTTP协议层面并没有任何的限制，限制只出现在浏览器或者服务器限制，get和post请求在底层上其实是一样的。</p>
<p>最后项目修改了请求类型，把 <code>get</code> 请求改成了 <code>post</code> 请求，在网上实际还找到了另外两个方案，如果对同一组参数频繁访问的化，也可以用 <code>post+get</code> 请求的方式去处理，或者用 <code>sessionStorage</code> 下面简单介绍一下。</p>
<ol>
<li>将预览内容 <code>post</code> 到服务端，根据一个唯一标识生成缓存(有效时间5分钟)，将唯一标识返回到前端，前端通过get方式传递唯一标识请求预览逻辑，拿到缓存的内容后渲染到页面。需要说明的是这里的缓存必须是分布式的。</li>
<li>通过H5的会话缓存 <code>sessionStorage</code> 将预览内容存储在浏览器，打开预览页后从 <code>sessionStorage</code> 中拿到内容就可以渲染出页面了。</li>
</ol>
<p>上述两种方案都不太符合我们的项目所以最终还是选择了最简单的方式</p>
<h2 id="GET-VS-POST"><a href="#GET-VS-POST" class="headerlink" title="GET VS POST"></a>GET VS POST</h2><ol>
<li><p>多数浏览器对于POST采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于GET），也就是第一步发送header数据，第二步再发送body部分。HTTP是应用层的协议，而在传输层有些情况TCP会出现两次连结的过程，HTTP协议本身不保存状态信息，一次请求一次响应。对于TCP而言，通信次数越多反而靠性越低，能在一次连结中传输完需要的消息是最可靠的，尽量使用GET请求来减少网络耗时。如果通信时间增加，这段时间客户端与服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。</p>
</li>
<li><p>GET请求能够被cache，GET请求能够被保存在浏览器的浏览历史里面（密码等重要数据GET提交，别人查看历史记录，就可以直接看到这些私密数据）POST不进行缓存。</p>
</li>
<li><p>GET参数是带在URL后面，传统IE中URL的最大可用长度为2048字符，其他浏览器对URL长度限制实现上有所不同。POST请求无长度限制（目前理论上是这样的）。</p>
</li>
<li><p>GET提交的数据大小，不同浏览器的限制不同，一般在2k-8K之间，POST提交数据比较大，大小靠服务器的设定值限制，而且某些数据只能用 POST 方法「携带」，比如 file。</p>
</li>
<li><p>全部用POST不是十分合理，最好先把请求按功能和场景分下类，对数据请求频繁，数据不敏感且数据量在普通浏览器最小限定的2k范围内，这样的情况使用GET。其他地方使用POST。</p>
</li>
<li><p>GET 的本质是「得」，而 POST 的本质是「给」。而且，GET 是「幂等」的，在这一点上，GET 被认为是「安全的」。但实际上 server 端也可以用作资源更新，但是这种用法违反了约定，容易造成 CSRF（跨站请求伪造）。</p>
</li>
</ol>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>以上是这次遇到问题后学到的一点知识，可能并不全面，后续如果遇到了类似的问题会继续丰富这篇文章。</p>
]]></content>
      <categories>
        <category>前端问题集</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>get</tag>
      </tags>
  </entry>
  <entry>
    <title>介绍一个好用的doc展示库 ---- vuepress</title>
    <url>/2020/01/05/FE-guide-vuepress/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做公司技术规范，需要能通过 <code>B/S</code> 方式进行分发，起初想法是做一个网站，用 <code>html</code> 的方式进行书写，但是后面感觉太麻烦了，所以就放弃了，偶然间看到有工具可以直接通过 <code>md</code> 文件编译生成网站，就像是 <code>hexo</code> 博客这样，我觉得这挺好，极大的节省了开发网站所需要的时间，只需要专注于内容就好了，所以我就研究了下来，整个了解过程中有这么两个工具映入了我的眼帘，一个是 <code>doctify</code>，另外一个就是今天的主角 <code>vuepress</code> 。</p>
<a id="more"></a>

<h1 id="vuepress-何许"><a href="#vuepress-何许" class="headerlink" title="vuepress 何许"></a><code>vuepress</code> 何许</h1>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>工具分享</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 柯里化 currying</title>
    <url>/2020/01/05/FE-guide-currying/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<p>柯里化，可以理解为<strong><em>提前接收部分参数，延迟执行，不立即输出结果，而是返回一个接受剩余参数的函数</em></strong>。因为这样的特性，也被称为部分计算函数。</p>
<p>通俗易懂的解释：用<strong><em>闭包</em></strong>把参数保存起来，当参数的数量足够执行函数了，就开始执行函数。柯里化，是一个逐步接收参数的过程。在接下来的剖析中，你会深刻体会到这一点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function currying(fn)&#123;</span><br><span class="line">    var allArgs &#x3D; [];</span><br><span class="line"></span><br><span class="line">    return function next()&#123;</span><br><span class="line">        var args &#x3D; [].slice.call(arguments); &#x2F;&#x2F; 拆成数组元素</span><br><span class="line"></span><br><span class="line">        if(args.length &gt; 0)&#123;</span><br><span class="line">            allArgs &#x3D; allArgs.concat(args);</span><br><span class="line">            return next;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return fn.apply(null, allArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来一个简单的实例验证一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var add &#x3D; currying(function()&#123;</span><br><span class="line">    var sum &#x3D; 0;</span><br><span class="line">    for(var i &#x3D; 0; i &lt; arguments.length; i++)&#123;</span><br><span class="line">        sum +&#x3D; arguments[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">add(1)(2, 3)(4)() &#x2F;&#x2F; &#x3D;&gt; 10</span><br></pre></td></tr></table></figure>

<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h2 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function getUrl(domain, protocol, path) &#123;</span><br><span class="line">	return protocol + &quot;:&#x2F;&#x2F;&quot; + domain + &quot;&#x2F;&quot; + path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var page1 &#x3D; getUrl(&#39;http&#39;, &#39;lixuguang.github.io&#39;, &#39;page1.html&#39;);</span><br><span class="line">var page2 &#x3D; getUrl(&#39;http&#39;, &#39;lixuguang.github.io&#39;, &#39;page2.html&#39;);</span><br></pre></td></tr></table></figure>
<p>我们使用currying来简化它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var conardliSite &#x3D; currying(getUrl)</span><br><span class="line">var page1 &#x3D; conardliSite(&#39;page1.html&#39;)(&#39;http&#39;, &#39;lixuguang.github.io&#39;)();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce函数的妙用 ---- 实现map和filter</title>
    <url>/2020/01/05/FE-guide-about-reduce/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看了好多技术文章，好多的代码片段，突然发现好多的代码里都有 <code>reduce</code> ，感觉以前都没怎么关注过这个函数，为了弥补这个过失，打算专门写一篇文章说说它。</p>
<p><code>reduce</code> 函数在 MDN 中是这样介绍的</p>
<blockquote>
<p>reduce() 方法对数组中的<strong><em>每个元素</em></strong>执行一个由 <strong><em>您</em></strong> 提供的 <code>reducer</code> 函数(<strong><em>升序执行</em></strong>)，将其结果汇总为单个返回值。</p>
</blockquote>
<p>说实话看了一脸懵逼，这上面说的叫人话？后来耐着性子看了一些代码后感觉有所理解，如果理解不对，还请斧正。<br>首先看一下这里面几个关键词</p>
<p><strong>* 每个元素： *</strong> 这就是遍历咯，没啥好说的<br><strong><em>您</em></strong>提供的 <code>reducer</code> 函数：我哪有什么 <code>reducer</code> 函数呢，后来理解了，就是回调，有的地方呢叫 <code>handler</code> ，这里跟 <code>reduce</code> 配合就叫了 <code>reducer</code>。<br><strong><em>升序执行</em></strong>：就是说是0，1，2下标这样的顺序执行啦。<br>将其结果汇总为单个返回值：最后返回的是一个值，当然没说必须是什么类型。</p>
<p>这样解释完了以后，上面这句话就比较好懂了，简单说就是 <code>reduce</code> 里传一个回调函数，执行回调函数方法后返回一个值，就是这样。</p>
<blockquote>
<p>reducer 函数接收4个参数:</p>
</blockquote>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)<br>您的 <code>reducer</code> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<p>看上面的描述一定要注意，这些参数是 <code>reducer</code> 的参数，不是 <code>reduce</code> 的参数，一共有4个，通常用前两个情况比较多。</p>
<p>那么 <code>reduce</code> 函数呢实际上有两个参数，第二个还可以省略 <code>reducer</code> 和 <code>initialValue</code>，<code>initialValue</code>作为第一次调用 <code>reducer</code> 函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 <strong><em>在没有初始值的空数组上调用 <code>reduce</code> 将报错</em></strong>，这点切记。</p>
<p>终于把前置知识讲清楚了，接下来，我们就用 <code>reduce</code> 搞点事情。</p>
<h2 id="1-使用-reduce-实现-map"><a href="#1-使用-reduce-实现-map" class="headerlink" title="1. 使用 reduce 实现 map"></a>1. 使用 <code>reduce</code> 实现 <code>map</code></h2><p><code>map</code> 的话我不想再讲一遍，一句话带过，就是对回调函数中的元素进行加工后返回一个长度一样的新数组。<br>那么该如何实现呢，我们来想想原理吧，刚才上面说过了，reduce执行过后的返回值会作为下一次执行的第一个参数放进去，那么就可以先用一个空数组作为初始值来接受每次需要处理的元素的集合，并返回回去，作为下一次传入的第一个参数，这样每次操作完之后就可以push到这个数组中，那么剩下要做的就是处理数组中每一项的函数了，我们叫他 <code>handler</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Array.prototype.reduceToMap &#x3D; function (handler) &#123; &#x2F;&#x2F; 自定义 &#96;map&#96; 函数 &#96;reduceToMap&#96;</span><br><span class="line">  return this.reduce((target, current, index) &#x3D;&gt; &#123; &#x2F;&#x2F; this指向调用他的数组</span><br><span class="line">    target.push(handler.call(this, current, index)) &#x2F;&#x2F; 这里用了call方法，handler将接受两个参数 current和index</span><br><span class="line">    return target; &#x2F;&#x2F; 处理完成后返回新数组</span><br><span class="line">  &#125;, []) &#x2F;&#x2F; 初始化空的新数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>就这样我们就用 <code>reduce</code>，实现了 <code>map</code> 的功能，是不是很好用？</p>
<h2 id="2-使用-reduce-实现-filter"><a href="#2-使用-reduce-实现-filter" class="headerlink" title="2. 使用 reduce 实现 filter"></a>2. 使用 <code>reduce</code> 实现 <code>filter</code></h2><p><code>filter</code> 也是数组常用的方法，同样传入一个回调函数，处理结果返回true或false，最终 <code>filter</code> 会返回一个过滤后的函数。<br>学会了上面的 <code>map</code> 的实现，实际上 <code>filter</code> 就会很简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Array.prototype.reduceToFilter &#x3D; function (handler) &#123; &#x2F;&#x2F; 还是自定义方法名</span><br><span class="line">  return this.reduce((target, current, index) &#x3D;&gt; &#123;</span><br><span class="line">    if (handler.call(this, current, index)) &#123; &#x2F;&#x2F; 这里注意 handler 要返回的是布尔类型的值</span><br><span class="line">      target.push(current); &#x2F;&#x2F; 符合条件就插入新数组</span><br><span class="line">    &#125; &#x2F;&#x2F; 不符合就什么都不做</span><br><span class="line">    return target; &#x2F;&#x2F; 最后返回新数组</span><br><span class="line">  &#125;, []) &#x2F;&#x2F; 初始化一个空数组</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>日后在看到 <code>reduce</code> 的妙用之后还会来补充这篇文章，如果实在懒得写，我也会链接一下新文章，希望大家长期关注。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>数组常见操作 ---- 去重、扁平、取最大最小值</title>
    <url>/2020/01/05/FE-guide-ArrayOprs/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h1><h2 id="1-利用-Object-的-Key-唯一特性"><a href="#1-利用-Object-的-Key-唯一特性" class="headerlink" title="1. 利用 Object 的 Key 唯一特性"></a>1. 利用 <code>Object</code> 的 <code>Key</code> 唯一特性</h2><p>开辟一个外部存储空间用于标示元素是否出现过。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; (array)&#x3D;&gt; &#123;</span><br><span class="line">    var container &#x3D; &#123;&#125;;</span><br><span class="line">    return array.filter((item, index) &#x3D;&gt;  container.hasOwnProperty(item) ? false : (container[item] &#x3D; true));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-利用-indexOf-的返回值数值进行去重"><a href="#2-利用-indexOf-的返回值数值进行去重" class="headerlink" title="2. 利用 indexOf 的返回值数值进行去重"></a>2. 利用 <code>indexOf</code> 的返回值数值进行去重</h2><p>原理是 <code>indexOf</code> 获取元素时如果返回值不等于下标说明已经有了，配合 <code>filter</code> 更美味</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; arr.filter((e,i) &#x3D;&gt; </span><br><span class="line">  arr.indexOf(e) &#x3D;&#x3D;&#x3D; i &#x2F;&#x2F; 如果元素找到的当前下标和当前索引相同说明是同一个，不同说明不是唯一</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>还有一种变形方法利用 <code>lastIndexOf</code> 方法</p>
<blockquote>
<p>lastIndexOf() 方法返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const filterNonUnique &#x3D; arr &#x3D;&gt; arr.filter(e &#x3D;&gt; </span><br><span class="line">  arr.indexOf(e) &#x3D;&#x3D;&#x3D; arr.lastIndexOf(e) &#x2F;&#x2F; 判断一个元素出现时的第一次下标和最后一次下标是否相同，如果相同那么就唯一</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="3-利用-Set-特性去重"><a href="#3-利用-Set-特性去重" class="headerlink" title="3. 利用 Set 特性去重"></a>3. 利用 <code>Set</code> 特性去重</h2><p><code>Set</code> 是 <code>ES6</code> 中新的数据类型，它的特点就是元素唯一性，且可以和数组进行转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; Array.from(new Set(arr)); &#x2F;&#x2F; Array.from 方法从一个类似数组或可迭代对象创建一个新的，浅拷贝的数组实例。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 优化</span><br><span class="line"></span><br><span class="line">const unique &#x3D; arr &#x3D;&gt; [...new Set(arr)]; &#x2F;&#x2F; 利用 &#96;ES6&#96; 中展开操作</span><br></pre></td></tr></table></figure>
<h2 id="4-排序后判断前后两项是否相等去重"><a href="#4-排序后判断前后两项是否相等去重" class="headerlink" title="4. 排序后判断前后两项是否相等去重"></a>4. 排序后判断前后两项是否相等去重</h2><p>通过比较相邻数字是否重复，将排序后的数组进行去重。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const unique &#x3D; (array) &#x3D;&gt; &#123;</span><br><span class="line">  array.sort((a, b) &#x3D;&gt; a - b);</span><br><span class="line">  let pre &#x3D; 0;</span><br><span class="line">  const result &#x3D; [];</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (!i || array[i] !&#x3D; array[pre]) &#123;</span><br><span class="line">      result.push(array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pre &#x3D; i;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扁平"><a href="#扁平" class="headerlink" title="扁平"></a>扁平</h1><h2 id="1-普通方法"><a href="#1-普通方法" class="headerlink" title="1. 普通方法"></a>1. 普通方法</h2><p>通过递归的方式判断数组中的项是否是数组，如果不是就加入到新的扁平数组，如果是就递归调用逐层判断，直到全部结束</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const flatten &#x3D; (array) &#x3D;&gt; &#123; &#x2F;&#x2F; array 原数组</span><br><span class="line">  let result &#x3D; []; &#x2F;&#x2F; 定义新的扁平数组</span><br><span class="line">  for (let i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">    if (Array.isArray(array[i])) &#123; &#x2F;&#x2F; 判断子元素是否是数组</span><br><span class="line">      result &#x3D; result.concat(flatten(array[i])); &#x2F;&#x2F; 递归判断</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(array[i]); &#x2F;&#x2F; 加入新数组</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-使用reduce简化上述方法"><a href="#2-使用reduce简化上述方法" class="headerlink" title="2. 使用reduce简化上述方法"></a>2. 使用reduce简化上述方法</h2><blockquote>
<p>reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。<br>reducer 函数接收4个参数:</p>
</blockquote>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)</li>
<li>您的 reducer 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<p>先看一段 reduce 的示例函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const array1 &#x3D; [1, 2, 3, 4];</span><br><span class="line">const reducer &#x3D; (accumulator, currentValue) &#x3D;&gt; accumulator + currentValue; &#x2F;&#x2F; 定义一个累计器函数，作用是将数组前后累计值与当前值累加</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer)); &#x2F;&#x2F; 没有初始值用第一个元素</span><br><span class="line">&#x2F;&#x2F; expected output: 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5 + 1 + 2 + 3 + 4</span><br><span class="line">console.log(array1.reduce(reducer, 5)); &#x2F;&#x2F; 有初始值从初始值开始</span><br><span class="line">&#x2F;&#x2F; expected output: 15</span><br></pre></td></tr></table></figure>
<p>这下大家应该对 reduce 函数认识了，接下来看看怎么简化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function flatten(array) &#123;</span><br><span class="line">  return array.reduce((newArray, current) &#x3D;&gt; &#x2F;&#x2F; 新数组，当前项</span><br><span class="line">    Array.isArray(current) ? &#x2F;&#x2F; 判断当前项是否为数组</span><br><span class="line">      newArray.concat(flatten(current)) : &#x2F;&#x2F; 是的话 递归调用</span><br><span class="line">      newArray.concat(current) &#x2F;&#x2F; 不是的话加进新数组</span><br><span class="line">  , []) &#x2F;&#x2F; 初始化新数组为空</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们再变一个形，增加一个变量，变成可指定深度操作数组</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function flattenByDeep(array, deep &#x3D; 1) &#123; &#x2F;&#x2F; 默认一层</span><br><span class="line">  return array.reduce(</span><br><span class="line">    (target, current) &#x3D;&gt;</span><br><span class="line">      Array.isArray(current) &amp;&amp; deep &gt; 1 ?</span><br><span class="line">        target.concat(flattenByDeep(current, deep - 1)) : &#x2F;&#x2F; 下一次减一层</span><br><span class="line">        target.concat(current)</span><br><span class="line">    , [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h1><h2 id="利用-reduce"><a href="#利用-reduce" class="headerlink" title="利用 reduce"></a>利用 <code>reduce</code></h2><p><code>reduce</code> 函数真的是超级好用，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">array.reduce((c,n) &#x3D;&gt; Math.max(c,n))</span><br></pre></td></tr></table></figure>

<h2 id="Math-max"><a href="#Math-max" class="headerlink" title="Math.max"></a>Math.max</h2><p><code>Math.max</code> 参数原本是一组数字，只需要让他可以接收数组即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const array &#x3D; [3,2,1,4,5];</span><br><span class="line">Math.max.apply(null,array);</span><br><span class="line">Math.max(...array);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript实现经典排序算法</title>
    <url>/2020/01/04/Algorithm/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>一个算法的时间复杂度反映了程序运行从开始到结束所需要的时间。把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度。<br>没有循环语句，记作O(1)，也称为常数阶。只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O（n），也叫线性阶。<br>常见的时间复杂度有：</p>
<ul>
<li>O(1): Constant Complexity: Constant 常数复杂度</li>
<li>O(log n): Logarithmic Complexity: 对数复杂度</li>
<li>O(n): Linear Complexity: 线性时间复杂度</li>
<li>O(n^2): N square Complexity 平⽅方</li>
<li>O(n^3): N square Complexity ⽴立⽅方</li>
<li>O(2^n): Exponential Growth 指数</li>
<li>O(n!): Factorial 阶乘</li>
</ul>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。</p>
<p>一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。</p>
<ul>
<li>稳定</li>
<li>不稳定<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><img src="https://i.loli.net/2020/01/04/TqaRjEJSnhtQ5vH.png" alt="十大经典排序.jpg"><h2 id="关于时间复杂度："><a href="#关于时间复杂度：" class="headerlink" title="关于时间复杂度："></a>关于时间复杂度：</h2>平方阶 (O(n2)) 排序 各类简单排序：直接插入、直接选择和冒泡排序。<br>线性对数阶 (O(nlog2n)) 排序 快速排序、堆排序和归并排序；<br>O(n1+§)) 排序，§ 是介于 0 和 1 之间的常数。 希尔排序<br>线性阶 (O(n)) 排序 基数排序，此外还有桶、箱排序。</li>
</ul>
<h2 id="关于稳定性："><a href="#关于稳定性：" class="headerlink" title="关于稳定性："></a>关于稳定性：</h2><p>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。<br>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</p>
<h2 id="名词解释："><a href="#名词解释：" class="headerlink" title="名词解释："></a>名词解释：</h2><ul>
<li>n：数据规模</li>
<li>k：“桶”的个数</li>
<li>In-place：占用常数内存，不占用额外内存</li>
<li>Out-place：占用额外内存</li>
<li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li>
</ul>
<h1 id="1-冒泡排序（Bubble-Sort）-—-前后两两比较-—-气泡"><a href="#1-冒泡排序（Bubble-Sort）-—-前后两两比较-—-气泡" class="headerlink" title="1. 冒泡排序（Bubble Sort） — 前后两两比较 — 气泡"></a>1. 冒泡排序（Bubble Sort） — 前后两两比较 — 气泡</h1><p>冒泡排序可谓是最经典的排序算法了，它是基于比较的排序算法，其优点是实现简单，排序数量较小时性能较好。</p>
<p>它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h2 id="1-1-算法原理"><a href="#1-1-算法原理" class="headerlink" title="1. 1 算法原理"></a>1. 1 算法原理</h2><p>相邻的数据进行两两比较，小数放在前面，大数放在后面，如果前面的数据比后面的数据大，就交换这两个数的位置。也可以实现大数放在前面，小数放在后面，如果前面的数据比后面的小，就交换两个的位置。要实现上述规则需要用到两层for循环。</p>
<h2 id="1-2-算法描述"><a href="#1-2-算法描述" class="headerlink" title="1. 2 算法描述"></a>1. 2 算法描述</h2><ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ol>
<h2 id="1-3-动图演示"><a href="#1-3-动图演示" class="headerlink" title="1. 3 动图演示"></a>1. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldB5VS.gif" alt="ldB5VS.gif"></p>
<h2 id="1-4-js代码实现"><a href="#1-4-js代码实现" class="headerlink" title="1. 4 js代码实现"></a>1. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">  var len &#x3D; arr.length;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    for (var j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F; 相邻元素两两对比</span><br><span class="line">      &#x2F;&#x2F; 元素交换</span><br><span class="line">      &#x2F;** 1.使用中间变量 **&#x2F; </span><br><span class="line">        var temp &#x3D; arr[j + 1]; </span><br><span class="line">        arr[j + 1] &#x3D; arr[j]</span><br><span class="line">        arr[j] &#x3D; temp</span><br><span class="line">        &#x2F;** 2.适用纯数字的数组排序 **&#x2F;</span><br><span class="line">        arr[j] &#x3D; arr[j] +  arr[j + 1]</span><br><span class="line">        arr[j + 1] &#x3D;  arr[j] - arr[j + 1]</span><br><span class="line">        arr[j] -&#x3D; arr[j + 1]</span><br><span class="line">        &#x2F;** 3.使用es6解构赋值 **&#x2F;</span><br><span class="line">        [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>冒泡排序算法优化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bubbleSort(arr) &#123;</span><br><span class="line">  var len &#x3D; arr.length;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">    var exchange&#x3D;false; &#x2F;&#x2F; 交换标志 </span><br><span class="line">    for (var j &#x3D; 0; j &lt; len - 1 - i; j++) &#123;</span><br><span class="line">      if (arr[j] &gt; arr[j + 1]) &#123; &#x2F;&#x2F; 相邻元素两两对比</span><br><span class="line">        [arr[j], arr[j + 1]] &#x3D; [arr[j + 1], arr[j]] &#x2F;&#x2F; 元素交换</span><br><span class="line">        exchange&#x3D;true; &#x2F;&#x2F;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!exchange)&#123; &#x2F;&#x2F; 若本趟排序未发生交换，提前终止算法</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="2-选择排序（Selection-Sort）-—-面试挑简历，在剩下的里面挑最好的"><a href="#2-选择排序（Selection-Sort）-—-面试挑简历，在剩下的里面挑最好的" class="headerlink" title="2. 选择排序（Selection Sort） — 面试挑简历，在剩下的里面挑最好的"></a>2. 选择排序（Selection Sort） — 面试挑简历，在剩下的里面挑最好的</h1><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n²)的时间复杂度。。。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p>
<h2 id="2-1-算法原理"><a href="#2-1-算法原理" class="headerlink" title="2. 1 算法原理"></a>2. 1 算法原理</h2><p>先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h2 id="2-2-算法描述"><a href="#2-2-算法描述" class="headerlink" title="2. 2 算法描述"></a>2. 2 算法描述</h2><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ol>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中</li>
<li>选出关键字最小的记录R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ol>
<h2 id="2-3-动图演示"><a href="#2-3-动图演示" class="headerlink" title="2. 3 动图演示"></a>2. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldDWW9.gif" alt="ldDWW9.gif"></p>
<h2 id="2-4-js代码实现"><a href="#2-4-js代码实现" class="headerlink" title="2. 4 js代码实现"></a>2. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function selectionSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    var minIndex, temp;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; len - 1; i++) &#123;</span><br><span class="line">        minIndex &#x3D; i;</span><br><span class="line">        for (var j &#x3D; i + 1; j &lt; len; j++) &#123;</span><br><span class="line">            if (arr[j] &lt; arr[minIndex]) &#123;     &#x2F;&#x2F;寻找最小的数</span><br><span class="line">                minIndex &#x3D; j;                 &#x2F;&#x2F;将最小数的索引保存</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        temp &#x3D; arr[i];</span><br><span class="line">        arr[i] &#x3D; arr[minIndex];</span><br><span class="line">        arr[minIndex] &#x3D; temp;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-插入排序（Insertion-Sort）—–-麻将-扑克"><a href="#3-插入排序（Insertion-Sort）—–-麻将-扑克" class="headerlink" title="3. 插入排序（Insertion Sort）—– 麻将/扑克"></a>3. 插入排序（Insertion Sort）—– 麻将/扑克</h1><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。</p>
<h2 id="3-1-算法原理"><a href="#3-1-算法原理" class="headerlink" title="3. 1 算法原理"></a>3. 1 算法原理</h2><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<h2 id="3-2-算法描述"><a href="#3-2-算法描述" class="headerlink" title="3. 2 算法描述"></a>3. 2 算法描述</h2><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ol>
<h2 id="3-3-动图演示"><a href="#3-3-动图演示" class="headerlink" title="3. 3 动图演示"></a>3. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/04/ldDfzR.gif" alt="ldDfzR.gif"></p>
<h2 id="3-4-js代码实现"><a href="#3-4-js代码实现" class="headerlink" title="3. 4 js代码实现"></a>3. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function insertSort(arr) &#123;</span><br><span class="line">  &#x2F;&#x2F; 从1位置开始遍历arr中每元素，同时声明空变量temp</span><br><span class="line">  for (let i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (arr[i] &lt; arr[i - 1]) &#123; &#x2F;&#x2F; 如果当前元素&lt;前一个元素</span><br><span class="line">      let temp &#x3D; arr[i] &#x2F;&#x2F; 将当前元素值临时保存在temp中</span><br><span class="line">      let p &#x3D; i - 1 &#x2F;&#x2F; 定义变量 p &#x3D; i- 1</span><br><span class="line">      &#x2F;&#x2F; 循环 条件：</span><br><span class="line">      &#x2F;&#x2F; 1. p&gt;&#x3D;0且temp小于p位置的元素</span><br><span class="line">      while (p &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[p]) &#123;</span><br><span class="line">        &#x2F;&#x2F; 循环体： 将P位置的值赋值给p的后一个元素</span><br><span class="line">        arr[p + 1] &#x3D; arr[p]</span><br><span class="line">        p-- &#x2F;&#x2F; p向前移动一个</span><br><span class="line">      &#125;</span><br><span class="line">      arr[p + 1] &#x3D; temp &#x2F;&#x2F; 将temp的值赋值给p+1位置的元素</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-快速排序（Selection-Sort）"><a href="#4-快速排序（Selection-Sort）" class="headerlink" title="4. 快速排序（Selection Sort）"></a>4. 快速排序（Selection Sort）</h1><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<h2 id="4-1-算法原理"><a href="#4-1-算法原理" class="headerlink" title="4. 1 算法原理"></a>4. 1 算法原理</h2><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<h2 id="4-2-算法描述"><a href="#4-2-算法描述" class="headerlink" title="4. 2 算法描述"></a>4. 2 算法描述</h2><p>选基准：在数据结构中选择一个元素作为基准(pivot<br>划分区：参照基准元素值的大小，划分无序区，所有小于基准元素的数据放入一个区间，所有大于基准元素的数据放入另一区间，分区操作结束后，基准元素所处的位置就是最终排序后它应该所处的位置<br>递归：对初次划分出来的两个无序区间，递归调用第 1步和第 2步的算法，直到所有无序区间都只剩下一个元素为止。</p>
<p>简单理解就是，选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。</p>
<h2 id="4-3-动图演示"><a href="#4-3-动图演示" class="headerlink" title="4. 3 动图演示"></a>4. 3 动图演示</h2><p><img src="https://i.loli.net/2020/01/04/AtNahbZF9J1dTnS.gif" alt="快速排序.gif"></p>
<h2 id="4-4-js代码实现"><a href="#4-4-js代码实现" class="headerlink" title="4. 4 js代码实现"></a>4. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function quickSort(arr)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果arr.length&lt;&#x3D;1,则直接返回arr</span><br><span class="line">    if(arr.length&lt;&#x3D;1)&#123;return arr&#125;</span><br><span class="line">    &#x2F;&#x2F; arr的元素个数&#x2F;2，再下去整，将值保存在pivotIndex中</span><br><span class="line">    var pivotIndex&#x3D;Math.floor(arr.length&#x2F;2);</span><br><span class="line">    &#x2F;&#x2F; 将arr中pivotIndex位置的元素，保存在变量pivot中</span><br><span class="line">    var pivot&#x3D;arr[pivotIndex];</span><br><span class="line">    &#x2F;&#x2F;声明空数组left和right</span><br><span class="line">    var left&#x3D;[];</span><br><span class="line">    var right&#x3D;[];</span><br><span class="line">    for(var i&#x3D;0;i&lt;arr.length;i++)&#123;  &#x2F;&#x2F; 遍历arr中每个元素</span><br><span class="line">        if(i !&#x3D;&#x3D; pivotIndex)&#123; &#x2F;&#x2F; 如果i !&#x3D;&#x3D; pivotIndex</span><br><span class="line">            if(arr[i]&lt;&#x3D;pivot)&#123; &#x2F;&#x2F; 如果当前元素值&lt;pivot</span><br><span class="line">                left.push(arr[i]); &#x2F;&#x2F; 就将当前值压入left</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                right.push(arr[i]); &#x2F;&#x2F; 就将当前值压入right</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;递归</span><br><span class="line">    return quickSort(left).concat(pivot, quickSort(right)); &#x2F;&#x2F; 链接多个数组到 left 从小到大</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-希尔排序"><a href="#5-希尔排序" class="headerlink" title="5. 希尔排序"></a>5. 希尔排序</h1><h2 id="5-1-算法原理"><a href="#5-1-算法原理" class="headerlink" title="5. 1 算法原理"></a>5. 1 算法原理</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ul>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</li>
</ul>
<h2 id="5-2-算法描述"><a href="#5-2-算法描述" class="headerlink" title="5. 2 算法描述"></a>5. 2 算法描述</h2><ul>
<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h2 id="5-3-js代码实现"><a href="#5-3-js代码实现" class="headerlink" title="5.3 js代码实现"></a>5.3 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function shellSort(arr) &#123;</span><br><span class="line">    var len &#x3D; arr.length,</span><br><span class="line">        temp,</span><br><span class="line">        gap &#x3D; 1;</span><br><span class="line">    while(gap &lt; len&#x2F;3) &#123;          &#x2F;&#x2F;动态定义间隔序列</span><br><span class="line">        gap &#x3D;gap*3+1;</span><br><span class="line">    &#125;</span><br><span class="line">    for (gap; gap &gt; 0; gap &#x3D; Math.floor(gap&#x2F;3)) &#123;</span><br><span class="line">        for (var i &#x3D; gap; i &lt; len; i++) &#123;</span><br><span class="line">            temp &#x3D; arr[i];</span><br><span class="line">            for (var j &#x3D; i-gap; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j-&#x3D;gap) &#123;</span><br><span class="line">                arr[j+gap] &#x3D; arr[j];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j+gap] &#x3D; temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6. 归并排序"></a>6. 归并排序</h1><h2 id="6-1-算法原理"><a href="#6-1-算法原理" class="headerlink" title="6. 1 算法原理"></a>6. 1 算法原理</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。<br>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；<blockquote>
<p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：<br>However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.<br>然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。</p>
</blockquote>
</li>
</ul>
<p>说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。</p>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p>
<h2 id="6-2-算法描述"><a href="#6-2-算法描述" class="headerlink" title="6. 2 算法描述"></a>6. 2 算法描述</h2><ol>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>
<li>重复步骤 3 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h2 id="6-3-动图演示"><a href="#6-3-动图演示" class="headerlink" title="6. 3 动图演示"></a>6. 3 动图演示</h2><p><img src="https://i.loli.net/2020/01/04/WMFo8Au4CGah6Kv.gif" alt="归并排序.gif"></p>
<h2 id="6-4-js代码实现"><a href="#6-4-js代码实现" class="headerlink" title="6. 4 js代码实现"></a>6. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function mergeSort(arr) &#123;  &#x2F;&#x2F; 采用自上而下的递归方法</span><br><span class="line">    var len &#x3D; arr.length;</span><br><span class="line">    if(len &lt; 2) &#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;</span><br><span class="line">    var middle &#x3D; Math.floor(len &#x2F; 2),</span><br><span class="line">        left &#x3D; arr.slice(0, middle),</span><br><span class="line">        right &#x3D; arr.slice(middle);</span><br><span class="line">    return merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function merge(left, right)&#123;</span><br><span class="line">    var result &#x3D; [];</span><br><span class="line">    while (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">        if (left[0] &lt;&#x3D; right[0]) &#123;</span><br><span class="line">            result.push(left.shift());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result.push(right.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (left.length)</span><br><span class="line">        result.push(left.shift());</span><br><span class="line"></span><br><span class="line">    while (right.length)</span><br><span class="line">        result.push(right.shift());</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-堆排序"><a href="#7-堆排序" class="headerlink" title="7. 堆排序"></a>7. 堆排序</h1><h2 id="7-1-算法原理"><a href="#7-1-算法原理" class="headerlink" title="7. 1 算法原理"></a>7. 1 算法原理</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br>堆排序的平均时间复杂度为 Ο(nlogn)。</li>
</ul>
<h1 id="7-2-算法描述"><a href="#7-2-算法描述" class="headerlink" title="7. 2 算法描述"></a>7. 2 算法描述</h1><ol>
<li>将待排序序列构建成一个堆 H[0……n-1]，根据（升序降序需求）选择大顶堆或小顶堆；</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li>
<li>重复步骤 2，直到堆的尺寸为 1。</li>
</ol>
<h2 id="7-3-动图演示"><a href="#7-3-动图演示" class="headerlink" title="7. 3 动图演示"></a>7. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/05/lBK9QH.gif" alt="堆排序.gif"></p>
<h2 id="7-4-js代码实现"><a href="#7-4-js代码实现" class="headerlink" title="7. 4 js代码实现"></a>7. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var len;    &#x2F;&#x2F; 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><br><span class="line"></span><br><span class="line">function buildMaxHeap(arr) &#123;   &#x2F;&#x2F; 建立大顶堆</span><br><span class="line">    len &#x3D; arr.length;</span><br><span class="line">    for (var i &#x3D; Math.floor(len&#x2F;2); i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        heapify(arr, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapify(arr, i) &#123;     &#x2F;&#x2F; 堆调整</span><br><span class="line">    var left &#x3D; 2 * i + 1,</span><br><span class="line">        right &#x3D; 2 * i + 2,</span><br><span class="line">        largest &#x3D; i;</span><br><span class="line"></span><br><span class="line">    if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">        largest &#x3D; left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">        largest &#x3D; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (largest !&#x3D; i) &#123;</span><br><span class="line">        swap(arr, i, largest);</span><br><span class="line">        heapify(arr, largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function swap(arr, i, j) &#123;</span><br><span class="line">    var temp &#x3D; arr[i];</span><br><span class="line">    arr[i] &#x3D; arr[j];</span><br><span class="line">    arr[j] &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function heapSort(arr) &#123;</span><br><span class="line">    buildMaxHeap(arr);</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; arr.length-1; i &gt; 0; i--) &#123;</span><br><span class="line">        swap(arr, 0, i);</span><br><span class="line">        len--;</span><br><span class="line">        heapify(arr, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-计数排序"><a href="#8-计数排序" class="headerlink" title="8. 计数排序"></a>8. 计数排序</h1><h2 id="8-1-算法原理"><a href="#8-1-算法原理" class="headerlink" title="8. 1 算法原理"></a>8. 1 算法原理</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<h2 id="8-2-算法描述"><a href="#8-2-算法描述" class="headerlink" title="8. 2 算法描述"></a>8. 2 算法描述</h2><h2 id="8-3-动图演示"><a href="#8-3-动图演示" class="headerlink" title="8. 3 动图演示"></a>8. 3 动图演示</h2><p><img src="https://s2.ax1x.com/2020/01/05/lBKq1g.gif" alt="计数排序.gif"></p>
<h2 id="8-4-js代码实现"><a href="#8-4-js代码实现" class="headerlink" title="8. 4 js代码实现"></a>8. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function countingSort(arr, maxValue) &#123;</span><br><span class="line">    var bucket &#x3D; new Array(maxValue+1),</span><br><span class="line">        sortedIndex &#x3D; 0;</span><br><span class="line">        arrLen &#x3D; arr.length,</span><br><span class="line">        bucketLen &#x3D; maxValue + 1;</span><br><span class="line"></span><br><span class="line">    for (var i &#x3D; 0; i &lt; arrLen; i++) &#123;</span><br><span class="line">        if (!bucket[arr[i]]) &#123;</span><br><span class="line">            bucket[arr[i]] &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var j &#x3D; 0; j &lt; bucketLen; j++) &#123;</span><br><span class="line">        while(bucket[j] &gt; 0) &#123;</span><br><span class="line">            arr[sortedIndex++] &#x3D; j;</span><br><span class="line">            bucket[j]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-桶排序"><a href="#9-桶排序" class="headerlink" title="9. 桶排序"></a>9. 桶排序</h1><h2 id="9-1-算法原理"><a href="#9-1-算法原理" class="headerlink" title="9. 1 算法原理"></a>9. 1 算法原理</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ul>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中<br>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。<h2 id="9-2-算法描述"><a href="#9-2-算法描述" class="headerlink" title="9. 2 算法描述"></a>9. 2 算法描述</h2><h3 id="1-什么时候最快"><a href="#1-什么时候最快" class="headerlink" title="1. 什么时候最快"></a>1. 什么时候最快</h3>当输入的数据可以均匀的分配到每一个桶中。<h3 id="2-什么时候最慢"><a href="#2-什么时候最慢" class="headerlink" title="2. 什么时候最慢"></a>2. 什么时候最慢</h3>当输入的数据被分配到了同一个桶中。<h2 id="9-3-动图演示"><a href="#9-3-动图演示" class="headerlink" title="9. 3 动图演示"></a>9. 3 动图演示</h2></li>
</ul>
<h2 id="9-4-js代码实现"><a href="#9-4-js代码实现" class="headerlink" title="9. 4 js代码实现"></a>9. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function bucketSort(arr, bucketSize) &#123;</span><br><span class="line">    if (arr.length &#x3D;&#x3D;&#x3D; 0) &#123;</span><br><span class="line">      return arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var i;</span><br><span class="line">    var minValue &#x3D; arr[0];</span><br><span class="line">    var maxValue &#x3D; arr[0];</span><br><span class="line">    for (i &#x3D; 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">      if (arr[i] &lt; minValue) &#123;</span><br><span class="line">          minValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最小值</span><br><span class="line">      &#125; else if (arr[i] &gt; maxValue) &#123;</span><br><span class="line">          maxValue &#x3D; arr[i];                &#x2F;&#x2F; 输入数据的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;桶的初始化</span><br><span class="line">    var DEFAULT_BUCKET_SIZE &#x3D; 5;            &#x2F;&#x2F; 设置桶的默认数量为5</span><br><span class="line">    bucketSize &#x3D; bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">    var bucketCount &#x3D; Math.floor((maxValue - minValue) &#x2F; bucketSize) + 1;   </span><br><span class="line">    var buckets &#x3D; new Array(bucketCount);</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        buckets[i] &#x3D; [];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;利用映射函数将数据分配到各个桶中</span><br><span class="line">    for (i &#x3D; 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        buckets[Math.floor((arr[i] - minValue) &#x2F; bucketSize)].push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    arr.length &#x3D; 0;</span><br><span class="line">    for (i &#x3D; 0; i &lt; buckets.length; i++) &#123;</span><br><span class="line">        insertionSort(buckets[i]);                      &#x2F;&#x2F; 对每个桶进行排序，这里使用了插入排序</span><br><span class="line">        for (var j &#x3D; 0; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">            arr.push(buckets[i][j]);                      </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="10-基数排序"><a href="#10-基数排序" class="headerlink" title="10. 基数排序"></a>10. 基数排序</h1><h2 id="10-1-算法原理"><a href="#10-1-算法原理" class="headerlink" title="10. 1 算法原理"></a>10. 1 算法原理</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<h2 id="10-2-算法描述"><a href="#10-2-算法描述" class="headerlink" title="10. 2 算法描述"></a>10. 2 算法描述</h2><h3 id="1-基数排序-vs-计数排序-vs-桶排序"><a href="#1-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="1. 基数排序 vs 计数排序 vs 桶排序"></a>1. 基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有三种方法：<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异案例看大家发的：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；<h2 id="10-3-动图演示"><a href="#10-3-动图演示" class="headerlink" title="10. 3 动图演示"></a>10. 3 动图演示</h2></li>
</ul>
<ol start="2">
<li>LSD 基数排序动图演示<br><img src="https://s2.ax1x.com/2020/01/05/lBQkPf.gif" alt="基数排序.gif"><h2 id="10-4-js代码实现"><a href="#10-4-js代码实现" class="headerlink" title="10. 4 js代码实现"></a>10. 4 js代码实现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; LSD Radix Sort</span><br><span class="line">var counter &#x3D; [];</span><br><span class="line">function radixSort(arr, maxDigit) &#123;</span><br><span class="line">    var mod &#x3D; 10;</span><br><span class="line">    var dev &#x3D; 1;</span><br><span class="line">    for (var i &#x3D; 0; i &lt; maxDigit; i++, dev *&#x3D; 10, mod *&#x3D; 10) &#123;</span><br><span class="line">        for(var j &#x3D; 0; j &lt; arr.length; j++) &#123;</span><br><span class="line">            var bucket &#x3D; parseInt((arr[j] % mod) &#x2F; dev);</span><br><span class="line">            if(counter[bucket]&#x3D;&#x3D;null) &#123;</span><br><span class="line">                counter[bucket] &#x3D; [];</span><br><span class="line">            &#125;</span><br><span class="line">            counter[bucket].push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        var pos &#x3D; 0;</span><br><span class="line">        for(var j &#x3D; 0; j &lt; counter.length; j++) &#123;</span><br><span class="line">            var value &#x3D; null;</span><br><span class="line">            if(counter[j]!&#x3D;null) &#123;</span><br><span class="line">                while ((value &#x3D; counter[j].shift()) !&#x3D; null) &#123;</span><br><span class="line">                      arr[pos++] &#x3D; value;</span><br><span class="line">                &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://s2.ax1x.com/2020/01/05/lBQTSS.png" alt="排序算法.png"><br>以上就是十大经典算法，算法对于前端来说并不是一个十分熟悉的领域，但是排序算法算是算法里比较入门的，还是需要掌握的，毕竟即使是为了面试也是要准备的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a><br>一本关于排序算法的 GitBook 在线书籍 《十大经典排序算法》，多语言实现。</p>
<p><a href="http://www.sohu.com/a/136157205_671058" target="_blank" rel="noopener">http://www.sohu.com/a/136157205_671058</a><br>技术面试宝典： 很全面的算法和数据结构知识（含代码实现）下篇</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 浏览器存储</title>
    <url>/2020/01/03/FE-guide-store/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="cookie，localStorage，sessionStorage，indexDB"><a href="#cookie，localStorage，sessionStorage，indexDB" class="headerlink" title="cookie，localStorage，sessionStorage，indexDB"></a>cookie，localStorage，sessionStorage，indexDB</h1><table>
<thead>
<tr>
<th>特性</th>
<th>cookie</th>
<th>localStorage</th>
<th>sessionStorage</th>
<th>indexDB</th>
</tr>
</thead>
<tbody><tr>
<td>数据生命周期</td>
<td>一般由服务器生成，可以设置过期时间</td>
<td>除非被清理，否则一直存在</td>
<td>页面关闭就清理</td>
<td>除非被清理，否则一直存在</td>
</tr>
<tr>
<td>数据存储大小</td>
<td>4K</td>
<td>5M</td>
<td>5M</td>
<td>无限制</td>
</tr>
<tr>
<td>与服务端通信</td>
<td>每次都会携带在 header 中，对于请求性能影响</td>
<td>不参与</td>
<td>不参与</td>
<td>不参与</td>
</tr>
</tbody></table>
<p>从上表可以看到， <code>cookie</code> 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 <code>localStorage</code> 和 <code>sessionStorage</code> 。对于不怎么改变的数据尽量使用 <code>localStorage</code> 存储，否则可以用 <code>sessionStorage</code> 存储。</p>
<p>对于 <code>cookie</code> ，我们还需要注意安全性。<br>| 属性      | 作用                                                           |<br>| ——— | ————————————————————– |<br>| value     | 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 |<br>| http-only | 不能通过 JS 访问 Cookie，减少 XSS 攻击                         |<br>| secure    | 只能在协议为 HTTPS 的请求中携带                                |<br>| same-site | 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击          |</p>
<h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><blockquote>
<p>Service workers 本质上充当 Web 应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步 API。</p>
</blockquote>
<p>目前该技术通常用来做缓存文件，提高首屏速度，可以试着来实现这个功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.js</span><br><span class="line">if (navigator.serviceWorker) &#123;</span><br><span class="line">  navigator.serviceWorker</span><br><span class="line">    .register(&#39;sw.js&#39;)</span><br><span class="line">    .then(function(registration) &#123;</span><br><span class="line">      console.log(&#39;service worker 注册成功&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(function(err) &#123;</span><br><span class="line">      console.log(&#39;servcie worker 注册失败&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; sw.js</span><br><span class="line">&#x2F;&#x2F; 监听 &#96;install&#96; 事件，回调中缓存所需文件</span><br><span class="line">self.addEventListener(&#39;install&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(&#39;my-cache&#39;).then(function(cache) &#123;</span><br><span class="line">      return cache.addAll([&#39;.&#x2F;index.html&#39;, &#39;.&#x2F;index.js&#39;])</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拦截所有请求事件</span><br><span class="line">&#x2F;&#x2F; 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br><span class="line">self.addEventListener(&#39;fetch&#39;, e &#x3D;&gt; &#123;</span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(function(response) &#123;</span><br><span class="line">      if (response) &#123;</span><br><span class="line">        return response</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#39;fetch source&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 <code>Service Worker</code> 已经启动了<br>在 <code>Cache</code> 中也可以发现我们所需的文件已被缓存</p>
<p>当我们重新刷新页面可以发现我们缓存的数据是从 <code>Service Worker</code> 中读取的</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么 0.1 + 0.2 != 0.3</title>
    <url>/2020/01/03/why-0.1-plus-0.2-not-equals-0.3/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p>因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题。</p>
<p>我们都知道计算机表示十进制是采用二进制表示的，所以 0.1 在二进制表示为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; (0011) 表示循环</span><br><span class="line">0.1 &#x3D; 2^-4 * 1.10011(0011)</span><br></pre></td></tr></table></figure>
<p>那么如何得到这个二进制的呢，我们可以来演算下</p>
<p>小数算二进制和整数不同。乘法计算时，只计算小数位，整数位用作每一位的二进制，并且得到的第一位为最高位。所以我们得出 <code>0.1 = 2^-4 * 1.10011(0011)</code>，那么 <code>0.2</code> 的演算也基本如上所示，只需要去掉第一步乘法，所以得出 <code>0.2 = 2^-3 * 1.10011(0011)</code>。</p>
<p>回来继续说 <code>IEEE 754</code> 双精度。六十四位中符号位占一位，整数位占十一位，其余五十二位都为小数位。因为 <code>0.1</code> 和 <code>0.2</code> 都是无限循环的二进制了，所以在小数位末尾处需要判断是否进位（就和十进制的四舍五入一样）。</p>
<p>所以 <code>2^-4 * 1.10011...001</code> 进位后就变成了 <code>2^-4 * 1.10011(0011 * 12次)010</code> 。那么把这两个二进制加起来会得出 <code>2^-2 * 1.0011(0011 * 11次)0100</code> , 这个值算成十进制就是 <code>0.30000000000000004</code></p>
<p>下面说一下原生解决办法，如下代码所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">parseFloat((0.1 + 0.2).toFixed(10))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- Proxy</title>
    <url>/2020/01/03/FE-guide-async-Proxy/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><p><code>Proxy</code> 是 <code>ES6</code> 中新增的功能，可以用来自定义对象中的操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let p &#x3D; new Proxy(target, handler);</span><br><span class="line">&#x2F;&#x2F; &#96;target&#96; 代表需要添加代理的对象</span><br><span class="line">&#x2F;&#x2F; &#96;handler&#96; 用来自定义对象中的操作</span><br></pre></td></tr></table></figure>
<p>可以很方便的使用 <code>Proxy</code> 来实现一个数据绑定和监听</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let onWatch &#x3D; (obj, setBind, getLogger) &#x3D;&gt; &#123;</span><br><span class="line">  let handler &#x3D; &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      return Reflect.get(target, property, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value);</span><br><span class="line">      return Reflect.set(target, property, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  return new Proxy(obj, handler);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123; a: 1 &#125;</span><br><span class="line">let value</span><br><span class="line">let p &#x3D; onWatch(obj, (v) &#x3D;&gt; &#123;</span><br><span class="line">  value &#x3D; v</span><br><span class="line">&#125;, (target, property) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;Get &#39;$&#123;property&#125;&#39; &#x3D; $&#123;target[property]&#125;&#96;);</span><br><span class="line">&#125;)</span><br><span class="line">p.a &#x3D; 2 &#x2F;&#x2F; bind &#96;value&#96; to &#96;2&#96;</span><br><span class="line">p.a &#x2F;&#x2F; -&gt; Get &#39;a&#39; &#x3D; 2</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- async 和 await</title>
    <url>/2020/01/03/FE-guide-async-await/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h1><p>一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">async function test() &#123;</span><br><span class="line">  return &quot;1&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test()); &#x2F;&#x2F; -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>可以把 <code>async</code> 看成将函数返回值使用 <code>Promise.resolve()</code> 包裹了下。<br><code>await</code> 只能在 <code>async</code> 函数中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function sleep() &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;finish&#39;)</span><br><span class="line">      resolve(&quot;sleep&quot;);</span><br><span class="line">    &#125;, 2000);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">  let value &#x3D; await sleep();</span><br><span class="line">  console.log(&quot;object&quot;);</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</p>
<p><code>async</code> 和 <code>await</code> 相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码。缺点在于滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性。</p>
<p>下面来看一个使用 <code>await</code> 的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var a &#x3D; 0</span><br><span class="line">var b &#x3D; async () &#x3D;&gt; &#123;</span><br><span class="line">  a &#x3D; a + await 10</span><br><span class="line">  console.log(&#39;2&#39;, a) &#x2F;&#x2F; -&gt; &#39;2&#39; 10</span><br><span class="line">  a &#x3D; (await 10) + a</span><br><span class="line">  console.log(&#39;3&#39;, a) &#x2F;&#x2F; -&gt; &#39;3&#39; 20</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line">console.log(&#39;1&#39;, a) &#x2F;&#x2F; -&gt; &#39;1&#39; 1</span><br></pre></td></tr></table></figure>
<p>对于以上代码你可能会有疑惑，这里说明下原理</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为在 <code>await</code> 内部实现了 <code>generators</code> ， <code>generators</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li>
<li>因为 <code>await</code> 是异步操作，遇到 <code>await</code> 就会立即返回一个 <code>pending</code> 状态的 <code>Promise</code> 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 <code>console.log(&#39;1&#39;, a)</code></li>
<li>这时候同步代码执行完毕，开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 10</code></li>
<li>然后后面就是常规执行代码了</li>
</ul>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- Map、FlatMap 和 Reduce</title>
    <url>/2020/01/03/FE-guide-Map-FlatMap-Reduce/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Map、FlatMap-和-Reduce"><a href="#Map、FlatMap-和-Reduce" class="headerlink" title="Map、FlatMap 和 Reduce"></a>Map、FlatMap 和 Reduce</h1><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h2><p><code>Map</code> 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后 <code>append</code> 到新的数组中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">[1, 2, 3].map((v) &#x3D;&gt; v + 1) &#x2F;&#x2F; -&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure>
<p><code>Map</code> 有三个参数，分别是<strong><em>当前索引元素</em></strong>，<strong><em>索引</em></strong>，<strong><em>原数组</em></strong></p>
<h2 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a><code>FlatMap</code></h2><p><code>FlatMap</code> 和 <code>map</code> 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 <code>FlatMap</code> 看成是 <code>map + flatten</code> ，目前该函数在浏览器中还不支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">[1, [2], 3].flatMap((v) &#x3D;&gt; v + 1) &#x2F;&#x2F; -&gt; [2, 3, 4]</span><br></pre></td></tr></table></figure>
<p>如果想将一个多维数组彻底的降维，可以这样实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const flattenDeep &#x3D; (arr) &#x3D;&gt; Array.isArray(arr)</span><br><span class="line">  ? arr.reduce( (a, b) &#x3D;&gt; [...a, ...flattenDeep(b)] , [])</span><br><span class="line">  : [arr]</span><br><span class="line"></span><br><span class="line">flattenDeep([1, [[2], [3, [4]], 5]])</span><br></pre></td></tr></table></figure>

<h2 id="Reduce-升序执行"><a href="#Reduce-升序执行" class="headerlink" title="Reduce 升序执行"></a>Reduce 升序执行</h2><p><code>Reduce</code> 作用是数组中的值组合起来，最终得到一个值<br><code>reduce()</code> 方法对数组中的每个元素执行一个由您提供的 <code>reducer</code> 函数(升序执行)，将其结果汇总为单个返回值。</p>
<p><code>reducer</code> 函数接收4个参数:</p>
<ul>
<li>Accumulator (acc) (累计器)</li>
<li>Current Value (cur) (当前值)</li>
<li>Current Index (idx) (当前索引)</li>
<li>Source Array (src) (源数组)<br>您的 <code>reducer</code> 函数的返回值分配给累计器，该返回值在数组的每个迭代中被记住，并最后成为最终的单个结果值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    console.log(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[a, b].reduce((a, b) &#x3D;&gt; a(b()))</span><br><span class="line">&#x2F;&#x2F; -&gt; 2 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- Generator 生成器</title>
    <url>/2020/01/03/FE-guide-Generator/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a><code>Generator</code> 实现</h1><p><code>Generator</code> 是 <code>ES6</code> 中新增的语法，和 <code>Promise</code> 一样，都可以用来异步编程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 * 表示这是一个 Generator 函数</span><br><span class="line">&#x2F;&#x2F; 内部可以通过 yield 暂停代码</span><br><span class="line">&#x2F;&#x2F; 通过调用 next 恢复执行</span><br><span class="line">function* test() &#123;</span><br><span class="line">  let a &#x3D; 1 + 2;</span><br><span class="line">  yield 2;</span><br><span class="line">  yield 3;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; test();</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: 2, done: false &#125;</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: 3, done: false &#125;</span><br><span class="line">console.log(b.next()); &#x2F;&#x2F; &gt;  &#123; value: undefined, done: true &#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以发现，加上 <code>*</code> 的函数执行后拥有了 <code>next</code> 函数，也就是说函数执行后返回了一个对象。每次调用 <code>next</code> 函数可以继续执行被暂停的代码。以下是 <code>Generator</code> 函数的简单实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; cb 也就是编译过的 test 函数</span><br><span class="line">function generator(cb) &#123;</span><br><span class="line">  return (function() &#123;</span><br><span class="line">    var object &#x3D; &#123;</span><br><span class="line">      next: 0,</span><br><span class="line">      stop: function() &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      next: function() &#123;</span><br><span class="line">        var ret &#x3D; cb(object);</span><br><span class="line">        if (ret &#x3D;&#x3D;&#x3D; undefined) return &#123; value: undefined, done: true &#125;;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: false</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 如果你使用 babel 编译后可以发现 test 函数变成了这样</span><br><span class="line">function test() &#123;</span><br><span class="line">  var a;</span><br><span class="line">  return generator(function(_context) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">      switch ((_context.prev &#x3D; _context.next)) &#123;</span><br><span class="line">        &#x2F;&#x2F; 可以发现通过 yield 将代码分割成几块</span><br><span class="line">        &#x2F;&#x2F; 每次执行 next 函数就执行一块代码</span><br><span class="line">        &#x2F;&#x2F; 并且表明下次需要执行哪块代码</span><br><span class="line">        case 0:</span><br><span class="line">          a &#x3D; 1 + 2;</span><br><span class="line">          _context.next &#x3D; 4;</span><br><span class="line">          return 2;</span><br><span class="line">        case 4:</span><br><span class="line">          _context.next &#x3D; 6;</span><br><span class="line">          return 3;</span><br><span class="line">		&#x2F;&#x2F; 执行完毕</span><br><span class="line">        case 6:</span><br><span class="line">        case &quot;end&quot;:</span><br><span class="line">          return _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- Promise</title>
    <url>/2020/01/03/FE-guide-Promise/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a><code>Promise</code> 实现</h1><p><code>Promise</code> 是 <code>ES6</code> 新增的语法，解决了回调地狱的问题。</p>
<p>可以把 <code>Promise</code> 看成一个状态机。初始是 <code>pending</code> 状态，可以通过函数 <code>resolve</code> 和 <code>reject</code> ，将状态转变为 <code>resolved</code> 或者 <code>rejected</code> 状态，<strong><em>状态一旦改变就不能再次变化</em></strong>。</p>
<p><code>then</code> 函数会返回一个 <code>Promise</code> 实例，并且该返回值是一个新的实例而不是之前的实例。因为 <code>Promise</code> 规范规定除了 <code>pending</code> 状态，其他状态是不可以改变的，如果返回的是一个相同实例的话，多个 <code>then</code> 调用就失去意义了。</p>
<p>对于 <code>then</code> 来说，本质上可以把它看成是 <code>flatMap</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 三种状态</span><br><span class="line">const PENDING &#x3D; &quot;pending&quot;;</span><br><span class="line">const RESOLVED &#x3D; &quot;resolved&quot;;</span><br><span class="line">const REJECTED &#x3D; &quot;rejected&quot;;</span><br><span class="line">&#x2F;&#x2F; promise 接收一个函数参数，该函数会立即执行</span><br><span class="line">function MyPromise(fn) &#123;</span><br><span class="line">  let _this &#x3D; this;</span><br><span class="line">  _this.currentState &#x3D; PENDING;</span><br><span class="line">  _this.value &#x3D; undefined;</span><br><span class="line">  &#x2F;&#x2F; 用于保存 then 中的回调，只有当 promise</span><br><span class="line">  &#x2F;&#x2F; 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span><br><span class="line">  _this.resolvedCallbacks &#x3D; [];</span><br><span class="line">  _this.rejectedCallbacks &#x3D; [];</span><br><span class="line"></span><br><span class="line">  _this.resolve &#x3D; function (value) &#123;</span><br><span class="line">    if (value instanceof MyPromise) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果 value 是个 Promise，递归执行</span><br><span class="line">      return value.then(_this.resolve, _this.reject)</span><br><span class="line">    &#125;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 异步执行，保证执行顺序</span><br><span class="line">      if (_this.currentState &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        _this.currentState &#x3D; RESOLVED;</span><br><span class="line">        _this.value &#x3D; value;</span><br><span class="line">        _this.resolvedCallbacks.forEach(cb &#x3D;&gt; cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  _this.reject &#x3D; function (reason) &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 异步执行，保证执行顺序</span><br><span class="line">      if (_this.currentState &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">        _this.currentState &#x3D; REJECTED;</span><br><span class="line">        _this.value &#x3D; reason;</span><br><span class="line">        _this.rejectedCallbacks.forEach(cb &#x3D;&gt; cb());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 用于解决以下问题</span><br><span class="line">  &#x2F;&#x2F; new Promise(() &#x3D;&gt; throw Error(&#39;error))</span><br><span class="line">  try &#123;</span><br><span class="line">    fn(_this.resolve, _this.reject);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    _this.reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then &#x3D; function (onResolved, onRejected) &#123;</span><br><span class="line">  var self &#x3D; this;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.2.7，then 必须返回一个新的 promise</span><br><span class="line">  var promise2;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.2.onResolved 和 onRejected 都为可选参数</span><br><span class="line">  &#x2F;&#x2F; 如果类型不是函数需要忽略，同时也实现了透传</span><br><span class="line">  &#x2F;&#x2F; Promise.resolve(4).then().then((value) &#x3D;&gt; console.log(value))</span><br><span class="line">  onResolved &#x3D; typeof onResolved &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onResolved : v &#x3D;&gt; v;</span><br><span class="line">  onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : r &#x3D;&gt; throw r;</span><br><span class="line"></span><br><span class="line">  if (self.currentState &#x3D;&#x3D;&#x3D; RESOLVED) &#123;</span><br><span class="line">    return (promise2 &#x3D; new MyPromise(function (resolve, reject) &#123;</span><br><span class="line">      &#x2F;&#x2F; 规范 2.2.4，保证 onFulfilled，onRjected 异步执行</span><br><span class="line">      &#x2F;&#x2F; 所以用了 setTimeout 包裹下</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x &#x3D; onResolved(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.currentState &#x3D;&#x3D;&#x3D; REJECTED) &#123;</span><br><span class="line">    return (promise2 &#x3D; new MyPromise(function (resolve, reject) &#123;</span><br><span class="line">      setTimeout(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 异步执行onRejected</span><br><span class="line">        try &#123;</span><br><span class="line">          var x &#x3D; onRejected(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (reason) &#123;</span><br><span class="line">          reject(reason);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (self.currentState &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">    return (promise2 &#x3D; new MyPromise(function (resolve, reject) &#123;</span><br><span class="line">      self.resolvedCallbacks.push(function () &#123;</span><br><span class="line">        &#x2F;&#x2F; 考虑到可能会有报错，所以使用 try&#x2F;catch 包裹</span><br><span class="line">        try &#123;</span><br><span class="line">          var x &#x3D; onResolved(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      self.rejectedCallbacks.push(function () &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">          var x &#x3D; onRejected(self.value);</span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125; catch (r) &#123;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 规范 2.3</span><br><span class="line">function resolutionProcedure(promise2, x, resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.3.1，x 不能和 promise2 相同，避免循环引用</span><br><span class="line">  if (promise2 &#x3D;&#x3D;&#x3D; x) &#123;</span><br><span class="line">    return reject(new TypeError(&quot;Error&quot;));</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.3.2</span><br><span class="line">  &#x2F;&#x2F; 如果 x 为 Promise，状态为 pending 需要继续等待否则执行</span><br><span class="line">  if (x instanceof MyPromise) &#123;</span><br><span class="line">    if (x.currentState &#x3D;&#x3D;&#x3D; PENDING) &#123;</span><br><span class="line">      x.then(function (value) &#123;</span><br><span class="line">        &#x2F;&#x2F; 再次调用该函数是为了确认 x resolve 的</span><br><span class="line">        &#x2F;&#x2F; 参数是什么类型，如果是基本类型就再次 resolve</span><br><span class="line">        &#x2F;&#x2F; 把值传给下个 then</span><br><span class="line">        resolutionProcedure(promise2, value, resolve, reject);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      x.then(resolve, reject);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.3.3.3.3</span><br><span class="line">  &#x2F;&#x2F; reject 或者 resolve 其中一个执行过得话，忽略其他的</span><br><span class="line">  let called &#x3D; false;</span><br><span class="line">  &#x2F;&#x2F; 规范 2.3.3，判断 x 是否为对象或者函数</span><br><span class="line">  if (x !&#x3D;&#x3D; null &amp;&amp; (typeof x &#x3D;&#x3D;&#x3D; &quot;object&quot; || typeof x &#x3D;&#x3D;&#x3D; &quot;function&quot;)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 规范 2.3.3.2，如果不能取出 then，就 reject</span><br><span class="line">    try &#123;</span><br><span class="line">      &#x2F;&#x2F; 规范 2.3.3.1</span><br><span class="line">      let then &#x3D; x.then;</span><br><span class="line">      &#x2F;&#x2F; 如果 then 是函数，调用 x.then</span><br><span class="line">      if (typeof then &#x3D;&#x3D;&#x3D; &quot;function&quot;) &#123;</span><br><span class="line">        &#x2F;&#x2F; 规范 2.3.3.3</span><br><span class="line">        then.call(</span><br><span class="line">          x,</span><br><span class="line">          y &#x3D;&gt; &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            &#x2F;&#x2F; 规范 2.3.3.3.1</span><br><span class="line">            resolutionProcedure(promise2, y, resolve, reject);</span><br><span class="line">          &#125;,</span><br><span class="line">          e &#x3D;&gt; &#123;</span><br><span class="line">            if (called) return;</span><br><span class="line">            called &#x3D; true;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; 规范 2.3.3.4</span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (called) return;</span><br><span class="line">      called &#x3D; true;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 规范 2.3.4，x 为基本类型</span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是根据 <code>Promise / A+</code> 规范来实现的代码，可以通过 <code>promises-aplus-tests</code> 的完整测试</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- call, apply, bind 区别</title>
    <url>/2020/01/03/FE-guide-call-apply-bind/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call, apply, bind 区别"></a>call, apply, bind 区别</h1><p>首先说下前两者的异同。<br>相同： <code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。<br>不同：传参的方式不同，除了第一个参数外， <code>call</code> 可以接收一个参数<strong><em>列表</em></strong>， <code>apply</code> 只接受一个参数<strong><em>数组</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">let anObj &#x3D; &#123;</span><br><span class="line">    value: 1</span><br><span class="line">&#125;</span><br><span class="line">function getValue(name, age) &#123;</span><br><span class="line">    console.log(name)</span><br><span class="line">    console.log(age)</span><br><span class="line">    console.log(this.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(anObj, &#39;lixuguang&#39;, &#39;31&#39;)</span><br><span class="line">getValue.apply(anObj, [&#39;lixuguang&#39;, &#39;31&#39;])</span><br></pre></td></tr></table></figure>
<h2 id="模拟实现-call-和-apply"><a href="#模拟实现-call-和-apply" class="headerlink" title="模拟实现 call 和 apply"></a>模拟实现 <code>call</code> 和 <code>apply</code></h2><p>可以从以下几点来考虑如何实现</p>
<ul>
<li>不传入第一个参数，那么默认为 <code>window</code></li>
<li>改变了 <code>this</code> 指向，让新的对象可以执行该函数。那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Function.prototype.myCall &#x3D; function (context) &#123;</span><br><span class="line">  var context &#x3D; context || window &#x2F;&#x2F; 有入参用入参，没有给 window</span><br><span class="line">  context.fn &#x3D; this  &#x2F;&#x2F; 给 context 添加一个属性，getValue.call(anObj, &#39;lixuguang&#39;, &#39;31&#39;) &#x3D;&gt; anObj.fn &#x3D; getValue</span><br><span class="line">  var args &#x3D; [...arguments].slice(1) &#x2F;&#x2F; 将 context 后面的参数取出来</span><br><span class="line">  var result &#x3D; context.fn(...args) &#x2F;&#x2F; getValue.call(anObj, &#39;lixuguang&#39;, &#39;31&#39;) &#x3D;&gt; anObj.fn(&#39;yck&#39;, &#39;24&#39;)</span><br><span class="line">  delete context.fn &#x2F;&#x2F; 删除 fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
以上就是 call 的思路，apply 的实现也类似<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Function.prototype.Apply &#x3D; function (context) &#123;</span><br><span class="line">  var context &#x3D; context || window &#x2F;&#x2F; 有入参用入参，没有给 window</span><br><span class="line">  context.fn &#x3D; this  &#x2F;&#x2F; 给 context 添加一个属性，getValue.call(anObj, &#39;lixuguang&#39;, &#39;31&#39;) &#x3D;&gt; anObj.fn &#x3D; getValue</span><br><span class="line">  var args &#x3D; arguments[1] &#x2F;&#x2F; 将 context 后面的参数取出来</span><br><span class="line">  var result &#x3D; args?context.fn(...args):context.fn() &#x2F;&#x2F; getValue.call(anObj, [&#39;lixuguang&#39;, &#39;31&#39;]) &#x3D;&gt; anObj.fn(&#39;yck&#39;, &#39;24&#39;)</span><br><span class="line">  delete context.fn &#x2F;&#x2F; 删除 fn</span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>bind</code> 和其他两个方法作用也是一致的，只是该方法会返回一个函数。并且我们可以通过 <code>bind</code> 实现柯里化。</li>
</ul>
<p>同样的，也来模拟实现下 <code>bind</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">Function.prototype.myBind &#x3D; function (context) &#123;</span><br><span class="line">  if (typeof this !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">    throw new TypeError(&#39;Error&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">  var _this &#x3D; this</span><br><span class="line">  var args &#x3D; [...arguments].slice(1)</span><br><span class="line">  </span><br><span class="line">  return function F() &#123; &#x2F;&#x2F; 返回一个函数，这是 &#96;bind&#96; 和 &#96;call&#96; ， &#96;apply&#96; 的区别</span><br><span class="line">    if (this instanceof F) &#123; &#x2F;&#x2F; 因为返回了一个函数，我们可以 new F()，所以需要判断</span><br><span class="line">      return new _this(...args, ...arguments)</span><br><span class="line">    &#125;</span><br><span class="line">    return _this.apply(context, args.concat(...arguments))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 继承</title>
    <url>/2020/01/03/FE-guide-inherit/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在 ES5 中，我们可以使用如下方式解决继承的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">function Super() &#123;&#125;</span><br><span class="line">Super.prototype.getNumber &#x3D; function() &#123;</span><br><span class="line">  return 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Sub() &#123;&#125;</span><br><span class="line">let s &#x3D; new Sub()</span><br><span class="line">Sub.prototype &#x3D; Object.create(Super.prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: Sub,</span><br><span class="line">    enumerable: false,</span><br><span class="line">    writable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上继承实现思路就是将子类的原型设置为父类的原型<br>在 <code>ES6</code> 中，我们可以通过 <code>class</code> 语法轻松解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">class MyDate extends Date &#123;</span><br><span class="line">  test() &#123;</span><br><span class="line">    return this.getTime()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let myDate &#x3D; new MyDate()</span><br><span class="line">myDate.test()</span><br></pre></td></tr></table></figure>
<p>但是 <code>ES6</code> 不是所有浏览器都兼容，所以我们需要使用 <code>Babel</code> 来编译这段代码。</p>
<p>如果你使用编译过得代码调用 <code>myDate.test()</code> 你会惊奇地发现出现了报错</p>
<p>因为在 <code>JS</code> 底层有限制，如果不是由 <code>Date</code> 构造出来的实例的话，是不能调用 <code>Date</code> 里的函数的。所以这也侧面的说明了：<strong><em>ES6 中的 class 继承与 ES5 中的一般继承写法是不同的</em></strong>。</p>
<p>既然底层限制了实例必须由 <code>Date</code> 构造出来，那么我们可以改变下思路实现继承</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function MyData() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">MyData.prototype.test &#x3D; function () &#123;</span><br><span class="line">  return this.getTime()</span><br><span class="line">&#125;</span><br><span class="line">let d &#x3D; new Date() &#x2F;&#x2F; 父类实例</span><br><span class="line">Object.setPrototypeOf(d, MyData.prototype)</span><br><span class="line">Object.setPrototypeOf(MyData.prototype, Date.prototype)</span><br></pre></td></tr></table></figure>
<p>以上继承实现思路：先创建父类实例 =&gt; 改变实例原先的 <code>__proto__</code> 转而连接到子类的 <code>prototype</code> =&gt; 子类的 <code>prototype</code> 的 <code>__proto__</code> 改为父类的 <code>prototype</code>。</p>
<p>通过以上方法实现的继承就可以完美解决 JS 底层的这个限制。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 函数防抖和节流</title>
    <url>/2020/01/03/FE-guide-debounce-throttle/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="函数防抖和节流"><a href="#函数防抖和节流" class="headerlink" title="函数防抖和节流"></a>函数防抖和节流</h1><p>在前端开发的过程中，我们经常会需要绑定一些持续触发的事件，如 resize、scroll、mousemove 等等，但有些时候我们并不希望在事件持续触发的过程中那么频繁地去执行函数。</p>
<p>通常这种情况下我们怎么去解决的呢？一般来讲，防抖和节流是比较好的解决方案。</p>
<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>你是否在日常开发中遇到一个问题，在滚动事件中需要做个复杂计算或者实现一个按钮的防二次点击操作。</p>
<p>这些需求都可以通过函数防抖动来实现。尤其是第一个需求，如果在频繁的事件回调中做复杂计算，很有可能导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p>
<p>PS：防抖和节流的作用都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。</p>
<p>我们先来看一个袖珍版的防抖理解一下防抖的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; func是用户传入需要防抖的函数</span><br><span class="line">&#x2F;&#x2F; wait是等待时间</span><br><span class="line">const debounce &#x3D; (func, wait &#x3D; 50) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 缓存一个定时器id</span><br><span class="line">  let timer &#x3D; 0</span><br><span class="line">  &#x2F;&#x2F; 这里返回的函数是每次用户实际调用的防抖函数</span><br><span class="line">  &#x2F;&#x2F; 如果已经设定过定时器了就清空上一次的定时器</span><br><span class="line">  &#x2F;&#x2F; 开始一个新的定时器，延迟执行用户传入的方法</span><br><span class="line">  return function(...args) &#123;</span><br><span class="line">    if (timer) clearTimeout(timer)</span><br><span class="line">    timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      func.apply(this, args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不难看出如果用户调用该函数的间隔小于wait的情况下，上一次的时间还未到就被清除了，并不会执行函数</span><br></pre></td></tr></table></figure>
<p>这是一个简单版的防抖，但是有缺陷，这个防抖只能在最后调用。一般的防抖会有immediate选项，表示是否立即调用。这两者的区别，举个栗子来说：</p>
<ul>
<li>例如在搜索引擎搜索问题的时候，我们当然是希望用户输入完最后一个字才调用查询接口，这个时候适用延迟执行的防抖函数，它总是在一连串（间隔小于wait的）函数触发之后调用。</li>
<li>例如用户给某系统表单点提交的时候，我们希望用户点第一下的时候就去调用接口，这个情况适用立即执行的防抖函数，它总是在第一次调用，并且下一次调用必须与前一次调用的时间间隔大于wait才会触发。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 这个是用来获取当前时间戳的</span><br><span class="line">function now() &#123;</span><br><span class="line">  return +new Date()</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 防抖函数，返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;function&#125; func        回调函数</span><br><span class="line"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;boolean&#125;  immediate   设置为ture时，是否立即调用函数</span><br><span class="line"> * @return &#123;function&#125;             返回客户调用函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">function debounce (func, wait &#x3D; 50, immediate &#x3D; true) &#123;</span><br><span class="line">  let timer, context, args</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 延迟执行函数</span><br><span class="line">  const later &#x3D; () &#x3D;&gt; setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 延迟函数执行完毕，清空缓存的定时器序号</span><br><span class="line">    timer &#x3D; null</span><br><span class="line">    &#x2F;&#x2F; 延迟执行的情况下，函数会在延迟函数中执行</span><br><span class="line">    &#x2F;&#x2F; 使用到之前缓存的参数和上下文</span><br><span class="line">    if (!immediate) &#123;</span><br><span class="line">      func.apply(context, args)</span><br><span class="line">      context &#x3D; args &#x3D; null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, wait)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 这里返回的函数是每次实际调用的函数</span><br><span class="line">  return function(...params) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果没有创建延迟执行函数（later），就创建一个</span><br><span class="line">    if (!timer) &#123;</span><br><span class="line">      timer &#x3D; later()</span><br><span class="line">      &#x2F;&#x2F; 如果是立即执行，调用函数</span><br><span class="line">      &#x2F;&#x2F; 否则缓存参数和调用上下文</span><br><span class="line">      if (immediate) &#123;</span><br><span class="line">        func.apply(this, params)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        context &#x3D; this</span><br><span class="line">        args &#x3D; params</span><br><span class="line">      &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果已有延迟执行函数（later），调用的时候清除原来的并重新设定一个</span><br><span class="line">    &#x2F;&#x2F; 这样做延迟函数会重新计时</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      timer &#x3D; later()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体函数实现的不难，总结一下。</p>
<ul>
<li>对于按钮防点击来说的实现：如果函数是立即执行的，就立即调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中去执行。一旦我开始一个定时器，只要我定时器还在，你每次点击我都重新计时。一旦你点累了，定时器时间到，定时器重置为 null，就可以再次点击了。</li>
<li>对于延时执行函数来说的实现：清除定时器ID，如果是延迟调用就调用函数</li>
</ul>
<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>防抖动和节流本质是不一样的。防抖动是将多次执行变为最后一次执行，节流是将多次执行变成每隔一段时间执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * underscore 节流函数，返回函数连续调用时，func 执行频率限定为 次 &#x2F; wait</span><br><span class="line"> *</span><br><span class="line"> * @param  &#123;function&#125;   func      回调函数</span><br><span class="line"> * @param  &#123;number&#125;     wait      表示时间窗口的间隔</span><br><span class="line"> * @param  &#123;object&#125;     options   如果想忽略开始函数的的调用，传入&#123;leading: false&#125;。</span><br><span class="line"> *                                如果想忽略结尾函数的调用，传入&#123;trailing: false&#125;</span><br><span class="line"> *                                两者不能共存，否则函数不能执行</span><br><span class="line"> * @return &#123;function&#125;             返回客户调用函数</span><br><span class="line"> *&#x2F;</span><br><span class="line">_.throttle &#x3D; function(func, wait, options) &#123;</span><br><span class="line">    var context, args, result;</span><br><span class="line">    var timeout &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; 之前的时间戳</span><br><span class="line">    var previous &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 如果 options 没传则设为空对象</span><br><span class="line">    if (!options) options &#x3D; &#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F; 定时器回调函数</span><br><span class="line">    var later &#x3D; function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果设置了 leading，就将 previous 设为 0</span><br><span class="line">      &#x2F;&#x2F; 用于下面函数的第一个 if 判断</span><br><span class="line">      previous &#x3D; options.leading &#x3D;&#x3D;&#x3D; false ? 0 : _.now();</span><br><span class="line">      &#x2F;&#x2F; 置空一是为了防止内存泄漏，二是为了下面的定时器判断</span><br><span class="line">      timeout &#x3D; null;</span><br><span class="line">      result &#x3D; func.apply(context, args);</span><br><span class="line">      if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">    &#125;;</span><br><span class="line">    return function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 获得当前时间戳</span><br><span class="line">      var now &#x3D; _.now();</span><br><span class="line">      &#x2F;&#x2F; 首次进入前者肯定为 true</span><br><span class="line">	  &#x2F;&#x2F; 如果需要第一次不执行函数</span><br><span class="line">	  &#x2F;&#x2F; 就将上次时间戳设为当前的</span><br><span class="line">      &#x2F;&#x2F; 这样在接下来计算 remaining 的值时会大于0</span><br><span class="line">      if (!previous &amp;&amp; options.leading &#x3D;&#x3D;&#x3D; false) previous &#x3D; now;</span><br><span class="line">      &#x2F;&#x2F; 计算剩余时间</span><br><span class="line">      var remaining &#x3D; wait - (now - previous);</span><br><span class="line">      context &#x3D; this;</span><br><span class="line">      args &#x3D; arguments;</span><br><span class="line">      &#x2F;&#x2F; 如果当前调用已经大于上次调用时间 + wait</span><br><span class="line">      &#x2F;&#x2F; 或者用户手动调了时间</span><br><span class="line"> 	  &#x2F;&#x2F; 如果设置了 trailing，只会进入这个条件</span><br><span class="line">	  &#x2F;&#x2F; 如果没有设置 leading，那么第一次会进入这个条件</span><br><span class="line">	  &#x2F;&#x2F; 还有一点，你可能会觉得开启了定时器那么应该不会进入这个 if 条件了</span><br><span class="line">	  &#x2F;&#x2F; 其实还是会进入的，因为定时器的延时</span><br><span class="line">	  &#x2F;&#x2F; 并不是准确的时间，很可能你设置了2秒</span><br><span class="line">	  &#x2F;&#x2F; 但是他需要2.2秒才触发，这时候就会进入这个条件</span><br><span class="line">      if (remaining &lt;&#x3D; 0 || remaining &gt; wait) &#123;</span><br><span class="line">        &#x2F;&#x2F; 如果存在定时器就清理掉否则会调用二次回调</span><br><span class="line">        if (timeout) &#123;</span><br><span class="line">          clearTimeout(timeout);</span><br><span class="line">          timeout &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">        previous &#x3D; now;</span><br><span class="line">        result &#x3D; func.apply(context, args);</span><br><span class="line">        if (!timeout) context &#x3D; args &#x3D; null;</span><br><span class="line">      &#125; else if (!timeout &amp;&amp; options.trailing !&#x3D;&#x3D; false) &#123;</span><br><span class="line">        &#x2F;&#x2F; 判断是否设置了定时器和 trailing</span><br><span class="line">	    &#x2F;&#x2F; 没有的话就开启一个定时器</span><br><span class="line">        &#x2F;&#x2F; 并且不能不能同时设置 leading 和 trailing</span><br><span class="line">        timeout &#x3D; setTimeout(later, remaining);</span><br><span class="line">      &#125;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 模块化</title>
    <url>/2020/01/03/FE-guide-Module/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>在有 <code>Babel</code> 的情况下，我们可以直接使用 <code>ES6</code> 的模块化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; file a.js</span><br><span class="line">export function a() &#123;&#125;</span><br><span class="line">export function b() &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; file b.js</span><br><span class="line">export default function() &#123;&#125;</span><br><span class="line"></span><br><span class="line">import &#123;a, b&#125; from &#39;.&#x2F;a.js&#39;</span><br><span class="line">import XXX from &#39;.&#x2F;b.js&#39;</span><br></pre></td></tr></table></figure>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><code>CommonJS</code></h2><p><code>CommonJs</code> 是 <code>Node</code> 独有的规范，浏览器中使用就需要用到 <code>Browserify</code> 解析了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">exports.a &#x3D; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; b.js</span><br><span class="line">var module &#x3D; require(&#39;.&#x2F;a.js&#39;)</span><br><span class="line">module.a &#x2F;&#x2F; -&gt; log 1</span><br></pre></td></tr></table></figure>
<p>在上述代码中， <code>module.exports</code> 和 <code>exports</code> 很容易混淆，让我们来看看大致内部实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var module &#x3D; require(&#39;.&#x2F;a.js&#39;)</span><br><span class="line">module.a</span><br><span class="line">&#x2F;&#x2F; 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，</span><br><span class="line">&#x2F;&#x2F; 重要的是 module 这里，module 是 Node 独有的一个变量</span><br><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    a: 1</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 基本实现</span><br><span class="line">var module &#x3D; &#123;</span><br><span class="line">  exports: &#123;&#125; &#x2F;&#x2F; exports 就是个空对象</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这个是为什么 exports 和 module.exports 用法相似的原因</span><br><span class="line">var exports &#x3D; module.exports</span><br><span class="line">var load &#x3D; function (module) &#123;</span><br><span class="line">    &#x2F;&#x2F; 导出的东西</span><br><span class="line">    var a &#x3D; 1</span><br><span class="line">    module.exports &#x3D; a</span><br><span class="line">    return module.exports</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来说说 module.exports 和 exports，用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。</p>
<p>对于 CommonJS 和 ES6 中的模块化的两者区别是：</p>
<ul>
<li>前者支持动态导入，也就是 require(${path}/xx.js)，后者目前不支持，但是已有提案</li>
<li>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li>
<li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li>
<li>后者会编译成 require/exports 来执行的</li>
</ul>
<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>AMD 是由 <code>RequireJS</code> 提出的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; AMD</span><br><span class="line">define([&#39;.&#x2F;a&#39;, &#39;.&#x2F;b&#39;], function(a, b) &#123;</span><br><span class="line">    a.do()</span><br><span class="line">    b.do()</span><br><span class="line">&#125;)</span><br><span class="line">define(function(require, exports, module) &#123;</span><br><span class="line">    var a &#x3D; require(&#39;.&#x2F;a&#39;)</span><br><span class="line">    a.doSomething()</span><br><span class="line">    var b &#x3D; require(&#39;.&#x2F;b&#39;)</span><br><span class="line">    b.doSomething()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 深浅拷贝</title>
    <url>/2020/01/03/FE-guide-copy/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; a</span><br><span class="line">a.age &#x3D; 2</span><br><span class="line">console.log(b.age) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<p>从上述例子中我们可以发现，如果给一个变量赋值一个对象，那么两者的值会是同一个引用，其中一方改变，另一方也会相应改变。</p>
<p>通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。</p>
<h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>首先可以通过 <code>Object.assign</code> 来解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; Object.assign(&#123;&#125;, a)</span><br><span class="line">a.age &#x3D; 2</span><br><span class="line">console.log(b.age) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<p>当然我们也可以通过展开运算符（…）来解决</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    age: 1</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; &#123;...a&#125;</span><br><span class="line">a.age &#x3D; 2</span><br><span class="line">console.log(b.age) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<p>我们还可以用很多简单的方法都能实现浅拷贝：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">arr.slice();</span><br><span class="line">arr.concat();</span><br></pre></td></tr></table></figure>


<p>通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就需要使用到深拷贝了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    age: 1,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: &#39;FE&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; &#123;...a&#125;</span><br><span class="line">a.jobs.first &#x3D; &#39;native&#39;</span><br><span class="line">console.log(b.jobs.first) &#x2F;&#x2F; native</span><br></pre></td></tr></table></figure>
<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到刚开始的话题了，两者享有相同的引用。要解决这个问题，我们需要引入深拷贝。</p>
<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决，这也是最好用最简单的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    age: 1,</span><br><span class="line">    jobs: &#123;</span><br><span class="line">        first: &#39;FE&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(a))</span><br><span class="line">a.jobs.first &#x3D; &#39;native&#39;</span><br><span class="line">console.log(b.jobs.first) &#x2F;&#x2F; FE</span><br></pre></td></tr></table></figure>
<p>但是该方法也是有局限性的：</p>
<ul>
<li>会忽略 undefined</li>
<li>会忽略 symbol</li>
<li>不能序列化函数</li>
<li>不能解决循环引用的对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">  a: 1,</span><br><span class="line">  b: &#123;</span><br><span class="line">    c: 2,</span><br><span class="line">    d: 3,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">obj.c &#x3D; obj.b</span><br><span class="line">obj.e &#x3D; obj.a</span><br><span class="line">obj.b.c &#x3D; obj.c</span><br><span class="line">obj.b.d &#x3D; obj.b</span><br><span class="line">obj.b.e &#x3D; obj.b.c</span><br><span class="line">let newObj &#x3D; JSON.parse(JSON.stringify(obj))</span><br><span class="line">console.log(newObj)</span><br></pre></td></tr></table></figure>
<p>如果你有这么一个循环引用对象，你会发现你不能通过该方法深拷贝<br>在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let a &#x3D; &#123;</span><br><span class="line">    age: undefined,</span><br><span class="line">    sex: Symbol(&#39;fmale&#39;),</span><br><span class="line">    jobs: function() &#123;&#125;,</span><br><span class="line">    name: &#39;lixuguang&#39;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; JSON.parse(JSON.stringify(a))</span><br><span class="line">console.log(b) &#x2F;&#x2F; &#123;name: &quot;lixuang&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>你会发现在上述情况中，该方法会忽略掉函数和 undefined 。</p>
<p>但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。当然如果你的数据中含有以上三种情况下，可以使用 lodash 的深拷贝函数。</p>
<p>如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function structuralClone(obj) &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    const &#123;port1, port2&#125; &#x3D; new MessageChannel();</span><br><span class="line">    port2.onmessage &#x3D; ev &#x3D;&gt; resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;a: 1, b: &#123;</span><br><span class="line">    c: b</span><br><span class="line">&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; 注意该方法是异步的</span><br><span class="line">&#x2F;&#x2F; 可以处理 undefined 和循环引用对象</span><br><span class="line">(async () &#x3D;&gt; &#123;</span><br><span class="line">  const clone &#x3D; await structuralClone(obj)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>深拷贝实现方式2，可以深拷贝 <code>function</code> 、<code>symbol</code>，等等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">const mapTag &#x3D; &#39;[object Map]&#39;;</span><br><span class="line">const setTag &#x3D; &#39;[object Set]&#39;;</span><br><span class="line">const arrayTag &#x3D; &#39;[object Array]&#39;;</span><br><span class="line">const objectTag &#x3D; &#39;[object Object]&#39;;</span><br><span class="line">const argsTag &#x3D; &#39;[object Arguments]&#39;;</span><br><span class="line"></span><br><span class="line">const boolTag &#x3D; &#39;[object Boolean]&#39;;</span><br><span class="line">const dateTag &#x3D; &#39;[object Date]&#39;;</span><br><span class="line">const numberTag &#x3D; &#39;[object Number]&#39;;</span><br><span class="line">const stringTag &#x3D; &#39;[object String]&#39;;</span><br><span class="line">const symbolTag &#x3D; &#39;[object Symbol]&#39;;</span><br><span class="line">const errorTag &#x3D; &#39;[object Error]&#39;;</span><br><span class="line">const regexpTag &#x3D; &#39;[object RegExp]&#39;;</span><br><span class="line">const funcTag &#x3D; &#39;[object Function]&#39;;</span><br><span class="line"></span><br><span class="line">const deepTag &#x3D; [mapTag, setTag, arrayTag, objectTag, argsTag];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function forEach(array, iteratee) &#123;</span><br><span class="line">    let index &#x3D; -1;</span><br><span class="line">    const length &#x3D; array.length;</span><br><span class="line">    while (++index &lt; length) &#123;</span><br><span class="line">        iteratee(array[index], index);</span><br><span class="line">    &#125;</span><br><span class="line">    return array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function isObject(target) &#123;</span><br><span class="line">    const type &#x3D; typeof target;</span><br><span class="line">    return target !&#x3D;&#x3D; null &amp;&amp; (type &#x3D;&#x3D;&#x3D; &#39;object&#39; || type &#x3D;&#x3D;&#x3D; &#39;function&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getType(target) &#123;</span><br><span class="line">    return Object.prototype.toString.call(target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getInit(target) &#123;</span><br><span class="line">    const Ctor &#x3D; target.constructor;</span><br><span class="line">    return new Ctor();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneSymbol(targe) &#123;</span><br><span class="line">    return Object(Symbol.prototype.valueOf.call(targe));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneReg(targe) &#123;</span><br><span class="line">    const reFlags &#x3D; &#x2F;\w*$&#x2F;;</span><br><span class="line">    const result &#x3D; new targe.constructor(targe.source, reFlags.exec(targe));</span><br><span class="line">    result.lastIndex &#x3D; targe.lastIndex;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneFunction(func) &#123;</span><br><span class="line">    const bodyReg &#x3D; &#x2F;(?&lt;&#x3D;&#123;)(.|\n)+(?&#x3D;&#125;)&#x2F;m;</span><br><span class="line">    const paramReg &#x3D; &#x2F;(?&lt;&#x3D;\().+(?&#x3D;\)\s+&#123;)&#x2F;;</span><br><span class="line">    const funcString &#x3D; func.toString();</span><br><span class="line">    if (func.prototype) &#123;</span><br><span class="line">        const param &#x3D; paramReg.exec(funcString);</span><br><span class="line">        const body &#x3D; bodyReg.exec(funcString);</span><br><span class="line">        if (body) &#123;</span><br><span class="line">            if (param) &#123;</span><br><span class="line">                const paramArr &#x3D; param[0].split(&#39;,&#39;);</span><br><span class="line">                return new Function(...paramArr, body[0]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return new Function(body[0]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return eval(funcString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cloneOtherType(targe, type) &#123;</span><br><span class="line">    const Ctor &#x3D; targe.constructor;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">        case boolTag:</span><br><span class="line">        case numberTag:</span><br><span class="line">        case stringTag:</span><br><span class="line">        case errorTag:</span><br><span class="line">        case dateTag:</span><br><span class="line">            return new Ctor(targe);</span><br><span class="line">        case regexpTag:</span><br><span class="line">            return cloneReg(targe);</span><br><span class="line">        case symbolTag:</span><br><span class="line">            return cloneSymbol(targe);</span><br><span class="line">        case funcTag:</span><br><span class="line">            return cloneFunction(targe);</span><br><span class="line">        default:</span><br><span class="line">            return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clone(target, map &#x3D; new WeakMap()) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 克隆原始类型</span><br><span class="line">    if (!isObject(target)) &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 初始化</span><br><span class="line">    const type &#x3D; getType(target);</span><br><span class="line">    let cloneTarget;</span><br><span class="line">    if (deepTag.includes(type)) &#123;</span><br><span class="line">        cloneTarget &#x3D; getInit(target, type);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return cloneOtherType(target, type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 防止循环引用</span><br><span class="line">    if (map.get(target)) &#123;</span><br><span class="line">        return target;</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(target, cloneTarget);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 克隆set</span><br><span class="line">    if (type &#x3D;&#x3D;&#x3D; setTag) &#123;</span><br><span class="line">        target.forEach(value &#x3D;&gt; &#123;</span><br><span class="line">            cloneTarget.add(clone(value));</span><br><span class="line">        &#125;);</span><br><span class="line">        return cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 克隆map</span><br><span class="line">    if (type &#x3D;&#x3D;&#x3D; mapTag) &#123;</span><br><span class="line">        target.forEach((value, key) &#x3D;&gt; &#123;</span><br><span class="line">            cloneTarget.set(key, clone(value));</span><br><span class="line">        &#125;);</span><br><span class="line">        return cloneTarget;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 克隆对象和数组</span><br><span class="line">    const keys &#x3D; type &#x3D;&#x3D;&#x3D; arrayTag ? undefined : Object.keys(target);</span><br><span class="line">    forEach(keys || target, (value, key) &#x3D;&gt; &#123;</span><br><span class="line">        if (keys) &#123;</span><br><span class="line">            key &#x3D; value;</span><br><span class="line">        &#125;</span><br><span class="line">        cloneTarget[key] &#x3D; clone(target[key], map);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return cloneTarget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用方法</span><br><span class="line">clone(target);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 闭包</title>
    <url>/2020/01/02/FE-guide-Closure/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="闭包Closure"><a href="#闭包Closure" class="headerlink" title="闭包Closure"></a>闭包<code>Closure</code></h1><p>闭包的定义很简单：函数 <code>A</code> 返回了一个函数 <code>B</code> ，并且函数 <code>B</code> 中使用了函数 <code>A</code> 的变量，函数 <code>B</code> 就被称为闭包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function A() &#123;</span><br><span class="line">  let a &#x3D; 1</span><br><span class="line">  function B() &#123;</span><br><span class="line">      console.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">  return B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你是否会疑惑，为什么函数 <code>A</code> 已经弹出调用栈了，为什么函数 <code>B</code> 还能引用到函数 <code>A</code> 中的变量。因为函数 <code>A</code> 中的变量这时候是存储在堆上的。现在的 <code>JS</code> 引擎可以通过<strong><em>逃逸分析</em></strong>辨别出哪些变量需要存储在堆上，哪些需要存储在栈上。</p>
<p>经典面试题，循环中使用闭包解决 <code>var</code> 定义函数的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">for ( var i&#x3D;1; i&lt;&#x3D;5; i++) &#123;</span><br><span class="line">	setTimeout( function timer() &#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先因为 <code>setTimeout</code> 是个异步函数，所有会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。</p>
<p>解决办法两种，第一种使用闭包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;</span><br><span class="line">  (function(j) &#123;</span><br><span class="line">    setTimeout(function timer() &#123;</span><br><span class="line">      console.log(j);</span><br><span class="line">    &#125;, j * 1000);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种就是使用 <code>setTimeout</code> 的第三个参数(附加参数，传给 <code>setTimeout</code> 中的函数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">for ( var i&#x3D;1; i&lt;&#x3D;5; i++) &#123;</span><br><span class="line">	setTimeout( function timer(j) &#123;</span><br><span class="line">		console.log( j );</span><br><span class="line">	&#125;, i*1000, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种就是使用 <code>let</code> 定义 <code>i</code> 了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">for ( let i&#x3D;1; i&lt;&#x3D;5; i++) &#123;</span><br><span class="line">	setTimeout( function timer() &#123;</span><br><span class="line">		console.log( i );</span><br><span class="line">	&#125;, i*1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为对于 <code>let</code> 来说，他会创建一个块级作用域，相当于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">&#123; &#x2F;&#x2F; 形成块级作用域</span><br><span class="line">  let i &#x3D; 0</span><br><span class="line">  &#123;</span><br><span class="line">    let ii &#x3D; i</span><br><span class="line">    setTimeout( function timer() &#123;</span><br><span class="line">        console.log( ii );</span><br><span class="line">    &#125;, i*1000 );</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    let ii &#x3D; i</span><br><span class="line">  &#125;</span><br><span class="line">  i++</span><br><span class="line">  &#123;</span><br><span class="line">    let ii &#x3D; i</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 执行上下文</title>
    <url>/2020/01/02/FE-guide-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>当执行 <code>JS</code> 代码时，会产生三种执行上下文</p>
<ul>
<li>全局执行上下文</li>
<li>函数执行上下文</li>
<li><code>eval</code> 执行上下文</li>
</ul>
<p>每个执行上下文中都有三个重要的属性</p>
<ul>
<li>变量对象（ <code>VO</code> ），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li>
<li>作用域链（ <code>JS</code> 采用<strong><em>词法作用域</em></strong>，也就是说变量的作用域是在定义时就决定了）</li>
<li>this<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var a &#x3D; 10</span><br><span class="line">function foo(i) &#123;</span><br><span class="line">  var b &#x3D; 20</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>
对于上述代码，执行栈中有两个上下文：全局上下文和函数 <code>foo</code> 上下文。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">stack &#x3D; [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
对于全局上下文来说， <code>VO</code> 大概是这样的<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">globalContext.VO &#x3D;&#x3D;&#x3D; globe</span><br><span class="line">globalContext.VO &#x3D; &#123;</span><br><span class="line">    a: undefined,</span><br><span class="line">	foo: &lt;Function&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于函数 <code>foo</code> 来说， <code>VO</code> 不能访问，只能访问到活动对象（ <code>AO</code> ）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">fooContext.VO &#x3D;&#x3D;&#x3D; foo.AO</span><br><span class="line">fooContext.AO &#123;</span><br><span class="line">    i: undefined,</span><br><span class="line">	b: undefined,</span><br><span class="line">    arguments: &lt;&gt;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; arguments 是函数独有的对象(箭头函数没有)</span><br><span class="line">&#x2F;&#x2F; 该对象是一个伪数组，有 &#96;length&#96; 属性且可以通过下标访问元素</span><br><span class="line">&#x2F;&#x2F; 该对象中的 &#96;callee&#96; 属性代表函数本身</span><br><span class="line">&#x2F;&#x2F; &#96;caller&#96; 属性代表函数的调用者</span><br></pre></td></tr></table></figure>
对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过 <code>[[Scope]]</code> 属性查找上级变量<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">fooContext.[[Scope]] &#x3D; [</span><br><span class="line">    globalContext.VO</span><br><span class="line">]</span><br><span class="line">fooContext.Scope &#x3D; fooContext.[[Scope]] + fooContext.VO</span><br><span class="line">fooContext.Scope &#x3D; [</span><br><span class="line">    fooContext.VO,</span><br><span class="line">    globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
接下来让我们看一个老生常谈的例子， <code>var</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">b() &#x2F;&#x2F; call b</span><br><span class="line">console.log(a) &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">var a &#x3D; &#39;Hello world&#39;</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&#39;call b&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
想必以上的输出大家肯定都已经明白了，这是因为函数和变量提升的原因。通常提升的解释是说将声明的代码移动到了顶部，这其实没有什么错误，便于大家理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 <code>VO</code> ）， <code>JS</code> 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存入内存中，变量只声明并且赋值为 <code>undefined</code> ，所以在第二个阶段，也就是代码执行阶段，我们可以直接提前使用。</li>
</ul>
<p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">b() &#x2F;&#x2F; call b second</span><br><span class="line"></span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&#39;call b fist&#39;)</span><br><span class="line">&#125;</span><br><span class="line">function b() &#123;</span><br><span class="line">	console.log(&#39;call b second&#39;)</span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; &#39;Hello world&#39;</span><br></pre></td></tr></table></figure>
<p><code>var</code> 会产生很多错误，所以在 <code>ES6</code> 中引入了 <code>let</code> 。 <code>let</code> 不能在声明前使用，但是这并不是常说的 <code>let</code> 不会提升， <code>let</code> 提升了声明但没有赋值，因为临时死区导致了并不能在声明前使用。</p>
<p>对于非匿名的立即执行函数需要注意以下一点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">var foo &#x3D; 1</span><br><span class="line">(function foo() &#123;</span><br><span class="line">    foo &#x3D; 10</span><br><span class="line">    console.log(foo)</span><br><span class="line">&#125;()) &#x2F;&#x2F; -&gt; ƒ foo() &#123; foo &#x3D; 10 ; console.log(foo) &#125;</span><br></pre></td></tr></table></figure>
<p>因为当 <code>JS</code> 解释器在遇到非匿名的立即执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 <code>foo</code> ，但是这个值又是只读的，所以对它的赋值并不生效，所以打印的结果还是这个函数，并且外部的值也没有发生更改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">specialObject &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Scope &#x3D; specialObject + Scope;</span><br><span class="line"></span><br><span class="line">foo &#x3D; new FunctionExpression;</span><br><span class="line">foo.[[Scope]] &#x3D; Scope;</span><br><span class="line">specialObject.foo &#x3D; foo; &#x2F;&#x2F; &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span><br><span class="line"></span><br><span class="line">delete Scope[0]; &#x2F;&#x2F; remove specialObject from the front of scope chain</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- this</title>
    <url>/2020/01/02/FE-guide-this/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h1><p>this 是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function foo() &#123;</span><br><span class="line">	console.log(this.a)</span><br><span class="line">&#125;</span><br><span class="line">var a &#x3D; 1</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">	a: 2,</span><br><span class="line">	foo: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以上两者情况 &#96;this&#96; 只依赖于调用函数前的对象，优先级是第二个情况大于第一个情况</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 以下情况是优先级最高的，&#96;this&#96; 只会绑定在 &#96;c&#96; 上，不会被任何方式修改 &#96;this&#96; 指向</span><br><span class="line">var c &#x3D; new foo()</span><br><span class="line">c.a &#x3D; 3</span><br><span class="line">console.log(c.a)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 还有种就是利用 &#96;call&#96; ， &#96;apply&#96; ， &#96;bind&#96; 改变 &#96;this&#96; ，这个优先级仅次于 &#96;new&#96;</span><br></pre></td></tr></table></figure>
<p>以上几种情况明白了，很多代码中的 <code>this</code> 应该就没什么问题了，下面让我们看看箭头函数中的 <code>this</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">    return () &#x3D;&gt; &#123;</span><br><span class="line">        return () &#x3D;&gt; &#123;</span><br><span class="line">        	console.log(this)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a()()())</span><br></pre></td></tr></table></figure>
<p>箭头函数其实是没有 <code>this</code> 的，这个函数中的 <code>this</code> 只取决于他外面的第一个不是箭头函数的函数的 <code>this</code> 。在这个例子中，因为调用 <code>a</code> 符合前面代码中的第一个情况，所以 <code>this</code> 是 <code>window。并且</code> this 一旦绑定了上下文，就不会被任何代码改变。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- instanceof</title>
    <url>/2020/01/02/FE-guide-instanceof/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h1><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。<br>举例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js代码</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span></span><br></pre></td></tr></table></figure>
<p>判断 <code>Object</code> 的 <code>prototype</code> 是否在 <code>a</code> 的原型链上。</p>
<p>我们也可以试着实现一下 <code>instanceof</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function instanceof(left, right) &#123;</span><br><span class="line">    let prototype &#x3D; right.prototype &#x2F;&#x2F; 获得类型的原型</span><br><span class="line">    left &#x3D; left.__proto__ &#x2F;&#x2F; 获得对象的原型</span><br><span class="line">    while (true) &#123; &#x2F;&#x2F; 判断对象的类型是否等于类型的原型</span><br><span class="line">    	if (left &#x3D;&#x3D;&#x3D; null)</span><br><span class="line">    		return false</span><br><span class="line">    	if (prototype &#x3D;&#x3D;&#x3D; left)</span><br><span class="line">    		return true</span><br><span class="line">    	left &#x3D; left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- new</title>
    <url>/2020/01/02/FE-guide-new/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="new-一个对象的过程"><a href="#new-一个对象的过程" class="headerlink" title="new 一个对象的过程"></a><code>new</code> 一个对象的过程</h1><ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ol>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function create() &#123;</span><br><span class="line">    &#x2F;&#x2F; 创建一个空的对象</span><br><span class="line">    let obj &#x3D; new Object()</span><br><span class="line">    &#x2F;&#x2F; 获得构造函数</span><br><span class="line">    let Con &#x3D; [].shift.call(arguments)</span><br><span class="line">    &#x2F;&#x2F; 链接到原型</span><br><span class="line">    obj.__proto__ &#x3D; Con.prototype</span><br><span class="line">    &#x2F;&#x2F; 绑定 this，执行构造函数</span><br><span class="line">    let result &#x3D; Con.apply(obj, arguments)</span><br><span class="line">    &#x2F;&#x2F; 确保 new 出来的是个对象</span><br><span class="line">    return typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; ? result : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</p>
<p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125; &#x2F;&#x2F; function 就是个语法糖，内部等同于 new Function()</span><br><span class="line">let a &#x3D; &#123; b: 1 &#125; &#x2F;&#x2F; 这个字面量内部也是使用了 new Object()</span><br></pre></td></tr></table></figure>
<p>对于 <code>new</code> 来说，还需要注意下运算符优先级。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function Foo() &#123;</span><br><span class="line">    return this;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;1&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;2&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">new Foo.getName();   &#x2F;&#x2F; -&gt; 1</span><br><span class="line">new Foo().getName(); &#x2F;&#x2F; -&gt; 2</span><br></pre></td></tr></table></figure>

<p>从上图可以看出，<code>new Foo()</code> 的优先级大于 <code>new Foo</code> ，所以对于上述代码来说可以这样划分执行顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">new (Foo.getName());</span><br><span class="line">(new Foo()).getName();</span><br></pre></td></tr></table></figure>

<ul>
<li>对于第一个函数来说，先执行了 <code>Foo.getName()</code> ，所以结果为 1；</li>
<li>对于后者来说，先执行 <code>new Foo()</code> 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。</li>
</ul>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 原型</title>
    <url>/2020/01/02/FE-guide-prototype/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h1><p><img src="https://i.loli.net/2020/01/02/7ov8I4YDiBkjJyr.png" alt="yuanxing.png"><br>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向<code>原型</code>。<br>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的<strong><em>构造函数的原型</em></strong>。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。<br>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了<code>原型链</code>。</p>
<a id="more"></a>

<h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a><code>prototype</code></h1><p>首先来介绍下 <code>prototype</code> 属性。这是一个<code>显式</code>原型属性，只有<code>函数</code>才拥有该属性。基本上所有函数都有这个属性，但是也有一个例外</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">let fun &#x3D; Function.prototype.bind()</span><br></pre></td></tr></table></figure>
<p>如果你以上述方法创建一个函数，那么可以发现这个函数是不具有 prototype 属性的。</p>
<h2 id="prototype-如何产生的"><a href="#prototype-如何产生的" class="headerlink" title="prototype 如何产生的"></a><code>prototype</code> 如何产生的</h2><p>当我们声明一个函数时，这个属性就被自动创建了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>并且这个属性的值是一个对象（也就是<code>原型</code>），只有一个属性 <code>constructor</code><br><code>constructor</code> 对应着构造函数，也就是 <code>Foo</code>。</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><code>constructor</code></h2><p><code>constructor</code> 是一个公有且不可枚举的属性。一旦我们改变了函数的 <code>prototype</code> ，那么新对象就没有这个属性了（当然可以通过原型链取到 <code>constructor</code>）。</p>
<p>那么你肯定也有一个疑问，这个属性到底有什么用呢？其实这个属性可以说是一个历史遗留问题，在大部分情况下是没用的，在我的理解里，我认为他有两个作用：</p>
<ol>
<li>让实例对象知道是什么函数构造了它</li>
<li>如果想给某些类库中的构造函数增加一些自定义的方法，就可以通过 xx.constructor.method 来扩展</li>
</ol>
<h2 id="proto"><a href="#proto" class="headerlink" title="_proto_"></a><code>_proto_</code></h2><p>这是每个对象都有的<code>隐式原型属性</code>，指向了创建该对象的<code>构造函数</code>的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</p>
<p>因为在 JS 中是没有类的概念的，为了实现类似继承的方式，通过 <em>proto</em> 将对象和原型联系起来组成原型链，得以让对象可以访问到不属于自己的属性。</p>
<h3 id="实例对象的-proto-如何产生的"><a href="#实例对象的-proto-如何产生的" class="headerlink" title="实例对象的 _proto_ 如何产生的"></a>实例对象的 <code>_proto_</code> 如何产生的</h3><p>从上图可知，当我们使用 <code>new</code> 操作符时，生成的实例对象拥有了 <code>_proto_</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 这个函数是 Function 的实例对象</span><br><span class="line">&#x2F;&#x2F; function 就是一个语法糖</span><br><span class="line">&#x2F;&#x2F; 内部调用了 new Function(...)</span><br></pre></td></tr></table></figure>
<p>所以可以说，在 <code>new</code> 的过程中，新对象被添加了 <code>_proto_</code> 并且链接到构造函数的原型上。</p>
<h3 id="new-的过程"><a href="#new-的过程" class="headerlink" title="new 的过程"></a><code>new</code> 的过程</h3><ol>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 <code>this</code></li>
<li>返回新对象</li>
</ol>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function create() &#123;</span><br><span class="line">	let obj &#x3D; new Object() &#x2F;&#x2F; 创建一个空的对象</span><br><span class="line">	let Con &#x3D; [].shift.call(arguments) &#x2F;&#x2F; 获得构造函数</span><br><span class="line">	obj.__proto__ &#x3D; Con.prototype	&#x2F;&#x2F; 链接到原型</span><br><span class="line">	let result &#x3D; Con.apply(obj, arguments) &#x2F;&#x2F; 绑定 this，执行构造函数</span><br><span class="line">	return typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; ? result : obj &#x2F;&#x2F; 确保 new 出来的是个对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于实例对象来说，都是通过 <code>new</code> 产生的，无论是 <code>function Foo()</code> 还是 <code>let a = { b : 1 }</code> 。</p>
<p>对于创建一个对象来说，更推荐使用字面量的方式创建对象。因为你使用 new Object() 的方式创建对象需要通过作用域链一层层找到 Object，但是你使用字面量的方式就没这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">function Foo() &#123;&#125; &#x2F;&#x2F; function 就是个语法糖,内部等同于 new Function()</span><br><span class="line">let a &#x3D; &#123; b: 1 &#125; &#x2F;&#x2F; 这个字面量内部也是使用了 new Object()</span><br></pre></td></tr></table></figure>

<h2 id="Function-proto-Function-prototype"><a href="#Function-proto-Function-prototype" class="headerlink" title="Function.proto === Function.prototype"></a>Function.proto === Function.prototype</h2><p>对于对象来说，<code>xx.__proto__.contrcutor</code> 是该对象的构造函数，但是在图中我们可以发现 <code>Function.__proto__</code> === <code>Function.prototype</code>，难道这代表着 <code>Function</code> 自己产生了自己?</p>
<p>答案肯定是否认的，要说明这个问题我们先从 <code>Object</code> 说起。</p>
<p>从图中我们可以发现，所有对象都可以通过原型链最终找到 <code>Object.prototype</code> ，虽然 <code>Object.prototype</code> 也是一个对象，但是这个对象却不是 <code>Object</code> 创造的，而是引擎自己创建了 <code>Object.prototype</code> 。所以可以这样说，所有实例都是对象，但是对象不一定都是实例。</p>
<p>接下来我们来看 <code>Function.prototype</code> 这个特殊的对象，如果你在浏览器将这个对象打印出来，会发现这个对象其实是一个函数。</p>
<p>我们知道函数都是通过 <code>new Function()</code> 生成的，难道 <code>Function.prototype</code> 也是通过 <code>new Function()</code> 产生的吗？答案也是否定的，这个函数也是引擎自己创建的。首先引擎创建了 <code>Object.prototype</code> ，然后创建了 <code>Function.prototype</code> ，并且通过 <code>__proto__</code> 将两者联系了起来。这里也很好的解释了上面的一个问题，为什么 <code>let fun = Function.prototype.bind()</code> 没有 prototype 属性。因为 <code>Function.prototype</code> 是引擎创建出来的对象，引擎认为不需要给这个对象添加 <code>prototype</code> 属性。</p>
<p><strong><em>所以我们又可以得出一个结论，不是所有函数都是 <code>new Function()</code> 产生的。</em></strong><br>有了 <code>Function.prototype</code> 以后才有了 <code>function Function()</code> ，然后其他的构造函数都是 <code>function Function()</code> 生成的。</p>
<p>现在可以来解释 <code>Function.__proto__ === Function.prototype</code> 这个问题了。因为先有的 <code>Function.prototype</code> 以后才有的 <code>function Function()</code> ，所以也就不存在鸡生蛋蛋生鸡的悖论问题了。对于为什么 <code>Function.__proto__</code> 会等于 <code>Function.prototype</code> ，个人的理解是：其他所有的构造函数都可以通过原型链找到 <code>Function.prototype</code> ，并且 <code>function Function()</code> 本质也是一个函数，为了不产生混乱就将 <code>function Function()</code> 的 <code>__proto__</code> 联系到了 <code>Function.prototype</code> 上。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，他们由引擎来创建</li>
<li>除了以上两个特殊对象，其他对象都是通过构造器 <code>new</code> 出来的</li>
<li>函数的 <code>prototype</code> 是一个对象，也就是原型</li>
<li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见知识点整理 ---- 数据类型、类型判断、类型转换、类型比较</title>
    <url>/2020/01/02/FE-guide-dataType/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>温故而知新，可以为师矣。<br>           ———————— 论语</p>
</blockquote>
<p>这篇文章主要是把我看过的书中的知识点，还有其他人整理的面试题进行整理，巩固自己的前端开发理论知识，希望其他看到这篇文章的人也能有所帮助。</p>
<a id="more"></a>

<h1 id="JS知识点"><a href="#JS知识点" class="headerlink" title="JS知识点"></a>JS知识点</h1><blockquote>
<p>当前市场中，如何区分一个好一点的前端开发和一般的前端开发，主要看的就是js能力的差距，好的前端开发，JS玩的转，不仅仅是框架玩的好，还要JS的基础扎实，只有基础与新技术都玩的6的前端开发才是好前端。</p>
</blockquote>
<p>上面这句话不是什么名人或者某位知名前端大拿说的，这是我在公司这几年面试招聘的过程中真真切切总结感受的。<br>所以可以说得JS者得高级前端，所以下面也主要是写JS的相关知识点。</p>
<h2 id="JavaScript内置数据类型-—-数据类型"><a href="#JavaScript内置数据类型-—-数据类型" class="headerlink" title="JavaScript内置数据类型 — 数据类型"></a>JavaScript内置数据类型 — 数据类型</h2><p>无论学什么语言最重要最基础的就是数据类型，《JavaScript权威指南》这本书中详细的介绍了JS中的数据类型，下面总结一下。</p>
<p>JavaScript中数据类型分为两大类共七种内置数据类型，其一是6种<strong><em><code>基本类型</code></em></strong>，其二是1种<strong><em><code>引用类型</code></em></strong>，我发现在面试过程中好多面试者都不会先说有两大类，而是会直接蹦出数字类型、字符串类型。。。对象、数组也会被并排放在一起，这其实不是个掌握知识点的好方法，应该先把数据类型分成上面说的<strong><em><code>基本类型</code></em></strong>、<strong><em><code>引用类型</code></em></strong>这样两个大类之后，再看看这两大类中有什么其他的子类型，在记忆其他子类型之前我觉得应该先了解一下什么是<strong><em><code>基本类型</code></em></strong>和<strong><em><code>引用类型</code></em></strong>，实际上基本类型和引用类型的主要区别是存储的区别，基本类型在栈中，而引用类型的话，引用数据的地址存储在栈中，而对象本身是存储在堆中，引用的数据地址是个16进制的数据值，它就像一把钥匙让你能够找到宝藏在什么地方。这就是基本数据类型和引用类型的区别了。</p>
<p>那么如何记住有哪些基本数据类型和引用数据类型呢，实际上只要记住了6个基本数据类型，其他的都是引用数据类型，而所有的引用数据类型的祖宗都是Object，所以引用数据类型实际上只有Object一个，那么像是Array等其他子类型，都是Object的孩子，不跟Object在一个级别上。</p>
<p>基本数据类型有哪些呢？其实挺好记的，数字，字符串，这两个一个像温柔的文学少女（string），一个像有点精于算计的男生（number），还有一个布尔类型（boolen）他像是班级里正义感爆棚的人，只论对错；另外还有个差生，没头脑似的未定义（Undefined）还有一个失了忆记不起来自己是谁的空（Null），最后还有一个新加入的插班生，总是带着口罩的标志符号（Symbol），这些人构成了这个班级的所有学生，也就是全部的基本类型，那么引用类型的对象Object呢就像及了漂亮爱化妆的班主任老师，有好多副面孔。不知道大家有没有看过一个动漫叫做《黑塔利亚》，他就是把国家都拟人化了，有了各自的性格，我很喜欢看，我觉得这些数据类型也各有各的特点，像这些国家一样，好了脑洞有点挖深了，有人会说我不就是这么几个简单的数据类型嘛，硬记下来不就好了，但是知识总有你硬记不下来的时候，最好的方法也是速记领域最为常用的方法，就是把你不熟悉的知识与你感兴趣的画面或者既往的知识串联起来，这样就能达到很好的记忆，如果你不喜欢动漫（怎么会有不喜欢动漫的人！！！），可以试试用其他的方法记，当然你如果硬要死记硬背那我也没办法，我继续开我的脑洞。<br>如果你是学过Java开发的同学（如果是计算机专业出来的，应该都或多或少学过，非计算机专业的我也不知道说啥了。。），数字在Java中是分成 byte/short/int/long 的，但是在Js中没有那么多，就一个Number，它是浮点类型，基于 IEEE 754标准实现，刚才我不是说了Number是个精于算计的男生，精于算计就是说他分毫不差，这样浮点型就很好的记了下来，这个754的标准可以不记，如果非要记的话，你可以记成他是自称IEEE 754团体的成员。最后Number身后还跟着一个小弟，叫做NaN，他虽然是Number的小弟，但他总是说话不算数，自己说过什么都不承认。所以NaN!=NaN。<br>老师是个爱化妆的老师，而这些学生也不是普通的学生，在学校他们是老老实实的基本类型，放了学之后一打扮，他们就各有了其他的能力，这个过程叫做装箱，具体的后面再说。（好了快回到现实吧你！）</p>
<p>如果基础数据是字面量类型，那么他们就像是在上课的学生，只是学生而已，而当他们调用方法时，他们就成了下课后各种技能都有的新新人类，这个过程有时候是显示的，就像是有些学生喜欢大声嚷嚷，而更多的是你不自觉中就用到了装箱操作，是Js引擎提供的能力，就像是有些闷骚的学生一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">let aNumber &#x3D; 111 &#x2F;&#x2F; 这只是字面量，不是 number 类型</span><br><span class="line">aNumber.toString() &#x2F;&#x2F; 装箱操作自动转化成数字对象，使用时候才会转换为对象类型</span><br></pre></td></tr></table></figure>
<p>对象有个深浅拷贝的知识点必须要会，对象因为是引用数据类型，在栈中存储的是地址，当用另一个变量接收了之前的变量，那么就好像把钥匙复制了一把，两把钥匙开的还是同一个门，而深拷贝呢就像是照着原来的样板间又造了一个一模一样的房间，这两个房间长得一样，但就是两个房间，钥匙自然也是不一样的，所以呢，当往房间里搬家具的时候，浅拷贝搬进去的是一个房间，所以两把钥匙打开之后看到的都是多了家具，而深拷贝的话，我只是往样板间搬了家具，所以照着装修的房间里是不可能有的，这就是浅拷贝原数据会受影响，而深拷贝不会。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">let a &#x3D; &#123; name: &#39;FE&#39; &#125;</span><br><span class="line">let b &#x3D; a</span><br><span class="line">b.name &#x3D; &#39;EF&#39;</span><br><span class="line">console.log(a.name) &#x2F;&#x2F; EF 浅拷贝原数据会受影响</span><br></pre></td></tr></table></figure>
<h2 id="内置数据类型检测-Typeof-—-类型判断"><a href="#内置数据类型检测-Typeof-—-类型判断" class="headerlink" title="内置数据类型检测 Typeof — 类型判断"></a>内置数据类型检测 Typeof — 类型判断</h2><blockquote>
<p>typeof 对于基本类型，除了 null 都可以显示正确的类型</p>
</blockquote>
<p>typeof 就像是学校的教导主任一样，他有着一双火眼金睛，不管是哪个同学，穿了什么样的衣服，他一问就能问出来这个学生是谁，大家都怕他，但是Null因为失忆了，他也不知道教导主任是谁，所以typeof就拿他也没办法，因为他不怕教导主任，教导主任甚至会以为他是老师呢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">typeof 1 &#x2F;&#x2F; &#39;number&#39;</span><br><span class="line">typeof &#39;1&#39; &#x2F;&#x2F; &#39;string&#39;</span><br><span class="line">typeof undefined &#x2F;&#x2F; &#39;undefined&#39;</span><br><span class="line">typeof true &#x2F;&#x2F; &#39;boolean&#39;</span><br><span class="line">typeof Symbol() &#x2F;&#x2F; &#39;symbol&#39;</span><br><span class="line">typeof b &#x2F;&#x2F; b 没有声明，但是还会显示 undefined</span><br><span class="line"></span><br><span class="line">typeof null &#x2F;&#x2F; &#39;object&#39; 这是JS中的bug</span><br></pre></td></tr></table></figure>

<blockquote>
<p>typeof 对于对象，除了函数都会显示 object</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">typeof [] &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof &#123;&#125; &#x2F;&#x2F; &#39;object&#39;</span><br><span class="line">typeof console.log &#x2F;&#x2F; &#39;function&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>知识扩展：为什么会出现这种情况呢？因为在 JS 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p>
</blockquote>
<p><strong><em>如果我们想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(xx)。这样我们就可以获得类似 [object Type] 的字符串。</em></strong></p>
<blockquote>
<p>小知识扩展</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a</span><br><span class="line">&#x2F;&#x2F; 我们也可以这样判断 undefined</span><br><span class="line">a &#x3D;&#x3D;&#x3D; undefined</span><br><span class="line">&#x2F;&#x2F; 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span><br><span class="line">let undefined &#x3D; 1</span><br><span class="line">&#x2F;&#x2F; 这样判断就会出错</span><br><span class="line">&#x2F;&#x2F; 所以可以用下面的方式来判断，并且代码量更少</span><br><span class="line">&#x2F;&#x2F; 因为 void 后面随便跟上一个组成表达式</span><br><span class="line">&#x2F;&#x2F; 返回就是 undefined</span><br><span class="line">a &#x3D;&#x3D;&#x3D; void 0</span><br></pre></td></tr></table></figure>

<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a>转Boolean</h3><p>一句话可以概括</p>
<blockquote>
<p>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>， <code>-0</code>，其他所有值都转为 true，包括所有对象。</p>
</blockquote>
<p>从上面这段话可以看出来，<code>undefined</code>、<code>null</code> 是基本类型之二，而<code>false</code>是布尔类型的假值，<code>NaN</code>是数字类型的无效值，<code>&#39;&#39;</code>是字符串类型的空值，而<code>0</code>， <code>-0</code>都是数字类型的零值，可以看到，除了<code>0</code>、<code>-0</code>有些特殊，除了插班生<code>Symbol</code>，剩下的都是基本类型的假值，由此实际上就很好记了，有时候数字这个容易忘，但是记住“非0既真”这句话就好了。</p>
<h3 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h3><p>对象在转换基本类型时，首先是先会调用ToPrimitive（原始类型），如果有hint参数调用对应的的类型方法，如果没有那默认先会调用 valueOf 然后调用 toString。如果返回了基本类型，结束。如果都没返回，那么Error<strong><em>但是注意这两个方法你是可以重写的。</em></strong></p>
<blockquote>
<p>Symbol.toPrimitive 是一个内置的 Symbol 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数。（来自MDN的解释）<br>需要解释的关键机制是ToPrimitive函数。该函数是将任意值转换为相应的基本类型值。如果输入的就是一个基本类型值，那么将不做修改，被直接返回。如果值是非基本类型值，它将调用内部方法 [[DefaultValue]] 为对象找到一个默认值。<br>[[DefaultValue]]是每一个对象的内部属性。该方法需要一个可选的参数hint，值是Number或String。如果没有提供hint，则默认为Number(除非该对象是Date，在这种情况下默认为String)。然后将调用toString和valueOf去寻找基本类型值。在这里hint就起到作用了。如果hint参数值为Number，valueOf将先被调用，如果hint是String的话，则toString被先调用。<br>[[DefaultValue]] 返回的值一定是基本类型值。如果不是，一个TypeError 将会被抛出。这就意味着为了在这种情况下有意义，toString和valueOf应该返回基本类型值。</p>
</blockquote>
<h3 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h3><blockquote>
<p>只有当<strong><em>加法</em></strong>运算时，其中一方是<strong><em>字符串类型</em></strong>，就会把另一个也转为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。<strong><em>并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。</em></strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line"></span><br><span class="line">1 + &#39;1&#39; &#x2F;&#x2F; &#39;11&#39; 这里会是面试陷阱</span><br><span class="line">2 * &#39;2&#39; &#x2F;&#x2F; 4 </span><br><span class="line">[1, 2] + [2, 1] &#x2F;&#x2F; &#39;1,22,1&#39;</span><br><span class="line">&#x2F;&#x2F; [1, 2].toString() -&gt; &#39;1,2&#39;</span><br><span class="line">&#x2F;&#x2F; [2, 1].toString() -&gt; &#39;2,1&#39;</span><br><span class="line">&#x2F;&#x2F; &#39;1,2&#39; + &#39;2,1&#39; &#x3D; &#39;1,22,1&#39;</span><br></pre></td></tr></table></figure>
<p><strong>*面试陷阱题之 ++ *</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 问表达式 &#39;a&#39; + + &#39;b&#39; 返回结果是什么？</span><br><span class="line">&#x2F;&#x2F; 答案是 &#39;aNaN&#39;</span><br><span class="line">&#39;a&#39; + + &#39;b&#39; -&gt; &#x2F;&#x2F; 一元运算符优先级高</span><br><span class="line">&#39;a&#39; + (+ &#39;b&#39;) -&gt; &#x2F;&#x2F; +&#39;b&#39;转数字类型，非有效结果是NaN</span><br><span class="line">&#39;a&#39; + NaN.toString() -&gt; &#x2F;&#x2F; NaN调用toString（）成字符串&#39;NaN&#39;</span><br><span class="line">&#39;aNaN&#39; &#x2F;&#x2F; 字符串接到一起后&#39;aNaN&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 类似题 &#39;1&#39; + + &#39;4&#39; 返回结果是什么 </span><br><span class="line">&#x2F;&#x2F; 其实就是&#39;4&#39; -&gt; 4 -&gt; &#39;4&#39; 最后还是&#39;14&#39;</span><br></pre></td></tr></table></figure>

<h2 id="操作符-—-类型比较"><a href="#操作符-—-类型比较" class="headerlink" title="== 操作符 — 类型比较"></a>== 操作符 — 类型比较</h2><blockquote>
<p>相等运算符的运算规则如下：<br>1、如果两个值类型相同，进行 === 比较。(这个非常好理解，就不多说了)<br>（1）数字比大小<br>（2）字符串就通过 unicode 字符索引来比较<br>2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：<br>（1）如果一个是null、一个是undefined，那么[相等]。 // 这个有点特殊需要单独记<br>（2）如果任一值是字符串，另一个值是数值，在比较相等性之前先将字符串转换为数值；即是调用Number()函数。<br>（3）如果任一值时布尔值，则在比较相等性之前先将其转换为数值，即是调用Number()函数。<br>（4）如果一个是对象，另一个是数值或字符串，把对象转换成基础类型的值再比较。对象转换成基础类型，利用它的toString或者valueOf方法。 （js核心内置类ToPrimitive，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。）</p>
</blockquote>
<p>1不说，2（1）的话单独记，其他基本类型转数字比较，引用性数据类型调用ToPrimitive转换成基本数据类型</p>
<p>首先还是一道面试题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; [] &#x3D;&#x3D; ![] 结果是什么</span><br><span class="line">[] &#x3D;&#x3D; ![] &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>为什么呢？我们来解析一下，</p>
<ol>
<li>首先我们看一下右侧，<code>![]</code>肯定是要先转换成boolen类型了吧，那么<code>[]</code>的布尔类型是什么呢，上面转换布尔的时候我们说过，除了那五个基本类型的假值以及正负0之外，都是真值，所以<code>[]</code> -&gt; <code>true</code> <code>![]</code> -&gt; <code>false</code></li>
<li><code>ToPrimitive(false)</code>-&gt;<code>0</code>右边的值得出了数值类型的原始值</li>
<li>看左边<code>ToPrimitive([])</code>-&gt;<code>[]</code>.toString()-&gt;<code>&#39;&#39;</code></li>
<li><code>Number(&#39;&#39;)</code>-&gt;<code>0</code></li>
<li>比较左右 <code>0 == 0</code> -&gt; <code>true</code></li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>到这里JS的内置数据类型及类型的转换和比较就讲完了，相信大家看过以后一定会记得住的<br>PS：突然好像学画漫画，《JS数据结构们》，一定大火，哈哈哈😂</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年21天主题挑战之灵感篇-Day 1-写下自己期待中的生平</title>
    <url>/2020/01/02/21-Day-Challenge-01/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>还记得我19年总结最下面的那张照片么，那个同事送的的本子，对，就是下面这张图，这本子叫做《One In A Million》中文叫做极少数手册，是一个管理时间用的管理手册，英文如果直译的话应该是叫做万里挑一，实话说我并不是很自信，虽然我觉得自己还算可以，但远远达不到万里挑一的程度，所以，我打算好好利用这个本子，让自己尽可能成为百里挑一，千里挑一，最后万里挑一的人。</p>
<p>本子里有一个栏目叫做21天主题挑战，21-Day Challenge，每个月21天都会给你列出一些主题，越往后列出来的主题越少，更多的需要个人去补充，我想去挑战这些内容，让自己的生活变得有目标，让自己变得更好。</p>
<a id="more"></a>

<h1 id="1月份21天主题挑战之灵感Inspiration"><a href="#1月份21天主题挑战之灵感Inspiration" class="headerlink" title="1月份21天主题挑战之灵感Inspiration"></a>1月份21天主题挑战之灵感Inspiration</h1><blockquote>
<p>设定一个挑战主题，让自己更富有创造力，连续21天挑战，让灵感乍现，唤醒天赋。</p>
</blockquote>
<h1 id="第一天-Day-1-写下自己期待中的生平"><a href="#第一天-Day-1-写下自己期待中的生平" class="headerlink" title="第一天 Day 1 写下自己期待中的生平"></a>第一天 Day 1 写下自己期待中的生平</h1><p>看到这个题目之后，我闭上了眼睛，努力的回想我自己曾经的梦想是什么，什么时候丢掉了梦想，儿时的梦想，上学时的梦想，长大以后的梦想，现在的梦想，我努力回想了好久好久，儿时的梦想我想起来了，上学时的梦想我想起来了，长大后的梦想我也想起来了，但是我没能一下子找到我现在的梦想，也许现在说梦想有些奢侈，也许也有点贴不上今天的主题期待中的人生，我不太会写文章，但是想到哪里写哪里吧，我先写下我之前的那些个梦想。</p>
<h2 id="小时候的梦想-成为科学家"><a href="#小时候的梦想-成为科学家" class="headerlink" title="小时候的梦想-成为科学家"></a>小时候的梦想-成为科学家</h2><p>小时候的梦想说出来很简单，但是是那么真诚，真诚就容易打动人，说实话我记性不是太好，已经忘掉了小时候的梦想，所以我问了我妈，我妈笑话我，说我咋不记得小时候那伟大的梦想了，妈妈说我儿时的梦想是当科学家，那会应该是上小学吧，妈妈说学校老师让写作文，标题就是我的梦想，我的作文里写的是成为科学家，这个科学家不像是别人写的，比如造火箭，造大炮又或者是造卫星造原子弹，我的梦想现在说起来与其说是科学家，不如说是药剂师更贴切，妈妈笑着跟我说我当时的梦想是做一个科学家，要研究出来一种长生不老的药，然后让爸爸妈妈吃下以后就可以永远健康年轻，妈妈说那个时候她总逗我，看到路上漂亮的阿姨就会问我，那个阿姨漂亮么，起初我会说漂亮，然后妈妈就会说那让她给你当妈妈好不好，我呢会说不好，妈妈说后来她再问的时候，我就再也不会说我要漂亮阿姨当妈妈的话了，我现在想想也许就是那时，就是因为发现妈妈越来越胖，辛苦操劳后年轻也渐渐不在我才有了这个想法吧，说实话上小学期间我一直认为自己长大能够成为一个科学家，能够造出那长生不老的药让爸妈吃下，这样我就再也不会需要一个漂亮阿姨当妈妈了。我那时希望快快长大，长大了以后我就能做科学家了。</p>
<p>上了初中高中以后，也许是进了大城市，也许是长大了，我知道了原来的梦想可能有些遥远，学业的压力让我有些透不过气，从海岛到城市，落后了3年的时间，我通过补习班慢慢追赶，终于能够追到了班级还算靠前的位置，那个时候我的梦想很小，也很简单，那就是考个好大学找个好工作，让爸爸妈妈早点不用那么操劳，早点享福。</p>
<h2 id="18岁的梦想-—-找个好工作，让爸妈早点享福"><a href="#18岁的梦想-—-找个好工作，让爸妈早点享福" class="headerlink" title="18岁的梦想 — 找个好工作，让爸妈早点享福"></a>18岁的梦想 — 找个好工作，让爸妈早点享福</h2><p>努力的学习，懵懂的感情，初中4年+高中3年的生活，最终我并没能特别出色的考上985/211大学，而是上了离家只有1小时车程的大外，学了计算机加日语英语，学费不便宜，每年16000，说实话没自己工作的时候不知道这16000对于一个下岗自己在家开小卖店的父母是多大的负担，工作后我才终于知道这笔钱有多少。好在原来在爸爸单位的时候接触电脑还算比较早，而我对这个新鲜玩意也算是感兴趣，大学学业上并没给我带来太大的压力，但是我也确实不是个聪明的孩子，日语仅仅过了N2，而英语则一直只是CET-4，现在回想起来，原来应该多努努力，也许现在的生活就会更好了，多想回到过去跟自己说，你要努力啊！一晃4年的大学生活就结束了，这时我终于离开了父母身边，只身去往了大城市北京，开启了我的工作生涯。</p>
<h2 id="20岁的人生-—-多挣钱，快速成长"><a href="#20岁的人生-—-多挣钱，快速成长" class="headerlink" title="20岁的人生 — 多挣钱，快速成长"></a>20岁的人生 — 多挣钱，快速成长</h2><p>工作了以后，我就像海绵一样不断的吸收着周围的水分，学习工作中需要的技能，学习如何才能让领导器重，学习如何才能快速积累人生的财富，因为我想着，想着能快快独立反哺我的爸妈。20岁，我跟媳妇儿谈了场异地的恋爱，后来她到北京找我，再后来我们就一起回了大连。北京是个大城市，大的有时候让人迷茫，虽然工作机会比较多，但是租房的压力，环境的恶劣，家里的呼唤，最终让我选择了回到我熟悉的城市，另外找了份工资不高的工作，我不满足，我想能成为顶天立地的男子汉，后来我就来到了现在的公司华宇，而且一待就是5年。</p>
<h2 id="华宇的职业生涯-—-5年工作，9年经验"><a href="#华宇的职业生涯-—-5年工作，9年经验" class="headerlink" title="华宇的职业生涯 — 5年工作，9年经验"></a>华宇的职业生涯 — 5年工作，9年经验</h2><p>网上有个段子我记得，一个人面试拿出简历，工作时间是2年却写着3年工作经验，面试官问他是不是写错了，他答不是，因为加班加出来的。这算是对前公司的吐槽吧。</p>
<p>来到大连华宇时，公司还不足120人，我所在的团队还是个交互组，只有三个人，前端的话只有我和另外一个刚毕业的大学生，记得刚来公司的第一年，我参与了140个项目的开发工作，现在想想这个数字有些惊人，但是因为只是些前端切图仔的工作，对我来说感觉难度并不大，不过还是要感谢刚开始这2年，让我的基础非常扎实，再后来公司引入了前后端分离，引入了Vue框架，越来越多的业务要写，数据处理要写，加班成了家常便饭，后面这三年，我几乎没有休过除了元旦和春节的任何法定节假日，每年5天的年假也几乎都没休成，说实话每次加班加到要崩溃时候，我都会想我到底为了啥这么拼命。要不我还是换一家比较轻松一点的工作吧，工资还能涨点。说实话这段时间工作就是生活的全部，每天到家都10点以后，到家老人孩子都睡了，有时候我都睡不着，想着我的生活难道就这样了么，我不甘心，不服输。很多人劝我别那么拼命，别把公司当成自己家的，只是个打工的而已，但是有时候想着下面还有那么多新人信任着我依赖着我，我就没法撒手不管。终于时间到了19年年底，5年来培养的前端团队最后还是没守护住，要拆到各项目团队了，一开始真的难以接受，不过公司领导层已经决定了，作为一线员工只能服从，我希望大家能够把心中的担忧都能消除掉，在新的团队里开启新的篇章，也许会有更好的发展，如果有一天离开了华宇，也要江湖相望，常聚聚。</p>
<h2 id="2020年31岁踏上新的旅途"><a href="#2020年31岁踏上新的旅途" class="headerlink" title="2020年31岁踏上新的旅途"></a>2020年31岁踏上新的旅途</h2><p>还是感谢小可爱的这个本子，让我能够有主题想想我未来到底想要什么样的生活，说句实在话，我向往不为钱发愁工作的日子，可以在做好自己工作之外的时间里多陪陪家人，带着孩子常出去走走，见见外面的世界，说实话已经31岁了，除了谈恋爱时去找媳妇儿去过江浙苏杭，工作原因去过北京/青海，好像这些年也就去了趟南京，现在的我已经有些不知道什么叫做生活了，我希望自己的空闲时间是可以让兴趣填满的，可以和朋友同事同学多聚聚，但是怕打扰大家我又从来不会主动去约别人，小时候没有听从爸妈的话培养自己的兴趣，现在有些后悔，真的空闲下来都不知道该用什么填满这时间，都是躺在床上刷手机，看电视，我不喜欢这样的生活，但是我不知道该过怎么样的生活。看到那些会做饭的视频，做顿丰盛的饭菜给家人吃，看到他们的幸福笑脸，我想做那样的事；看到带着家人过着一路向前增长见闻的旅途生活，我想也尝试一下那样的人生，我感觉为了钱我被束缚在了工作上，2020年我想过一种不为工作所累，不为钱所累，能够享受生活，陪伴家人的生活，保重身体，每天快快乐乐的，多发现生活中的美好，感恩，努力，成长。期待自己成为更好的人。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>我所期待中的生平，成为一个不被工作强迫，不被金钱所累，爱家顾家，孝敬父母，人缘好朋友多，兴趣广泛，感恩的人。</p>
]]></content>
      <categories>
        <category>个人成长</category>
      </categories>
      <tags>
        <tag>21天挑战</tag>
        <tag>21 Day Challenge</tag>
      </tags>
  </entry>
  <entry>
    <title>你好2020</title>
    <url>/2020/01/01/Hello-2020/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="2020元旦伊始"><a href="#2020元旦伊始" class="headerlink" title="2020元旦伊始"></a>2020元旦伊始</h1><p>时间过的真快，19年睡了一觉就成了过去的一年，今天是元旦，早上8：00起了床，简单洗漱后我出了门，新年新气象，去年没有坚持的晨跑，今年想要坚持一下，所以一早就出门跑了会儿步，太久没活动了，只是跑了半个小时就气喘吁吁，只好回家，但是即使是这半个小时，我感觉呼吸了新鲜的空气，整个人也精神了不少，回到家坐在阳台上，拿出小王宁送我的极少数手册开始研究了起来，生活还是应该有点仪式感何况是新年伊始，手册中有很多建议，全部看过一遍以后我郑重的拿起了笔写下了我今天的行动计划。但是没有写年度计划，明天上班后跟领导还要谈一谈，谈过之后再定一下年度的计划。今天我的计划就是陪家人过好元旦这一天。</p>
<h1 id="元旦执行计划"><a href="#元旦执行计划" class="headerlink" title="元旦执行计划"></a>元旦执行计划</h1><ol>
<li>写一篇日志</li>
<li>将家人这一天游玩的过程以Vlog的形式记录下来，上传到西瓜视频上。</li>
<li>陪家人逛街，给桐桐买新衣裳。</li>
</ol>
<h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><p>吃过早饭后大概到了10:30，一家人收拾好以后终于可以出门了，今天有点风，一点点冷不是特别冷，空气还不错，天气听晴朗的，一家人开着车听着歌前往甘井子万达广场，20分钟左右我们就到了万达广场，首先我们先去看了桐桐心心念念的小猫咪，也就是猫咪咖啡馆里的那些小可爱，桐桐可能是受妈妈影响，很喜欢猫咪，但是又有一点点怕。大概看了10分钟的猫咪，我们继续下一站，上四楼给桐桐买新衣裳，桐桐看到满眼的漂亮衣裳很是兴奋，最终她挑选了一套带着向日葵花朵的淡蓝色衣裙，穿上漂亮的新衣裳，平时像个假小子似的桐桐也一下子害羞了起来，让妈妈和奶奶看完后还会让爸爸和爷爷看看，得到了大家的肯定以后，心满意足的买下了它，也不知道是不是试衣服试累了，桐桐嚷嚷着要吃饭，桐桐妈说有一家港式茶餐厅味道不错，之前和同事来过，于是我们就去了4楼的茶餐厅，说实话这是我头一次吃茶餐厅，我还跟我爸妈调侃说，这也算是我们来过一次香港了。去到餐厅时才11点多一点，客还没有上满，还有座位，我们找了个靠里的位置坐了下来，打开菜谱，桐桐妈挑了几样她觉得不错的菜，上菜时间稍微有点慢，期间桐桐有些不耐烦，坐也坐不住，终于等到了吃的上来，可是觉得大多数吃的都太偏甜，爸妈和我都吃不太惯，桐桐吃的还不错，大概吃了半个小时就吃完了，出门的时候门口已经排起了长队，还好来的早一点，不然吃饭都要等了。本打算带着桐桐回家睡个觉，下午要到姥爷家串门，可桐桐说没有逛够，正巧这时看到了一楼有小丑在折气球玩具，我们就下到一楼找小丑玩了，小丑给桐桐折了个贵宾犬，小丑是荣耀手机的员工，可能是元旦策划的活动吧，反正来了就来了，进去看看也好，看了新出的V30手机，感觉并不是很喜欢，店员说有旧机抵值的活动，我问了他我的7p128g还能值多少，他打了几个电话后回复我1400块，哎，三年前7000块买的手机，现在只值1400了，算了还是用着吧，出了荣耀手机店又去了旁边的华为，看了看新出的mate30pro，这个手机是真的不错，当然手机不错价格也美丽，6500+的价格真的是让我不舍得买，还是把钱留下来给桐桐吧。桐桐终于累了，嚷嚷着要走，于是一家人驱车去了姥姥家。</p>
<p>姥姥家在西南路，因为平时工作忙很少带桐桐去，这次去桐桐又不认识他们了，开始的时候很拘束，也不说话，一直到吃饭结束才终于愿意开口问好唱歌，因为家里没有电视机，到了姥姥家看到电视机很兴奋，一直在看，今天也算是过了瘾了，亲人就是即使很长时间不见面，但一见面就特别亲的人，饭从5：30一直吃到8:30，聊了工作，聊了生活，聊了困惑，聊了坦然，我终于知道了长辈们的智慧，了解了身体健康的重要性，20年一定要锻炼出一副好的身体，对家人负责。</p>
<p>9:30回到了家，心里挺高兴的，新年第一天陪家人一起度过了充实的一天，回到家把今天路上录下来的视频剪成了短视频上传到了西瓜视频，这也是我今年的一个想法，记录我们一家人的幸福生活，如果有粉丝有点播的话还能赚点钱，没有的话也记录了桐桐的成长，算是一点纪念吧。最后写下了这篇日记，写完之后我就要睡觉去了，明天一早就要起床，明天起我就要走路去上班了，为了有一副好身体，加油。</p>
<p>今天的目标都完成了，很开心～～</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>元旦</tag>
      </tags>
  </entry>
  <entry>
    <title>再见2019</title>
    <url>/2019/12/31/GoodBye-2019/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知不觉又是一年，今天是2019年的最后一天，也是我30岁的最后一天，回顾这一年有收获有遗憾。翻出了18年的总结，看到了18年底对于自己19年的规划，现在回过头来看看哪些完成了。</p>
<h1 id="18年底定的计划"><a href="#18年底定的计划" class="headerlink" title="18年底定的计划"></a>18年底定的计划</h1><h2 id="学习技术"><a href="#学习技术" class="headerlink" title="学习技术"></a>学习技术</h2><h3 id="1-深入学习客户端开发（全年）"><a href="#1-深入学习客户端开发（全年）" class="headerlink" title="1. 深入学习客户端开发（全年）"></a>1. 深入学习客户端开发（全年）</h3><p>18年客户端的项目也做了几个，Electron的开发能力经验更多了，之前只是用html+css+js做前端页面的开发，今年又增加了跟vue框架的结合，成功在多个项目中实践，只是一直没有形成规范感觉还是少了一环，原来一直在犹豫Electron到底算不算前端的技术栈之一，后来也算是想明白了，大前端范畴，只要是面向用户的都算是前端该做的范畴，所以Electron当然也算是前端应该掌握的技术栈，20年会继续学习客户端技术，把公司相关规范制定和落地。</p>
<h3 id="2-学习前端自动化测试相关知识（2019年3月前）"><a href="#2-学习前端自动化测试相关知识（2019年3月前）" class="headerlink" title="2. 学习前端自动化测试相关知识（2019年3月前）"></a>2. 学习前端自动化测试相关知识（2019年3月前）</h3><p>18年关注了前端自动化测试相关的知识，本打算19年好好学习一下，在公司项目中实践，但是今年前后端工作量大增，前端人员的精力有限，加之成本的考虑，并没有开展起来，不过这方面的技能储备已经具备了，年底两次关于前端自动化的测试也将前端自动化的思想普及到了公司前端的团队里，20年是公司强调质量的一年，相信20年前端自动化测试将有机会在公司一些项目中落地</p>
<h3 id="3-学习并掌握TS-（2019年5月前）"><a href="#3-学习并掌握TS-（2019年5月前）" class="headerlink" title="3. 学习并掌握TS  （2019年5月前）"></a>3. 学习并掌握TS  （2019年5月前）</h3><p>18年就看到了TS将会成为一门比较活的开发语言，目前来说已经具备了做TS开发的技能，只是TS更适合大型的长期的项目，将更好的保障项目的代码质量，快速迭代和小型项目并不是很适合。前端团队里没有开花，没想到居然在开发团队里见到了曙光，感谢开发的小伙伴愿意接受这门前端新技术，相信有一个点采用后看到了优势，后续普及工作将会更好开展。</p>
<h3 id="4-学习并掌握React（2019年7月前）"><a href="#4-学习并掌握React（2019年7月前）" class="headerlink" title="4. 学习并掌握React（2019年7月前）"></a>4. 学习并掌握React（2019年7月前）</h3><p>18年Vue已经在公司前端全面普及开来，但是市场上React仍然是占据更多的份额，而且RN还能做App开发，所以还是一门必须要掌握的技术，今年看了一本React相关的书，也看了一些相关的视频教程，还参加了公司同事开展的React分享，虽然没有在项目中实际使用过，但是理论知识已经掌握了，可以进行小的Demo开发，20年要用React写一个开源的项目，做到学有所用，学以致用。</p>
<h3 id="5-学习前端持续集成的相关知识（2019年9月前）"><a href="#5-学习前端持续集成的相关知识（2019年9月前）" class="headerlink" title="5. 学习前端持续集成的相关知识（2019年9月前）"></a>5. 学习前端持续集成的相关知识（2019年9月前）</h3><p>19年公司强调了代码必须走线上构建的要求，前端工程化和自动构建持续集成的工作可以说是工作所迫，这方面的技能已经Get到了，另外令我感到高兴的是，通过对Github-Actions的配置，我的博客可以像提交代码一样提交文章了，而且也实践了自动构建的相关技术，很开心。</p>
<h3 id="6-学习Docker虚拟化技术（-2019年10月前）"><a href="#6-学习Docker虚拟化技术（-2019年10月前）" class="headerlink" title="6. 学习Docker虚拟化技术（ 2019年10月前）"></a>6. 学习Docker虚拟化技术（ 2019年10月前）</h3><p>这个任务没有达成，原本是希望能够通过Docker统一前端开发环境，不过Docker的适用场景还是以部署环境为主，Docker今年貌似热度也降下来了，今年K8s越来越火，不管怎样，持续关注新技术。</p>
<h2 id="整理计划"><a href="#整理计划" class="headerlink" title="整理计划"></a>整理计划</h2><h3 id="1-养成写博客的习惯，至少2天一篇，可以是技术博客，也可以是其他。"><a href="#1-养成写博客的习惯，至少2天一篇，可以是技术博客，也可以是其他。" class="headerlink" title="1. 养成写博客的习惯，至少2天一篇，可以是技术博客，也可以是其他。"></a>1. 养成写博客的习惯，至少2天一篇，可以是技术博客，也可以是其他。</h3><p>今年实在是太忙了，别说两天一篇文章，就连一个月一篇的量都没能达成，不过在年底我终于把博客又重新激活了，希望自己20年能够把博客坚持写下来，很简单，积累自己，打造个人品牌。</p>
<h3 id="2-将常用的方法和功能做成插件，开源给公司使用"><a href="#2-将常用的方法和功能做成插件，开源给公司使用" class="headerlink" title="2. 将常用的方法和功能做成插件，开源给公司使用"></a>2. 将常用的方法和功能做成插件，开源给公司使用</h3><p>今年4月开始，更多的精力都投在了部门的前端管理工作，说实话也迷茫也难过，这份迷茫终于在19年年底解开了，没能在技能层面有更高的提升，以及在代码层面给公司带来价值我觉得还是有些遗憾，20年希望自己能够在技术上有更大的进步，技术深度上/广度上/架构层面/后端技能都能有长足的进步。</p>
<h2 id="读书计划"><a href="#读书计划" class="headerlink" title="读书计划"></a>读书计划</h2><h3 id="1-每周读完一本书，并写一篇读后感"><a href="#1-每周读完一本书，并写一篇读后感" class="headerlink" title="1. 每周读完一本书，并写一篇读后感"></a>1. 每周读完一本书，并写一篇读后感</h3><p>2019年读了25本书，每读完一本都会写一篇读后感，虽然没能保证每周读一本书，但是基本保证了每两周读完一本书，算是完成了50%的目标吧。20年继续努力，读书使人聪明，因为不聪明所以更要多读书。</p>
<h2 id="部门前端计划"><a href="#部门前端计划" class="headerlink" title="部门前端计划"></a>部门前端计划</h2><h3 id="加强各设计组前端之间的交流"><a href="#加强各设计组前端之间的交流" class="headerlink" title="加强各设计组前端之间的交流"></a>加强各设计组前端之间的交流</h3><blockquote>
<p>设计组的出现导致前端交流不畅，2019年加强与各设计组前端的交流，掌握各位前端的技术能力。</p>
</blockquote>
<p>没想到一语成第，设计组居然在4月份将前端整个拿出来构成了一个前端组，由我来带，更没想到的是居然在19年年底又解散到项目团队了，这9个月的时间可以说有苦有泪也有甜，前端小伙伴们为了同一个目标，共同努力，尽最大的努力完成公司的业务，可以说为了这个目标，这一年我付出了很多很多，在这方面愧对了家人孩子，虽然最后前端还是拆分了，可以说我能力有限，但是我心里可以说是无愧，希望尽到项目团队里的小伙伴们也能开心工作，迅速成长，虽然不再在一个团队里，但是，我仍是你们的光妈。</p>
<h3 id="前端俱乐部推动"><a href="#前端俱乐部推动" class="headerlink" title="前端俱乐部推动"></a>前端俱乐部推动</h3><blockquote>
<p>继续每周2小时的兴趣交流，交流形式不限于ppt，要求各自建立技术博客做笔记。</p>
</blockquote>
<p>俱乐部的活动最后还是没能坚持下来，大家工作比较忙也好，我自己的原因也好，确实没能坚持下来，20年还是希望能够将俱乐部活动组织起来，算是大家交流的机会也好，帮助大家开阔眼界也好，20年一定要再做起来！</p>
<h3 id="进行梯队划分建设"><a href="#进行梯队划分建设" class="headerlink" title="进行梯队划分建设"></a>进行梯队划分建设</h3><blockquote>
<p>前端今年人数明显增多，但各层级职责并没有区分，19年抽时间进行梯队建设。</p>
</blockquote>
<p>19年前端从14人增加到了34人，可以说人数上翻翻了，随着负责人制的执行，梯队建设的工作算是完成了50%，但是能力提升的工作可以说还是做的不到位，应该有机会成长为高工的小伙伴没能升上去，这我有一定的责任，20年虽然团队不再，但是希望你们都坚持努力学习，迈向更高的台阶。</p>
<h3 id="引入前端工程化工具和思想"><a href="#引入前端工程化工具和思想" class="headerlink" title="引入前端工程化工具和思想"></a>引入前端工程化工具和思想</h3><blockquote>
<p>目前前端工程化已经非常成熟，希望能将成熟的技术和工具引入。</p>
</blockquote>
<p>19年，随着Vue的普及和熟练，模块化开发组件化开发的思想已经深入到每一个前端的心中，现在大家都知道该如何使用这些技术和工具，希望大家能不仅仅局限在用也能了解了解其中原理，至少对常用的配置有所了解。</p>
<h3 id="提升整体前端开发的能力"><a href="#提升整体前端开发的能力" class="headerlink" title="提升整体前端开发的能力"></a>提升整体前端开发的能力</h3><blockquote>
<p>目前整体前端开发能力还相对较弱，19年通过培训等方式提升整体前端开发的能力</p>
</blockquote>
<p>19年能力提升的工作做的太少了，没什么好说的，希望20年这方面工作能够投入更多的精力，让更多的小伙伴成长起来，让我们一起加油吧。</p>
<h2 id="生活目标"><a href="#生活目标" class="headerlink" title="生活目标"></a>生活目标</h2><h3 id="每天陪孩子读书一小时"><a href="#每天陪孩子读书一小时" class="headerlink" title="每天陪孩子读书一小时"></a>每天陪孩子读书一小时</h3><p>跟上面的工作和个人目标比起来，这个任务可以说完成度0%，这也是我觉得愧对家人的地方，为了工作，对家人的关注少了很多很多，以至于桐桐晚上都不愿意跟我一起睡觉，20年我要好好对她，做个好的爸爸，孩子明年就三岁了，去到幼儿园会认识更多的朋友，希望她会跟她的小伙伴说，我有个爱我的爸爸。</p>
<h3 id="减肥"><a href="#减肥" class="headerlink" title="减肥"></a>减肥</h3><p>减肥这件事可以说是真的对我来说太难了，看着自己马上破三位数（kg）的体重，心里无限难过，每次媳妇儿问我啥时候去健身，我都感到像被闪电击中了似的，办了健身卡被人嘲笑成了洗澡卡，20年，减不到150斤我就。。。。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>19年太多的遗憾，太多的后悔莫及，当然也有一些成绩和自我肯定，19年已经过去了，希望在20年，能够成为一个更优秀的人。<br><img src="https://i.loli.net/2019/12/31/jMlO5sPxFyhIkai.jpg" alt="WechatIMG6.jpeg"><br>感谢我可爱的同事，年底收到了礼物真的很开心。</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 GitLab CI/CD 的自动化构建、发布实践</title>
    <url>/2019/12/31/gitlab-cicd/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司于去年开始代码版本管理从SVN迁移到了Git，采用的GitLab程序做管理，但是自动构建采用的是Jekins，最近在给博客做自动构建的时候了解到的了Github的Actions，我就在想，是不是GitLab也有自己的自动构建能力，因为之前在参与项目的时候也看到GitLab上有CI/CD相关的内容，但是没有仔细的去看，趁这次机会就一起研究一下。</p>
<a id="more"></a>

<h2 id="说一下目前公司的构建和发布流程"><a href="#说一下目前公司的构建和发布流程" class="headerlink" title="说一下目前公司的构建和发布流程"></a>说一下目前公司的构建和发布流程</h2><p>1、<strong><em>手动构建时代</em></strong>：开发人员在测试需要验证环境的时候，在本地执行打包构建命令，然后将包放到服务器上，整个过程30分钟左右。<br>2、<strong><em>自动构建时代</em></strong>目前公司的构建是要在Jekins中，首先是在Jekins中配置拉去代码的仓库地址和代码分支，写好构建的脚本，在需要构建时候进行构建，一次配置后构建全程只需要点一下构建时间长度跟项目代码需要下载的依赖时间有关，通常不超过5分钟，需要注意的是要在构建前同步一下代码版本<br><strong><em>划重点</em></strong><br>在原来的手动构建时代，代码是以开发本地的代码为准，代码版本很可能跟最新的代码有出入，而且依赖于开发的电脑设备，如果他请假了，那么就GG了；另外通过一次配置后整个构建的时间从30分钟降到了5分钟，一次节省25分钟，那么一个项目周期下节省的工时就非常可观了。</p>
<h2 id="为什要使用GitLab-CI-CD进行构建"><a href="#为什要使用GitLab-CI-CD进行构建" class="headerlink" title="为什要使用GitLab CI/CD进行构建"></a>为什要使用GitLab CI/CD进行构建</h2><p>这里实际上没有太大的必要将公司的Jekins替换为GitLab的CI/CD进行自动构建，但是呢，因为公司本身采用的就是GitLab作为代码仓库管理代码，它本身又提供了CI/CD的功能，本着多学一点是一点的原则，我就花点时间研究一下它。</p>
<h2 id="什么是-GitLab-CI-CD"><a href="#什么是-GitLab-CI-CD" class="headerlink" title="什么是 GitLab CI/CD"></a>什么是 GitLab CI/CD</h2><p>下面我就要开始把我了解到的GitLab CI/CD的使用方式说一下，从零开始搭建GitLab CI/CD。</p>
<h3 id="1-简要介绍-GitLab-CI-CD"><a href="#1-简要介绍-GitLab-CI-CD" class="headerlink" title="1. 简要介绍 GitLab CI/CD"></a>1. 简要介绍 GitLab CI/CD</h3><p>代码提交到GitLab上后，满足指定条件之后会触发pipeline进行自动化构建、发布。<br><strong><em>pipeline</em></strong>可以理解为构建任务，里面可以包含多个流程，比如下载依赖、运行测试、编译、部署。<br>那么pipeline什么时候触发，分为几个流程，每个流程做什么，需要在项目的<strong><em>.gitlab-ci.yml</em></strong>文件中的定义。<br>这点呢跟Jekins里面实际上做的也是同样的事，在线下开发做构建时候也是做这些事，只是通过脚本之后这些事都可以交给计算机做了。</p>
<h3 id="2-GitLab-CI-CD-整体流程"><a href="#2-GitLab-CI-CD-整体流程" class="headerlink" title="2. GitLab CI/CD 整体流程"></a>2. GitLab CI/CD 整体流程</h3><ul>
<li>GitLab CI/CD 的 pipeline 具体流程和操作在 .gitlab-ci.yml 文件中申明。</li>
<li>触发 pipeline 后，由 GitLab Runner 根据  .gitlab-ci.yml 文件运行。</li>
<li>运行结束后将返回至 GitLab 系统。</li>
</ul>
<h4 id="2-1-gitlab-ci-yml-文件"><a href="#2-1-gitlab-ci-yml-文件" class="headerlink" title="2.1 .gitlab-ci.yml 文件"></a>2.1 .gitlab-ci.yml 文件</h4><p>.gitlab-ci.yml 文件是一个申明式文件，用于定义 GitLab CI/CD 流程分为几个阶段，每个阶段分别干什么。</p>
<p>关于具体干什么、怎么干，主要使用命令行和脚本操作，稍后会在实践部分做细致的介绍。</p>
<p>如果涉及一些逻辑的话，会使用脚本（shell）。</p>
<h4 id="2-2-GitLab-Runner"><a href="#2-2-GitLab-Runner" class="headerlink" title="2.2 GitLab Runner"></a>2.2 GitLab Runner</h4><p>GitLab Runner 是 CI 的执行环境，负责执行 gitlab-ci.yml 文件，并将结果返回给 GitLab 系统。Runner 具体可以有多种形式，docker、虚拟机或 shell，在注册 runner 时选定方式。实际上就是运行脚本的容器环境。</p>
<h2 id="3-从零搭建一个-GitLab-CI-CD-的基本步骤"><a href="#3-从零搭建一个-GitLab-CI-CD-的基本步骤" class="headerlink" title="3. 从零搭建一个 GitLab CI/CD 的基本步骤"></a>3. 从零搭建一个 GitLab CI/CD 的基本步骤</h2><p>上面介绍了一些GitLab构建的主要环节和名词概念，接下来我将给大家介绍一下如何从零搭建一个GitLab CI/CD，一起体验一把GitLab CI/CD的整个流程。</p>
<h3 id="3-1-新建一个-GitLab-项目"><a href="#3-1-新建一个-GitLab-项目" class="headerlink" title="3.1 新建一个 GitLab 项目"></a>3.1 新建一个 GitLab 项目</h3><p>我这用的是公司的自有仓库，各位可以在开源GitLab上创建自己的项目</p>
<h3 id="3-2-配置Runner"><a href="#3-2-配置Runner" class="headerlink" title="3.2 配置Runner"></a>3.2 配置Runner</h3><p>GitLab 提供了一些共享的Runner，我们可以不处理Runner，这里可以理解为，它提供了一些现成的脚本运行环境，不需要我们从头配置运行环境，so sweet～</p>
<h3 id="3-3-新建-gitlab-ci-yml-文件"><a href="#3-3-新建-gitlab-ci-yml-文件" class="headerlink" title="3.3 新建 .gitlab-ci.yml 文件"></a>3.3 新建 .gitlab-ci.yml 文件</h3><ol>
<li>拉取项目到本地</li>
<li>在项目根目录新建 .gitlab-ci.yml 文件</li>
<li>提交 .gitlab-ci.yml 文件</li>
<li>在项目的 CI/CD 中，可以看到 CI/CD 的运行情况<br>这个过程应该没人不会吧，没技术含量的我们简单一提，实际上最重要的就是.gitlab-ci.yml文件中要怎么去写，示例说明文件如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; .gitlab-ci.yml 示例说明</span><br><span class="line"></span><br><span class="line">image: node</span><br><span class="line"># 定义 stages</span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line"># 定义 job</span><br><span class="line"> build 阶段:</span><br><span class="line">  stage: build</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;build stage&quot;</span><br><span class="line"># 定义 job</span><br><span class="line">发布到测试环境:</span><br><span class="line">  stage: test</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;test stage&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="GitLab-CI-CD-实践"><a href="#GitLab-CI-CD-实践" class="headerlink" title="GitLab CI/CD 实践"></a>GitLab CI/CD 实践</h2><p>在实践部分，这里着重介绍 GitLab Runner 和 .gitlab-ci.yml 文件，主要的流程及遇到的问题和解决方案包含在 .gitlab-ci.yml 文件的介绍过程中。</p>
<h3 id="1-GitLab-Runner"><a href="#1-GitLab-Runner" class="headerlink" title="1. GitLab Runner"></a>1. GitLab Runner</h3><p>GitLab Runner 一般由 GitLab 系统维护者管理，配置后，同类项目可以共享，一般不需要进行修改。这里不进行具体介绍，主要介绍下使用过程中的注意点，具体使用可参考 GitLab Runner 文档。（<a href="https://docs.gitlab.com.cn/runner/）" target="_blank" rel="noopener">https://docs.gitlab.com.cn/runner/）</a></p>
<h4 id="1-1-GitLab-Runner-使用流程"><a href="#1-1-GitLab-Runner-使用流程" class="headerlink" title="1.1 GitLab Runner 使用流程"></a>1.1 GitLab Runner 使用流程</h4><ol>
<li>下载 GitLab Runner</li>
<li>注册 GitLab Runner</li>
<li>使用 GitLab Runner</li>
</ol>
<h4 id="1-2-GitLab-Runner-注意点"><a href="#1-2-GitLab-Runner-注意点" class="headerlink" title="1.2 GitLab Runner 注意点"></a>1.2 GitLab Runner 注意点</h4><p>在使用 Runner 的过程中，我们遇到了一些问题，下面简要介绍问题及解决方案，不做具体介绍。</p>
<h5 id="1-2-1-配置-Runner-后，push-代码，出发了-pipeline，但一直处于Pending状态"><a href="#1-2-1-配置-Runner-后，push-代码，出发了-pipeline，但一直处于Pending状态" class="headerlink" title="1.2.1 配置 Runner 后，push 代码，出发了 pipeline，但一直处于Pending状态"></a>1.2.1 配置 Runner 后，push 代码，出发了 pipeline，但一直处于Pending状态</h5><p>错误信息是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">This job is stuck, because you don’t have any active runners that can run this job</span><br></pre></td></tr></table></figure>
<p>注册的 Runner，默认情况下，不会运用没有 <code>tag</code> 的 job，可以在 Settings→CI/CD→Runners Settings，去掉 Runner untagged jobs 即可。</p>
<h5 id="1-2-2-GitLab-Runner-的类型"><a href="#1-2-2-GitLab-Runner-的类型" class="headerlink" title="1.2.2 GitLab Runner 的类型"></a>1.2.2 GitLab Runner 的类型</h5><p>有三种类型的 Runner，</p>
<ul>
<li>Shared Runners 在整个系统所有项目都可以使用</li>
<li>Group Runners 注册后，同一个项目下的不同代码库共享</li>
<li>Specific Runners 需要给项目单独配置，使用 Specific Runners 注意考虑是否需要关闭 Shared Runners、和 Group Runners。</li>
</ul>
<h5 id="1-2-3-在-GitLab-CI-中使用-docker"><a href="#1-2-3-在-GitLab-CI-中使用-docker" class="headerlink" title="1.2.3 在 GitLab CI 中使用 docker"></a>1.2.3 在 GitLab CI 中使用 docker</h5><p>如果部署使用的是docker方式，那么在部署时需要在 GitLab CI/CD 中使用 docker 打镜像发布。可以参考 Building Docker images with GitLab CI/CD（<a href="https://docs.gitlab.com/ee/ci/docker/using_docker_build.html）" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/docker/using_docker_build.html）</a></p>
<h5 id="1-2-4-在-GitLab-CI-CD-中访问-Runner-宿主机目录"><a href="#1-2-4-在-GitLab-CI-CD-中访问-Runner-宿主机目录" class="headerlink" title="1.2.4 在 GitLab CI/CD 中访问 Runner 宿主机目录"></a>1.2.4 在 GitLab CI/CD 中访问 Runner 宿主机目录</h5><p>我们使用的 Runner executor 是 Dokcer，在 Dokcer volumes 中配置需要访问的目录。</p>
<h3 id="2-gitlab-ci-yml-文件"><a href="#2-gitlab-ci-yml-文件" class="headerlink" title="2. .gitlab-ci.yml 文件"></a>2. .gitlab-ci.yml 文件</h3><p>.gitlab-ci.yml 详细的用法，可参考 GitLab CI/CD Pipeline Configuration Reference 文档（<a href="https://docs.gitlab.com/ee/ci/yaml/README.html）" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/yaml/README.html）</a></p>
<h4 id="2-1-gitlab-ci-yml-文件结构介绍"><a href="#2-1-gitlab-ci-yml-文件结构介绍" class="headerlink" title="2.1 .gitlab-ci.yml 文件结构介绍"></a>2.1 .gitlab-ci.yml 文件结构介绍</h4><ul>
<li><code>image</code> 是执行 CI/CD 依赖的 Docker 基础镜像。镜像中有 Node、Yarn、Dalp（内部 rsync 工具）。</li>
<li><code>stages</code> 中定义了我们的 pipeline 分为以下几个过程:<ol>
<li>下载依赖阶段 pre_build</li>
<li>构建阶段 build</li>
<li>发布阶段 deploy</li>
</ol>
</li>
<li><code>stage</code> 申明当前的阶段，在 stages 中使用</li>
<li><code>variables</code> 用于定义变量</li>
<li><code>before_script</code> 执行 script 前的操作</li>
<li><code>script</code> 当前 stage 需要执行的操作</li>
<li><code>changes</code> 指定 stage 触发条件</li>
<li><code>refs</code> 指定 stage 触发的分支</li>
</ul>
<p>下面具体看一下我们这个.gitlab-ci.yml文件实际的样子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image: registry.thunisoft.com&#x2F;gitlab-ci&#x2F;node:v1.8</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">  # $CI_PROJECT_PATH  ：项目id,用于项目唯一区分本项目与其它项目</span><br><span class="line">  # $CI_PROJECT_DIR   ：本地项目路径</span><br><span class="line">  # $PROCESS_PATH     ：临时文件目录(包括日志和一些临时文件)</span><br><span class="line">  NODE_MODULES_PATH: &#x2F;runner-cache&#x2F;frontend&#x2F;$CI_PROJECT_PATH&#x2F;$CI_BUILD_REF_NAME&#x2F;node_modules</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">  - pre_build # 下载依赖阶段</span><br><span class="line">  - build # 构建阶段</span><br><span class="line">  - deploy # 测试发布阶段</span><br><span class="line"></span><br><span class="line"># 下载依赖:</span><br><span class="line">  before_script: # 下载依赖前准备脚本</span><br><span class="line">    # 无 node_modules 文件时，新建 node_modules 文件</span><br><span class="line">    - &#x2F;bin&#x2F;bash .&#x2F;ci&#x2F;mkdir.sh $NODE_MODULES_PATH</span><br><span class="line">    # 软链 node_modules 到宿主机</span><br><span class="line">    - ln -s $NODE_MODULES_PATH .</span><br><span class="line">    - cd webpack@lixuguang-project</span><br><span class="line"></span><br><span class="line">  stage: pre_build</span><br><span class="line">  script:</span><br><span class="line">    - echo &quot;npm install&quot;</span><br><span class="line">    - npm install  --network-timeout 60000 # 安装依赖</span><br><span class="line">  only:</span><br><span class="line">    changes:</span><br><span class="line">      - webpack@lixuguang-project&#x2F;package.json</span><br><span class="line">    refs:</span><br><span class="line">      - master</span><br><span class="line">      - ci</span><br><span class="line"></span><br><span class="line"># 构建:</span><br><span class="line">  stage: build</span><br><span class="line">  variables:</span><br><span class="line">    CI_COMMIT_BEFORE_SHA_PATH: &#x2F;mnt&#x2F;gv0&#x2F;gitlab-runner-cache&#x2F;$CI_PROJECT_PATH</span><br><span class="line">    CI_COMMIT_BEFORE_SHA_FILE_NAME: $CI_BUILD_REF_NAME.sh</span><br><span class="line">    CI_COMMIT_BEFORE_SHA_FILE: &#x2F;mnt&#x2F;gv0&#x2F;gitlab-runner-cache&#x2F;$CI_PROJECT_PATH&#x2F;$CI_BUILD_REF_NAME.sh</span><br><span class="line">  before_script:</span><br><span class="line">    # 建存此次 CI CI_COMMIT_SHA 的文件</span><br><span class="line">    - &#x2F;bin&#x2F;bash .&#x2F;ci&#x2F;mkfile.sh $CI_COMMIT_BEFORE_SHA_PATH $CI_COMMIT_BEFORE_SHA_FILE_NAME</span><br><span class="line">    # 软链 node_modules 到宿主机</span><br><span class="line">    - ln -s $NODE_MODULES_PATH .</span><br><span class="line">    - rm -rf web&#x2F;share&#x2F;*</span><br><span class="line">    - cd webpack@lixuguang-projects</span><br><span class="line">  script:</span><br><span class="line">    # 缓存上次ci</span><br><span class="line">    - source $CI_COMMIT_BEFORE_SHA_FILE</span><br><span class="line">    - echo &quot;CI_COMMIT_BEFORE_SHA&#x3D;$CI_COMMIT_SHA&quot; &gt; $CI_COMMIT_BEFORE_SHA_FILE</span><br><span class="line">    - python3 ..&#x2F;ci&#x2F;build.py   # 编译</span><br><span class="line">    - &#x2F;bin&#x2F;bash ..&#x2F;ci&#x2F;commit.sh   # 提交编译结果</span><br><span class="line">  only:</span><br><span class="line">    changes:</span><br><span class="line">      - www_src&#x2F;**&#x2F;*</span><br><span class="line">    refs:</span><br><span class="line">      - master</span><br><span class="line">      - ci</span><br><span class="line"></span><br><span class="line"># 测试发布:</span><br><span class="line">  stage: deploy</span><br><span class="line">  variables:</span><br><span class="line">    PROCESS_PATH: &#x2F;mnt&#x2F;gv0&#x2F;gitlab-runner-cache&#x2F;deploy&#x2F;process&#x2F;$CI_JOB_ID  # 目录不要换，用于日志服务器获取日志展示</span><br><span class="line">  script:</span><br><span class="line">    - mkdir $PROCESS_PATH # 建立发布临时路径，存放发布配置中间文件和结果日志用</span><br><span class="line">    - dplt $CI_PROJECT_DIR&#x2F;.deploy_test.yml $CI_PROJECT_PATH $CI_PROJECT_DIR&#x2F;web&#x2F; $PROCESS_PATH</span><br><span class="line">    # dplt 发布yml配置</span><br><span class="line">    - echo &quot;发布完成，错误日志查看http:&#x2F;&#x2F;172.18.78.11:8089&#x2F;log?path&#x3D;&quot;$PROCESS_PATH</span><br><span class="line">    - echo &#96;ls $PROCESS_PATH&#x2F;*.log&#96;</span><br><span class="line">  only:</span><br><span class="line">    changes:</span><br><span class="line">      - web&#x2F;**&#x2F;*</span><br><span class="line">    refs:</span><br><span class="line">      - test</span><br></pre></td></tr></table></figure>

<h4 id="2-2-下载依赖阶段（pre-build-stage）"><a href="#2-2-下载依赖阶段（pre-build-stage）" class="headerlink" title="2.2 下载依赖阶段（pre_build stage）"></a>2.2 下载依赖阶段（pre_build stage）</h4><p>下载依赖的方案是：当 package.json 文件发生变化时，触发 pre_build stage，执行 npm install。下载的 node_modules 放在宿主机下，执行时通过软链获取依赖。</p>
<h4 id="2-3-构建阶段（build-stage）"><a href="#2-3-构建阶段（build-stage）" class="headerlink" title="2.3 构建阶段（build stage）"></a>2.3 构建阶段（build stage）</h4><p>构建阶段，分为 3 部分</p>
<ol>
<li>diff 文件变化</li>
<li>前端 build</li>
<li>commit build 后结果</li>
</ol>
<h5 id="2-3-1-diff-文件变化"><a href="#2-3-1-diff-文件变化" class="headerlink" title="2.3.1 diff 文件变化"></a>2.3.1 diff 文件变化</h5><p>每次 CI 时，将当前 CI commit SHA（CI_COMMIT_SHA 变量）存在文件中，存为 CI_COMMIT_BEFORE_SHA 变量， diff 时，git diff 当前 CI 与上次 commit SHA 的变化。</p>
<h5 id="2-3-2-前端-build"><a href="#2-3-2-前端-build" class="headerlink" title="2.3.2 前端 build"></a>2.3.2 前端 build</h5><p>根据 git diff 的变化情况，确定本次需要打包的内容。</p>
<h5 id="2-3-3-commit-打包后生成的-HTML-文件"><a href="#2-3-3-commit-打包后生成的-HTML-文件" class="headerlink" title="2.3.3 commit 打包后生成的 HTML 文件"></a>2.3.3 commit 打包后生成的 HTML 文件</h5><p>在 GitLab CI/CD 提交代码时，使用 Git 凭证存储，提交打包后的 HTML 文件。Git 凭证存储细节可参考凭证存储文档(<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8</a>)</p>
<h4 id="2-4-发布阶段（deploy-stage）"><a href="#2-4-发布阶段（deploy-stage）" class="headerlink" title="2.4 发布阶段（deploy stage）"></a>2.4 发布阶段（deploy stage）</h4><p>发布阶段，使用内部的 rsync 工具 dplt 将打包后的 HTML 文件部署。dplt 可配置集群、机器列表。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>以上就是GitLab CI/CD的整个理论到实践的全部过程，实现之后你就可以解放双手了，是不是超爽。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>持续集成是什么？(<a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html</a>)</p>
<p>什么是 CI/CD？(<a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener">https://www.redhat.com/zh/topics/devops/what-is-ci-cd</a>)</p>
<p>GitLab Docs(<a href="https://docs.gitlab.com/" target="_blank" rel="noopener">https://docs.gitlab.com/</a>)</p>
<p>Introduction to CI/CD with GitLab(<a href="https://docs.gitlab.com/ee/ci/introduction/" target="_blank" rel="noopener">https://docs.gitlab.com/ee/ci/introduction/</a>)</p>
<p>用 GitLab CI 进行持续集成(<a href="https://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/" target="_blank" rel="noopener">https://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/</a>)</p>
<p>如何实现前端工程的持续集成与持续部署？(<a href="https://www.zhihu.com/question/60194439" target="_blank" rel="noopener">https://www.zhihu.com/question/60194439</a>)</p>
<p>基于 GitLab CI 的前端工程CI/CD实践(<a href="https://github.com/giscafer/front-end-manual/issues/27" target="_blank" rel="noopener">https://github.com/giscafer/front-end-manual/issues/27</a>)</p>
]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>CI/CD</tag>
        <tag>自动构建</tag>
      </tags>
  </entry>
  <entry>
    <title>微信的H5兼容方案</title>
    <url>/2019/12/31/weichat-h5-compatibility/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近被公司新来的前端问到了一些微信页面的兼容性问题，因为我做微信开发的经验比较少，被问到了真是感到很尴尬，所以在搜到了解决方案告诉了他之后，我又深入的再网上找了一些微信开发中遇到的兼容问题，特此整理，以留后用。</p>
<a id="more"></a>

<h2 id="1、ios端兼容input光标的高度"><a href="#1、ios端兼容input光标的高度" class="headerlink" title="1、ios端兼容input光标的高度"></a>1、ios端兼容input光标的高度</h2><p><strong><em>bug描述：</em></strong><br>这个问题只出现在苹果手机上，在安卓手机上显示没有问题，可以说是非常诡异，简单描述一下就是在input输入框聚焦时，光标大小应该跟字号一直，但是在苹果手机上当点击输入的时候，光标的高度和父盒子的高度一样。<br><strong><em>分析：</em></strong><br>说来主要是习惯导致的问题，通常我们习惯将height和line-height设置成一样的值，这个时候input光标就会整个变得很大。<br><strong><em>解决：</em></strong><br>实际上解决方案也很简单，就是不设置行高，通过padding来控制输入内容与外框的距离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; less代码</span><br><span class="line">.input-x&#123;</span><br><span class="line">	height:40px;</span><br><span class="line">	&#x2F;&#x2F; line-height:40px; &#x2F;&#x2F; 此行注释掉</span><br><span class="line">	.input-inline&#123;</span><br><span class="line">		padding: 10px 0;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样做问题就解决了。</p>
<h2 id="2、ios端微信h5页面上下滑动会卡顿，页面会有缺失"><a href="#2、ios端微信h5页面上下滑动会卡顿，页面会有缺失" class="headerlink" title="2、ios端微信h5页面上下滑动会卡顿，页面会有缺失"></a>2、ios端微信h5页面上下滑动会卡顿，页面会有缺失</h2><p><strong><em>bug描述：</em></strong><br>没错又是ios端，当页面高度超过一屏，那么上下滑动时就会出现页面卡顿的情况，而且时有伴随内容不能全部显示的情况。<br><strong><em>分析：</em></strong><br>这里实际上是浏览器内核解析不同导致的问题，在Andriod设备上，微信调用的是Webkit内核，而ios中是使用了Safari的内核，Safari对于滚动事件（overflow-scrolling）会使用原生的控件。而webkit内核则会创建一个UIScrollView来提供给子layer用以渲染。<br><strong><em>解决：</em></strong><br>在做样式重置时，加上下面这句话就能解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css代码</span><br><span class="line">*&#123;</span><br><span class="line">	-webkit-overflow-scrolling: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个方案也有缺陷，就是页面中不能有使用absolute定位的元素，不然布局就错乱了。<br><strong><em>延伸：</em></strong><br>-webkit-overflow-scrolling 属性控制元素在移动设备上是否使用滚动回弹效果.</p>
<ul>
<li>auto: 使用普通滚动, 当手指从触摸屏上移开，滚动会立即停止。</li>
<li>touch: 使用具有回弹效果的滚动, 当手指从触摸屏上移开，内容会继续保持一段时间的滚动效果。继续滚动的速度和持续的时间和滚动手势的强烈程度成正比。同时也会创建一个新的堆栈上下文。</li>
</ul>
<h2 id="3、ios键盘唤起再收起，页面不会恢复原位"><a href="#3、ios键盘唤起再收起，页面不会恢复原位" class="headerlink" title="3、ios键盘唤起再收起，页面不会恢复原位"></a>3、ios键盘唤起再收起，页面不会恢复原位</h2><p><strong><em>bug描述：</em></strong><br>哎，对的还是ios，问题标题描述的比较清晰了，就是键盘弹出时，页面内容会整体上移，但是收起键盘时本应回归原位的不回去了。—_—|||<br><strong><em>分析：</em></strong><br>固定定位的元素，如果元素内input框聚焦的时候会弹出软键盘，软键盘会占用屏幕面积，失去焦点时软键盘消失，但是仍会占用，页面就会不能恢复原状，也就导致input框不能再次输入了。<br><strong><em>解决：</em></strong><br>在input失去焦点键盘收起时，写一个监听事件，事例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue代码</span><br><span class="line">&lt;input @blur&#x3D;&quot;changeBlur()&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">changeBlur()&#123;</span><br><span class="line">	let ua &#x3D; navigator.userAgent; &#x2F;&#x2F; 获取用户代理</span><br><span class="line">	let app &#x3D; navigator.appVersion; &#x2F;&#x2F; 获取客户端版本信息</span><br><span class="line">	let isIos &#x3D; ua.match(&#x2F;i[^;]+;( U;)? CPU.+Mac OS X&#x2F;); &#x2F;&#x2F; 判断是否是Ios设备</span><br><span class="line">	if(isIos)&#123;</span><br><span class="line">		setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">			const scrollHeight &#x3D; document.documentElement.scrollTop || document.body.scrollTop || 0</span><br><span class="line">			window.scrollTop(0,Math.max(scrollHeight - 1), 0)</span><br><span class="line">		&#125;,100)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>延伸：</em></strong><br>在iso的微信开发中，页面元素如果用到了position: fixed进行定位，那么键盘收起时，就会被顶上去，第三方输入法也不例外。</p>
<h2 id="4、Android弹出键盘遮挡文本输入框"><a href="#4、Android弹出键盘遮挡文本输入框" class="headerlink" title="4、Android弹出键盘遮挡文本输入框"></a>4、Android弹出键盘遮挡文本输入框</h2><p><strong><em>bug描述：</em></strong><br>刚才说的问题都是Ios端的，实际上Android上也有挺多坑，上面讲到Ios上输入框弹出键盘的问题后，Android中实际也有，只是现象不同；Andriod中弹出键盘后页面不会向上滑动，但是如果输入框在底部的话会直接被挡住。。。<br><strong><em>分析：</em></strong><br>很坑，因为Andriod中输入框focus后，并不会向上滑动，如果靠下就会被挡住。。<br><strong><em>解决：</em></strong><br>实际上跟Ios上处理差不多的方案，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; vue代码</span><br><span class="line">&lt;input @blur&#x3D;&quot;changeBlur()&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">changeFocus()&#123;</span><br><span class="line">   let ua &#x3D; navigator.userAgent;</span><br><span class="line">	 let app &#x3D; navigator.appVersion;</span><br><span class="line">   let isAndroid &#x3D; u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1;</span><br><span class="line">   if(isAndroid)&#123;</span><br><span class="line">      setTimeout(function() &#123;</span><br><span class="line">      document.activeElement.scrollIntoViewIfNeeded();</span><br><span class="line">      document.activeElement.scrollIntoView();</span><br><span class="line">      &#125;, 500);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>扩展</em></strong><br>Element.scrollIntoView()方法让当前的元素滚动到浏览器窗口的可视区域内。而Element.scrollIntoViewIfNeeded()方法也是用来将不在浏览器窗口的可见区域内的元素滚动到浏览器窗口的可见区域。但如果该元素已经在浏览器窗口的可见区域内，则不会发生滚动</p>
<h2 id="5、Vue中路由使用hash模式，分享时Android可分享成功，Ios端分享失败"><a href="#5、Vue中路由使用hash模式，分享时Android可分享成功，Ios端分享失败" class="headerlink" title="5、Vue中路由使用hash模式，分享时Android可分享成功，Ios端分享失败"></a>5、Vue中路由使用hash模式，分享时Android可分享成功，Ios端分享失败</h2><p><strong><em>bug描述：</em></strong><br>Ios的问题真的挺多的。。。</p>
<ul>
<li>在分享页面给A时，没问题，A把链接分享给B的时候就跳转到首页了；</li>
<li>使用Vue-router跳转到第二个页面在分享时候，分享失败；<br>以上两个问题在Android上均没有问题。</li>
</ul>
<p><strong><em>分析：</em></strong><br>jssdk是后端进行签署，前端校验，但是有时跨域，ios是分享以后会自动带上 from=singlemessage&amp;isappinstalled=0 以及其他参数，分享朋友圈参数还不一样，貌似系统不一样参数也不一样，但是每次获取url并不能获取后面这些参数<br><strong><em>解决：</em></strong></p>
<ul>
<li>可以使用改页面this.$router.push跳转，为window.location.href去跳转，而不使用路由跳转，这样可以使地址栏的地址与当前页的地址一样，可以分享成功</li>
<li>把入口地址保存在本地，等需要获取签名的时候再取出来，注意：sessionStorage.setItem(‘href’,href); 只在刚进入单应用的时候保存！（还没测试，有点low）</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>虽然微信H5方式开发想对来说成本比较低，但是有时候坑开始挺多的，但是微信原生开发又增加了成本，很矛盾，目前能做的就是尽量把踩过的坑都记下来，下次别再跳进去了。</p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>兼容</tag>
      </tags>
  </entry>
  <entry>
    <title>重拾java开发技能</title>
    <url>/2019/12/30/begin-learn-java/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近愈发觉得越想往上走，越不能局限在前端开发的领域，再往上走前后端都是通的，最近在知乎上看到一句话，说是到了架构师甚至专家的层面以后，就没有什么前端架构师或者前端专家和后端架构师、后端专家了，只有前端出身的技术专家，和后端出身的技术专家，越往上越注重人的综合能力，当一个人能够解决一个项目的技术选型、架构等工作后，对于公司或者团队来说，那就是个巨大的宝藏。</p>
<a id="more"></a>

<h2 id="公司这一年"><a href="#公司这一年" class="headerlink" title="公司这一年"></a>公司这一年</h2><p>最近对于自己的发展有一些迷茫，这一年公司前端的发展可以说是几经转折，我自己呢也一直在摇摆到底是做管理还是做技术，也参加了公司组织的部门经理的答辩，在部门前端的管理工作中也切实的了解到自己在为人处事方面不够圆润。所以目前也算是断了从事管理的念头，更希望能在技术上更进一步，前端目前看来已经不算是我的短板，而我的短板就是只会前端，一直在前端周围打转，其实如果不是看了那篇帖子，以及公司对专家岗位的要求，我可能还会更进一步在前端方向深入研究，但目前看更紧急的应该是补充一下后端的开发知识了，于是上周末开始我就开始了java的学习</p>
<h2 id="为什么选择java"><a href="#为什么选择java" class="headerlink" title="为什么选择java"></a>为什么选择java</h2><p>为什么选择java作为后端入门，实话讲好多前端开发应该都会问这个问题，明明有更熟悉的nodejs可以作为后端技能进行扩展，我这里的理由是目前大多数公司的包括外面公司的开发人员大都还是以java作为主要语言作为后端编写的选择，另外前端js中好多的设计也是借鉴或者照搬了java中的一些思想，可以说在学习java过程中也会自然而然的提高对js的理解，更重要的是，java相对于其他语言来说资料也更多，上手也更容易，因为这些因素吧，最终我选择了java作为后端的主要学习目标。</p>
<h2 id="怎么学习java"><a href="#怎么学习java" class="headerlink" title="怎么学习java"></a>怎么学习java</h2><p>java上大学的时候实际有系统的学过的，只是实习之后就再也没有使用过，如今9年过去了，java对于我可能也只剩下些零星的记忆，说实话刚一开始怎么学，从哪里学让我都有点无从下手，这里还要感谢一下我后端的开发伙伴，给了我很多很好的建议，看书的话大都是基础的太基础，实战的又经常忽略基础，最终我打算还是以视频教程2.5倍速快速过一遍java基础，然后再深入学习一下springboot框架，最后再进行实战，以此掌握java开发技能。</p>
<h3 id="开始学习java"><a href="#开始学习java" class="headerlink" title="开始学习java"></a>开始学习java</h3><p>最终我选择了在B站上看黑马的java基础+实战课程的教学视频，说实话黑马的教学视频还是讲的很仔细的，老师讲的也很有趣，只是一节课10多分钟，只有一个知识点，对于我来说还是有些慢，所以我就开了2.5倍速加快进就这么着看，上周末两天时间，看了130多课，今天的内容记忆不太深刻，趁着不是那么忙又看了30多课，感觉收获还是满满的，接下来的每一天都会看上30课左右，希望自己能在3个月的时间完全上手java开发，相信我可以做到。</p>
<h2 id="立个Flag"><a href="#立个Flag" class="headerlink" title="立个Flag"></a>立个Flag</h2><p>从今天起，每天都要把自己学习的进度做个总结，看看这一天自己收获了多少，希望30岁这年我重新起步，迈向更高更好的未来。</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>巧妙利用Acitons进行博客的自动构建</title>
    <url>/2019/12/27/Actions/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>忙活了很久很久，终于不那么忙了，也终于想起来我还有个博客没有运行，哎，虽然用Hexo可以享受Github提供的免费的空间和域名，但是命令行敲代码的方式实现博客编写还是有些不方便，尤其是需要编程环境的时候，最近公司在用CICD的方式对代码进行构建，我就在想有没有一种方式让博客也可以变成这样，于是我就在网上搜<code>Github</code> <code>Hexo</code> <code>自动构建</code> 这些个词，还真让我搜到了一种方法而且还是Github自己提供的，下面隆重请出 <code>GitHub Actions</code>。</p>
<a id="more"></a>

<h2 id="GitHub-Actions-是什么"><a href="#GitHub-Actions-是什么" class="headerlink" title="GitHub Actions 是什么"></a>GitHub Actions 是什么</h2><p>GitHub Actions 由 GitHub 官方推出的工作流工具。典型的应用场景应该是 CI/CD，类似 Travis 的用法。如果不知道 CI/CD&amp;Travis 感兴趣的建议去了解一下，下面不展开说明，直接说怎么用就好。</p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>在使用 <code>GitHub Actions</code> 之前我们先来看看我们有什么；<br>首先我们有一个放博客程序的地方，我这里是叫做 <code>blog-source</code> ，另外呢有一个通过 hexo g 创建出来的静态网站，为了存放它而建的另一个仓库，我这里是叫做<code>lixuguang.github.io</code>,也就是说我们现在是有这样两个仓库。<br>|仓库|作用|<br>|-|-|<br>|blog-source|放博客源代码|<br>|lixuguang.github.io|放博客生成代码|</p>
<h2 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h2><p>因为 <code>GitHub Actions</code> 它需要访问我的 <code>blog-source</code> 仓库的代码所以必须要有密钥，密钥大家应该熟悉了，创建博客的时候也是创建了一个公钥和私钥用来在本地往 <code>lixuguang.github.io</code> 这个仓库提交代码<br>这里呢我们用下面的命令生成密钥。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -f ~&#x2F;.ssh&#x2F;github-actions-deploy # 连按三次回车即刻</span><br></pre></td></tr></table></figure>
<p>命令执行完成后，我们会得到两个文件 <code>github-actions-deploy</code> 和 <code>github-actions-deploy.pub</code> 两个文件，第一个是私钥，第二个是公钥。<br>|名称|解释|<br>|-|-|<br>|github-actions-deploy|私钥|<br>|github-actions-deploy.pub|公钥|</p>
<p>接下来的步骤一定要好好看，因为我在这个地方被卡住好多次，就是因为有的文章说的并不正确，或者至少是讲的不够仔细，这里我会仔细地说明一下。</p>
<h2 id="配置-GitHub-仓库"><a href="#配置-GitHub-仓库" class="headerlink" title="配置 GitHub 仓库"></a>配置 GitHub 仓库</h2><h3 id="配置博客源代码仓库"><a href="#配置博客源代码仓库" class="headerlink" title="配置博客源代码仓库"></a>配置博客源代码仓库</h3><p>我这里的源代码是放在 <code>blog-source</code> 中，所以我现在要给源代码仓库配置<code>私钥</code>，配置过程如下：<br>打开 <code>blog-source</code> 仓库，选择 <code>settings</code>，然后选中 <code>secrets</code> ， 再点击 <code>Add new secrets</code>，照着下面填写内容<br>|字段|值|<br>|-|-|<br>|Name|HEXO_DEPLOY_PRI（名称自动构建时有用）|<br>|Value|github-actions-deploy|</p>
<h3 id="配置博客源代码仓库-1"><a href="#配置博客源代码仓库-1" class="headerlink" title="配置博客源代码仓库"></a>配置博客源代码仓库</h3><p>我这里生成的博客静态代码是放在 <code>lixuguang.github.io</code> 中，所以我现在要给静态代码仓库配置<code>公钥</code>，配置过程如下：<br>打开 <code>lixuguang.github.io</code>，选择 <code>settings</code>，然后选中 <code>keys</code>，再点击 <code>Add deploy key</code>，照着下面填写内容<br>|字段|值|<br>|-|-|<br>|Title|HEXO_DEPLOY_PUB|<br>|Key|github-actions-deploy.pub|</p>
<h2 id="编写-Actions-脚本"><a href="#编写-Actions-脚本" class="headerlink" title="编写 Actions 脚本"></a>编写 Actions 脚本</h2><p>经过上面一系列的准备操作，终于来到了编写自动构建脚本的环节，构建脚本如下，如果按照上面我做的操作一步步来的话，那么这一步你可以直接copy啦</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: Deploy Blog</span><br><span class="line"></span><br><span class="line">on: [push] # 当有新push时运行</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build: # 一项叫做build的任务</span><br><span class="line"></span><br><span class="line">    runs-on: ubuntu-latest # 在最新版的Ubuntu系统下运行</span><br><span class="line">    </span><br><span class="line">    steps:</span><br><span class="line">    - name: Checkout # 将仓库内master分支的内容下载到工作目录</span><br><span class="line">      uses: actions&#x2F;checkout@v1 # 脚本来自 https:&#x2F;&#x2F;github.com&#x2F;actions&#x2F;checkout</span><br><span class="line">      </span><br><span class="line">    - name: Use Node.js 10.x # 配置Node环境</span><br><span class="line">      uses: actions&#x2F;setup-node@v1 # 配置脚本来自 https:&#x2F;&#x2F;github.com&#x2F;actions&#x2F;setup-node</span><br><span class="line">      with:</span><br><span class="line">        node-version: &quot;10.x&quot;</span><br><span class="line">    </span><br><span class="line">    - name: Setup Hexo env</span><br><span class="line">      env:</span><br><span class="line">        HEXO_DEPLOY_PRI: $&#123;&#123; secrets.HEXO_DEPLOY_PRI &#125;&#125; # 这里是上面配置的私钥名称</span><br><span class="line">      run: |</span><br><span class="line">        # set up private key for deploy</span><br><span class="line">        mkdir -p ~&#x2F;.ssh&#x2F;</span><br><span class="line">        echo &quot;$HEXO_DEPLOY_PRI&quot; | tr -d &#39;\r&#39; &gt; ~&#x2F;.ssh&#x2F;id_rsa # 配置秘钥</span><br><span class="line">        chmod 600 ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">        ssh-keyscan github.com &gt;&gt; ~&#x2F;.ssh&#x2F;known_hosts</span><br><span class="line">        # set git infomation</span><br><span class="line">        git config --global user.name &#39;lixuguang&#39; # 换成你自己的名字</span><br><span class="line">        git config --global user.email &#39;lixuguang@gmail.com&#39; # 换成你自己的邮箱</span><br><span class="line">        # install dependencies</span><br><span class="line">        npm i -g hexo-cli # 安装hexo</span><br><span class="line">        npm i</span><br><span class="line">  </span><br><span class="line">    - name: Deploy</span><br><span class="line">      run: |</span><br><span class="line">        # publish</span><br><span class="line">        rm -rf .deploy_git # 如果上次构建失败这句命令会清除上次失败的代码</span><br><span class="line">        hexo generate &amp;&amp; hexo deploy # 执行部署程序</span><br></pre></td></tr></table></figure>

<hr>
<p>通过以上这些步骤的操作，如果没什么意外的话，博客的自动构建就完成了，之后只要你提交新的文章到博客源代码仓库，它将自动帮你生成并发送到博客的静态代码仓库，再也不用执行hexo g -d啦，如果这篇文章对你有用，欢迎follow我或打赏一下这篇文章，感谢阅读。</p>
<p>ps：这里有个小坑需要注意一下，因为博客的皮肤也是另外一个git仓库，如果你在本地构建好用但是线上构建博客不显示了，需要注意下是不是皮肤没有上传到博客源码仓库，这里我遇到了，希望你不会因此困扰，拜拜~</p>
]]></content>
      <categories>
        <category>博客技巧</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>Actions</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试Vue篇：Vue组件通信的几种方式</title>
    <url>/2019/12/27/Vue-Component-Communication/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>公司这两年兴起了前后端分离的热潮，在选用三大技术框架时，vue凭借其学习曲线低深受公司程序员的喜爱，因此我们也就走上了vue学习的不归路，在招聘招揽小伙伴时有那么一些问题经常被问起，vue组件间通信就是其中之一，下面我们来聊一聊vue组件通信有哪些方式。</p>
<a id="more"></a>

<h2 id="props和-emit"><a href="#props和-emit" class="headerlink" title="props和$emit"></a><code>props</code>和<code>$emit</code></h2><p>啥也不了解的小伙伴应该也知道这种方式吧，这是最最基础的通信方式了，父子组件通信基本都用它。父组件向子组件传递数据的时候通过prop传参，子组件中通过$emit传递给父组件，父组件在触发子组件$emit方法时得到子组件数据。实例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 父组件 parent.vue</span><br><span class="line"></span><br><span class="line">Vue.compinent(&#39;parent&#39;, &#123;</span><br><span class="line">    template: &#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;p&gt;父组件&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;child :message&#x3D;&quot;message&quot; @getChildrenData&#x3D;&quot;getChildrenData&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;&#96;,</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            message:&#39;Hello lixuguang&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">        * 执行子组件触发的事件方法 </span><br><span class="line">        *&#x2F;</span><br><span class="line">        getChildrenData(data)&#123;</span><br><span class="line">            console.log(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 子组件 child.vue</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;child&#39;, &#123;</span><br><span class="line">    props:[&#39;message&#39;], &#x2F;&#x2F; 得到父组件传过来的数据</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            childMessage: this.message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;childMessage&quot; @input&#x3D;&quot;emitParentData(childMessage)&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        emitParentData(data) &#123;</span><br><span class="line">            this.$emit(&#39;getChildrenData&#39;, data) &#x2F;&#x2F; 父组件触发时给父组件传值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    template: &#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;parent&gt;&lt;&#x2F;parent&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>解析代码：</strong></p>
<ol>
<li>父组件通过<code>message</code>属性将数据传递给子组件，并且通过<code>getChildrenData</code>事件来监听子组件出发的事件；</li>
<li>子组件通过<code>props</code>获得父组件传过来的数据，并且通过<code>this.$emit</code>触发了<code>getChildrenData</code>事件;</li>
</ol>
<h2 id="attrs和-listeners"><a href="#attrs和-listeners" class="headerlink" title="$attrs和$listeners"></a><code>$attrs</code>和<code>$listeners</code></h2><p>前一种方法我们完成了父子组件的数据通信，那你有没有想过如果有多层嵌套的数据最上层要往最下层传值怎么办，前一种方法只能一层一层的往下传，可是这样太麻烦了，那么有没有什么方法能够一次传到你想要传到的位置呢，当然是有的，那就是接下来要说到的<code>$attrs</code>和<code>$listeners</code>。<br>假设我们现在有三层包含关系的组件，分别是level1/level2/level3，level1 &gt; level2 &gt; level3, <code>&gt;</code> 表示包含关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; level3.vue</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;level3&#39;, &#123;</span><br><span class="line">    template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;$attrs.level3Message&quot; @input&#x3D;&quot;emitLevel3Data($attrs.level3Message)&quot;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        emitLevel3Data(data) &#123;</span><br><span class="line">            this.$emit(&#39;getLevel3Data&#39;, data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; level2.vue</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;level2&#39;, &#123;</span><br><span class="line">    props:[&#39;level2Message&#39;],</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            level2Message:this.level2Message</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; v-model&#x3D;&quot;level2Message&quot; @input&#x3D;&quot;emitLevel2Data(level2Message)&quot;&gt;</span><br><span class="line">    &lt;level3 v-bind&#x3D;&#39;$attrs&#39; v-on&#x3D;&#39;$listenrs&#39;&gt;&lt;&#x2F;level3&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        emitLevel2Data(data) &#123;</span><br><span class="line">            this.$emit(&#39;getLevel2Data&#39;, data) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; level1.vue</span><br><span class="line"></span><br><span class="line">Vue.component(&#39;level1&#39;, &#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            level3Message:&quot;I am Level3&quot;,</span><br><span class="line">            level2Message:&quot;I am Level2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template:&#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是level1中的内容&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;level2 :level2Message&#x3D;&quot;level2Message&quot; </span><br><span class="line">            :level3Message&#x3D;&quot;level3Message&quot;</span><br><span class="line">            @getLevel2Data&#x3D;&quot;getLevel2Data()&quot;</span><br><span class="line">            @getLevel3Data&#x3D;&quot;getLevel3Data()&quot;</span><br><span class="line">            &gt;&lt;&#x2F;level2&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getLevel2Data(data) &#123;</span><br><span class="line">            console.log(&#39;这是来自level2的数据&#39;, data)</span><br><span class="line">        &#125;,</span><br><span class="line">        getLevel3Data(data) &#123;</span><br><span class="line">            console.log(&#39;这是来自level3的数据&#39;, data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; App.vue</span><br><span class="line"></span><br><span class="line">var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#app&quot;,</span><br><span class="line">    template: &#96;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;level1&gt;&lt;&#x2F;level1&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &#96;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>解析代码：</strong></p>
<ol>
<li>level3组件能直接触发<code>getLevel3Data</code>是因为level2组件在调用level3组件时使用v-on绑定了$listeners属性；</li>
<li>通过v-bind绑定了$attrs属性，level3组件可以直接获取到从level1传下来的props;</li>
</ol>
<h2 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h2><p>父组件通过v-model传递值给子组件时，会自动传递一个value的props户型，在子组件中可以通过this.$emit(‘input’,val)自动修改v-model绑定的值。</p>
<p>```</p>
<p>未完待续~</p>
]]></content>
      <categories>
        <category>Vue基础</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>vue</tag>
        <tag>组件通信</tag>
      </tags>
  </entry>
  <entry>
    <title>Git的常用命令</title>
    <url>/2017/12/12/Git-Shell/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="指令表"><a href="#指令表" class="headerlink" title="指令表"></a>指令表</h2><table>
<thead>
<tr>
<th>指令</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>git add .</td>
<td>提示增加文件</td>
<td>.代表所有</td>
</tr>
<tr>
<td>git commit -m</td>
<td>“说明内容” 提交到本地服务器</td>
<td></td>
</tr>
<tr>
<td>git status</td>
<td>显示修改信息</td>
<td></td>
</tr>
<tr>
<td>git pull</td>
<td>从网络服务器拉 更新最新版本</td>
<td></td>
</tr>
<tr>
<td>git push</td>
<td>上传最新版本</td>
<td></td>
</tr>
<tr>
<td>git branch</td>
<td>查看当前分支</td>
<td></td>
</tr>
<tr>
<td>git checkout develop</td>
<td>切换到develop模式</td>
<td></td>
</tr>
<tr>
<td>git merge master</td>
<td>从master合并过来</td>
<td></td>
</tr>
<tr>
<td>git push origin develop</td>
<td>提交</td>
<td></td>
</tr>
<tr>
<td>git clone <a href="mailto:git@192.168.2.10">git@192.168.2.10</a>:bat-web.git</td>
<td>从服务器克隆</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>《Web全栈工程师的自我修养》读书笔记</title>
    <url>/2017/10/12/web-quanzhan/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近日工作不是那么忙，所以有时间看看书，这本书之前就已经读过一遍，隔了一段时间已经有所忘记，所以再次拾起，重新回顾一下。.</p>
<a id="more"></a>

<h2 id="什么是全栈"><a href="#什么是全栈" class="headerlink" title="什么是全栈"></a>什么是全栈</h2><p>“全栈”是个外来词，翻译自英文full-stack，此处的栈指的是为了完成项目而使用的一系列技术的合集，不是堆栈概念中的栈。</p>
<p>“全端”工程师是指能够完成pc端、移动端等多终端设备适配的情况</p>
<h2 id="什么是全栈工程师"><a href="#什么是全栈工程师" class="headerlink" title="什么是全栈工程师"></a>什么是全栈工程师</h2><blockquote>
<p>全栈工程师是指一个能够处理数据库、服务器、系统工程、客户端等所有工作的的工程师，根据项目不同，可能是移动栈、Web栈，或者原生应用程序栈。</p>
</blockquote>
<p>简单来说全栈工程师就是一个人能搞定一个项目，全能大神一样的人物。</p>
<h2 id="一个Web产品典型的技术栈"><a href="#一个Web产品典型的技术栈" class="headerlink" title="一个Web产品典型的技术栈"></a>一个Web产品典型的技术栈</h2><blockquote>
<p>服务器+数据库+服务器端编程语言+前端编程语言</p>
</blockquote>
<blockquote>
<p>全栈工程师技术的兴起有两个重要原因：技术的发展和PaaS（Platform as a Service，平台即服务）服务的平台越来越多。</p>
</blockquote>
<h3 id="全栈框架———MEAN"><a href="#全栈框架———MEAN" class="headerlink" title="全栈框架———MEAN"></a>全栈框架———MEAN</h3><blockquote>
<p>MongoDB-Express-AngularJs-Node.js<br>前后端采用一种编程语言JavaScript</p>
</blockquote>
<h2 id="全栈工程师的要求"><a href="#全栈工程师的要求" class="headerlink" title="全栈工程师的要求"></a>全栈工程师的要求</h2><h3 id="一专多长"><a href="#一专多长" class="headerlink" title="一专多长"></a>一专多长</h3><p>在一个领域里至少达到高级的级别，然后再去向上游或者下游延伸</p>
<h3 id="关注商业目标"><a href="#关注商业目标" class="headerlink" title="关注商业目标"></a>关注商业目标</h3><p>公司聘请你是为了让你产生利润，并不关心你会什么，所以选择技术栈时要考虑的是如何降低公司的成本或者提高收入。</p>
<h3 id="关注用户体验"><a href="#关注用户体验" class="headerlink" title="关注用户体验"></a>关注用户体验</h3><p>产品的最终目标是满足客户的需求，所以作为全栈工程师必须要关注用户体验。</p>
<hr>
<p>这是一些作为全栈工程师我整理出来的干货，这本书本身并不是一本技术性很强的书，倒像是一位过来人介绍些经验，适合刚入职场或者进入职场不久的人，在前端领域比较迷茫时看一看，书中介绍了作者读过的一些书，很有参考性，推荐大家阅读。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>前端类</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode ESLint JS代码静态检测工具</title>
    <url>/2017/10/12/VSCode-ESLint/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>VSCode是新一代IDE，方便灵活的插件安装方式让它强大无比，对前端友好，让它成为了越来越多前端开发者的首选IDE，编辑器虽好，但是要自己安装符合自己需求的插件才行，下面介绍一款插件，名叫ESLint，是用来静态检测js代码的工具，让你的js代码在编辑过程中就能找到错误，提高代码质量，好了废话不多说下面介绍如何安装和配置这款插件。</p>
<a id="more"></a>
<h1 id="安装ESLint插件"><a href="#安装ESLint插件" class="headerlink" title="安装ESLint插件"></a>安装ESLint插件</h1><p>打开VSCode编辑器，在左侧右下角有一个安装插件的图标，点击后就可以打开插件市场，输入ESLint，就会有个黄色的图标出现在你面前，不用犹豫双击它，稍等一会它就安装完了，是不是超简单。</p>
<h1 id="安装NPM依赖"><a href="#安装NPM依赖" class="headerlink" title="安装NPM依赖"></a>安装NPM依赖</h1><p>ESLint插件运行需要一些依赖，对于用过npm包管理工具的人来讲小意思啦，我把代码放到下面，需要的直接粘贴运行就好。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;全局安装eslint</span><br><span class="line">npm i eslint -g</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果用到html中的js校验</span><br><span class="line">npm i eslint-plugin-html -g</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;如果用到es2015语法</span><br><span class="line">npm i babel-eslint -g</span><br></pre></td></tr></table></figure>
<h1 id="配置eslint配置文件到项目根目录"><a href="#配置eslint配置文件到项目根目录" class="headerlink" title="配置eslint配置文件到项目根目录"></a>配置eslint配置文件到项目根目录</h1><p>配置文件名称如下：<br><strong>eslintrc.json</strong><br>内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        &quot;plugins&quot;: [</span><br><span class="line">                &#x2F;&#x2F; &quot;react&quot;,</span><br><span class="line">                &quot;html&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;env&quot;: &#123;</span><br><span class="line">                &quot;node&quot;: true,</span><br><span class="line">                &quot;jquery&quot;: true,</span><br><span class="line">                &quot;es6&quot;: true,</span><br><span class="line">                &quot;browser&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;globals&quot;: &#123;</span><br><span class="line">                &quot;angular&quot;: false</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;parser&quot;: &quot;babel-eslint&quot;,</span><br><span class="line">        &quot;rules&quot;: &#123;</span><br><span class="line">                &#x2F;&#x2F;官方文档 http:&#x2F;&#x2F;eslint.org&#x2F;docs&#x2F;rules&#x2F;</span><br><span class="line">                &#x2F;&#x2F;参数：0 关闭，1 警告，2 错误</span><br><span class="line">                &#x2F;&#x2F; &quot;quotes&quot;: [0, &quot;single&quot;],                  &#x2F;&#x2F;建议使用单引号</span><br><span class="line">                &#x2F;&#x2F; &quot;no-inner-declarations&quot;: [0, &quot;both&quot;],     &#x2F;&#x2F;不建议在&#123;&#125;代码块内部声明变量或函数</span><br><span class="line">                &quot;no-extra-boolean-cast&quot;: 1, &#x2F;&#x2F;多余的感叹号转布尔型</span><br><span class="line">                &quot;no-extra-semi&quot;: 1, &#x2F;&#x2F;多余的分号</span><br><span class="line">                &quot;no-extra-parens&quot;: 0, &#x2F;&#x2F;多余的括号</span><br><span class="line">                &quot;no-empty&quot;: 1, &#x2F;&#x2F;空代码块</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;使用前未定义</span><br><span class="line">                &quot;no-use-before-define&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &quot;nofunc&quot;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &quot;complexity&quot;: [0, 10], &#x2F;&#x2F;圈复杂度大于*</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;定义数组或对象最后多余的逗号</span><br><span class="line">                &quot;comma-dangle&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &quot;never&quot;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F; 不允许对全局变量赋值,如 window &#x3D; &#39;abc&#39;</span><br><span class="line">                &quot;no-global-assign&quot;: [&quot;error&quot;, &#123;</span><br><span class="line">                        &#x2F;&#x2F; 定义例外</span><br><span class="line">                        &#x2F;&#x2F; &quot;exceptions&quot;: [&quot;Object&quot;]</span><br><span class="line">                &#125;],</span><br><span class="line">                &quot;no-var&quot;: 0, &#x2F;&#x2F;用let或const替代var</span><br><span class="line">                &quot;no-const-assign&quot;: 2, &#x2F;&#x2F;不允许const重新赋值</span><br><span class="line">                &quot;no-class-assign&quot;: 2, &#x2F;&#x2F;不允许对class重新赋值</span><br><span class="line">                &quot;no-debugger&quot;: 1, &#x2F;&#x2F;debugger 调试代码未删除</span><br><span class="line">                &quot;no-console&quot;: 0, &#x2F;&#x2F;console 未删除</span><br><span class="line">                &quot;no-constant-condition&quot;: 2, &#x2F;&#x2F;常量作为条件</span><br><span class="line">                &quot;no-dupe-args&quot;: 2, &#x2F;&#x2F;参数重复</span><br><span class="line">                &quot;no-dupe-keys&quot;: 2, &#x2F;&#x2F;对象属性重复</span><br><span class="line">                &quot;no-duplicate-case&quot;: 2, &#x2F;&#x2F;case重复</span><br><span class="line">                &quot;no-empty-character-class&quot;: 2, &#x2F;&#x2F;正则无法匹配任何值</span><br><span class="line">                &quot;no-invalid-regexp&quot;: 2, &#x2F;&#x2F;无效的正则</span><br><span class="line">                &quot;no-func-assign&quot;: 2, &#x2F;&#x2F;函数被赋值</span><br><span class="line">                &quot;valid-typeof&quot;: 1, &#x2F;&#x2F;无效的类型判断</span><br><span class="line">                &quot;no-unreachable&quot;: 2, &#x2F;&#x2F;不可能执行到的代码</span><br><span class="line">                &quot;no-unexpected-multiline&quot;: 2, &#x2F;&#x2F;行尾缺少分号可能导致一些意外情况</span><br><span class="line">                &quot;no-sparse-arrays&quot;: 1, &#x2F;&#x2F;数组中多出逗号</span><br><span class="line">                &quot;no-shadow-restricted-names&quot;: 2, &#x2F;&#x2F;关键词与命名冲突</span><br><span class="line">                &quot;no-undef&quot;: 1, &#x2F;&#x2F;变量未定义</span><br><span class="line">                &quot;no-unused-vars&quot;: 1, &#x2F;&#x2F;变量定义后未使用</span><br><span class="line">                &quot;no-cond-assign&quot;: 2, &#x2F;&#x2F;条件语句中禁止赋值操作</span><br><span class="line">                &quot;no-native-reassign&quot;: 2, &#x2F;&#x2F;禁止覆盖原生对象</span><br><span class="line">                &quot;no-mixed-spaces-and-tabs&quot;: 0,</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;代码风格优化 --------------------------------------</span><br><span class="line">                &quot;no-irregular-whitespace&quot;: 0,</span><br><span class="line">                &quot;no-else-return&quot;: 0, &#x2F;&#x2F;在else代码块中return，else是多余的</span><br><span class="line">                &quot;no-multi-spaces&quot;: 0, &#x2F;&#x2F;不允许多个空格</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;object直接量建议写法 : 后一个空格前面不留空格</span><br><span class="line">                &quot;key-spacing&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;beforeColon&quot;: false,</span><br><span class="line">                                &quot;afterColon&quot;: true</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &quot;block-scoped-var&quot;: 1, &#x2F;&#x2F;变量应在外部上下文中声明，不应在&#123;&#125;代码块中</span><br><span class="line">                &quot;consistent-return&quot;: 1, &#x2F;&#x2F;函数返回值可能是不同类型</span><br><span class="line">                &quot;accessor-pairs&quot;: 1, &#x2F;&#x2F;object getter&#x2F;setter方法需要成对出现</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;换行调用对象方法  点操作符应写在行首</span><br><span class="line">                &quot;dot-location&quot;: [</span><br><span class="line">                        1,</span><br><span class="line">                        &quot;property&quot;</span><br><span class="line">                ],</span><br><span class="line">                &quot;no-lone-blocks&quot;: 1, &#x2F;&#x2F;多余的&#123;&#125;嵌套</span><br><span class="line">                &quot;no-labels&quot;: 1, &#x2F;&#x2F;无用的标记</span><br><span class="line">                &quot;no-extend-native&quot;: 1, &#x2F;&#x2F;禁止扩展原生对象</span><br><span class="line">                &quot;no-floating-decimal&quot;: 1, &#x2F;&#x2F;浮点型需要写全 禁止.1 或 2.写法</span><br><span class="line">                &quot;no-loop-func&quot;: 1, &#x2F;&#x2F;禁止在循环体中定义函数</span><br><span class="line">                &quot;no-new-func&quot;: 1, &#x2F;&#x2F;禁止new Function(...) 写法</span><br><span class="line">                &quot;no-self-compare&quot;: 1, &#x2F;&#x2F;不允与自己比较作为条件</span><br><span class="line">                &quot;no-sequences&quot;: 1, &#x2F;&#x2F;禁止可能导致结果不明确的逗号操作符</span><br><span class="line">                &quot;no-throw-literal&quot;: 1, &#x2F;&#x2F;禁止抛出一个直接量 应是Error对象</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;不允return时有赋值操作</span><br><span class="line">                &quot;no-return-assign&quot;: [</span><br><span class="line">                        1,</span><br><span class="line">                        &quot;always&quot;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;不允许重复声明</span><br><span class="line">                &quot;no-redeclare&quot;: [</span><br><span class="line">                        1,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;builtinGlobals&quot;: true</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;不执行的表达式</span><br><span class="line">                &quot;no-unused-expressions&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;allowShortCircuit&quot;: true,</span><br><span class="line">                                &quot;allowTernary&quot;: true</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;no-useless-call&quot;: 1, &#x2F;&#x2F;无意义的函数call或apply</span><br><span class="line">                &quot;no-useless-concat&quot;: 1, &#x2F;&#x2F;无意义的string concat</span><br><span class="line">                &quot;no-void&quot;: 1, &#x2F;&#x2F;禁用void</span><br><span class="line">                &quot;no-with&quot;: 1, &#x2F;&#x2F;禁用with</span><br><span class="line">                &quot;space-infix-ops&quot;: 0, &#x2F;&#x2F;操作符前后空格</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;jsdoc</span><br><span class="line">                &quot;valid-jsdoc&quot;: [</span><br><span class="line">                        0,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;requireParamDescription&quot;: true,</span><br><span class="line">                                &quot;requireReturnDescription&quot;: true</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line"> </span><br><span class="line">                &#x2F;&#x2F;标记未写注释</span><br><span class="line">                &quot;no-warning-comments&quot;: [</span><br><span class="line">                        1,</span><br><span class="line">                        &#123;</span><br><span class="line">                                &quot;terms&quot;: [</span><br><span class="line">                                        &quot;todo&quot;,</span><br><span class="line">                                        &quot;fixme&quot;,</span><br><span class="line">                                        &quot;any other term&quot;</span><br><span class="line">                                ],</span><br><span class="line">                                &quot;location&quot;: &quot;anywhere&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                ],</span><br><span class="line">                &quot;curly&quot;: 0 &#x2F;&#x2F;if、else、while、for代码块用&#123;&#125;包围</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>eslint就是根据这个配置表来进行js语法校验的。</p>
<h1 id="最后重启VSCode完成插件安装"><a href="#最后重启VSCode完成插件安装" class="headerlink" title="最后重启VSCode完成插件安装"></a>最后重启VSCode完成插件安装</h1><p>重启后控制台显示ESLint server is running说明插件已经生效，好啦接下来就愉快的写代码吧。</p>
]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>给博客添加基于github-issue的评论系统</title>
    <url>/2017/10/12/us-gitment/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章介绍了<a href="https://lixuguang.github.io/2017/10/11/use-GitHub-Hexo-Next-make-blog/">如何利用github+hexo+next制作一个博客系统</a>，但是由于这个博客系统是基于静态页面的，所以无法完成评论功能，博客怎么可以没有评论功能呢，当然next主题提供了几个选项，但是国内你知道的，提供的几个评论功能都不是太好用，于是就上网找了好多资料，功夫不负有心人，让我找到了一个名曰gitment的基于github-issue的评论插件，下面就介绍大家如何使用这个插件。</p>
<a id="more"></a>
<h2 id="第一步-注册一个小程序（OAuth-Application）"><a href="#第一步-注册一个小程序（OAuth-Application）" class="headerlink" title="第一步 注册一个小程序（OAuth Application）"></a>第一步 注册一个小程序（OAuth Application）</h2><p>点击<a href="https://github.com/settings/applications/new" target="_blank" rel="noopener">https://github.com/settings/applications/new</a>注册</p>
<ul>
<li>Application name 应用名称 这里随便写，我写的就是gitment</li>
<li>Homepage URL 主页地址，你可以写你的博客地址，我写的是<a href="https://lixuguang.github.io/">https://lixuguang.github.io/</a></li>
<li>Application description 应用描述，这里随便写点什么，反正是自己用。</li>
<li>Authorization callback URL 这个比较重要，请填写你的博客地址，我的是<a href="https://lixuguang.github.io/">https://lixuguang.github.io/</a></li>
</ul>
<p>点击确定以后你会获得两个关键信息，下一步配置时会用到</p>
<ul>
<li>Client ID</li>
<li>Client Secret</li>
</ul>
<h2 id="第二步-修改主题配置文件，添加gitment评论功能"><a href="#第二步-修改主题配置文件，添加gitment评论功能" class="headerlink" title="第二步 修改主题配置文件，添加gitment评论功能"></a>第二步 修改主题配置文件，添加gitment评论功能</h2><p>因为用的是next主题，所以配置文件地址如下：<br><strong>themes/next/_config.yml</strong></p>
<h3 id="1、在其中添加"><a href="#1、在其中添加" class="headerlink" title="1、在其中添加:"></a>1、在其中添加:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Gitment</span><br><span class="line"># Introduction: https:&#x2F;&#x2F;imsun.net&#x2F;posts&#x2F;gitment-introduction&#x2F;</span><br><span class="line">gitment:</span><br><span class="line">  enable: true</span><br><span class="line">  githubID: yourid &#x2F;&#x2F; 我的是lixuguang</span><br><span class="line">  repo: yourrepo &#x2F;&#x2F; 我的是lixuguang.github.io 必须跟githubID保持一致的用户名</span><br><span class="line">  ClientID: yourid &#x2F;&#x2F; 上面开通程序获得的ClientID</span><br><span class="line">  ClientSecret: yoursecret &#x2F;&#x2F; 上面开通程序获得的Client Secret</span><br><span class="line">  lazy: false &#x2F;&#x2F;是否需要点击展开评论才能可见评论，一般设置为false</span><br></pre></td></tr></table></figure>
<p><strong>一定要注意空格，不然会报错的，别问我咋知道的</strong></p>
<h3 id="2、然后在主题的配置语言环境的文件添加一句话"><a href="#2、然后在主题的配置语言环境的文件添加一句话" class="headerlink" title="2、然后在主题的配置语言环境的文件添加一句话"></a>2、然后在主题的配置语言环境的文件添加一句话</h3><p><code>en.yml</code>增加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitmentbutton: Show comments from Gitment</span><br></pre></td></tr></table></figure>

<p><code>zh-Hans.yml</code>增加:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gitmentbutton: 显示 Gitment 评论</span><br></pre></td></tr></table></figure>
<p>如果是中文网站英文配置也可以不用写。</p>
<h3 id="3、添加新的Dom结构"><a href="#3、添加新的Dom结构" class="headerlink" title="3、添加新的Dom结构"></a>3、添加新的Dom结构</h3><p><strong>修改主题layout/_partials/comments.swig</strong><br>在最后一个elseif分支后添加一个elseif分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% elseif theme.gitment.enable %&#125;</span><br><span class="line">       &#123;% if theme.gitment.lazy %&#125;</span><br><span class="line">         &lt;div onclick&#x3D;&quot;ShowGitment()&quot; id&#x3D;&quot;gitment-display-button&quot;&gt;&#123;&#123;  __(&#39;gitmentbutton&#39;) &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">         &lt;div id&#x3D;&quot;gitment-container&quot; style&#x3D;&quot;display:none&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">       &#123;% else %&#125;</span><br><span class="line">         &lt;div id&#x3D;&quot;gitment-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">       &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4、-在主题下layout-third-party-comments-目录下中添加文件gitment-swig"><a href="#4、-在主题下layout-third-party-comments-目录下中添加文件gitment-swig" class="headerlink" title="4、 在主题下layout/_third-party/comments/目录下中添加文件gitment.swig"></a>4、 在主题下layout/_third-party/comments/目录下中添加文件gitment.swig</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if theme.gitment.enable %&#125;</span><br><span class="line">   &#123;% set owner &#x3D; theme.gitment.githubID %&#125;</span><br><span class="line">   &#123;% set repo &#x3D; theme.gitment.repo %&#125;</span><br><span class="line">   &#123;% set cid &#x3D; theme.gitment.ClientID %&#125;</span><br><span class="line">   &#123;% set cs &#x3D; theme.gitment.ClientSecret %&#125;</span><br><span class="line">   &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;imsun.github.io&#x2F;gitment&#x2F;style&#x2F;default.css&quot;&gt;</span><br><span class="line">   &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;imsun.github.io&#x2F;gitment&#x2F;dist&#x2F;gitment.browser.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">   &#123;% if not theme.gitment.lazy %&#125;</span><br><span class="line">       &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">           var gitment &#x3D; new Gitment(&#123;</span><br><span class="line">               id: window.location.pathname, </span><br><span class="line">               owner: &#39;&#123;&#123;owner&#125;&#125;&#39;,</span><br><span class="line">               repo: &#39;&#123;&#123;repo&#125;&#125;&#39;,</span><br><span class="line">               oauth: &#123;</span><br><span class="line">                   client_id: &#39;&#123;&#123;cid&#125;&#125;&#39;,</span><br><span class="line">                   client_secret: &#39;&#123;&#123;cs&#125;&#125;&#39;,</span><br><span class="line">               &#125;&#125;);</span><br><span class="line">           gitment.render(&#39;gitment-container&#39;);</span><br><span class="line">       &lt;&#x2F;script&gt;</span><br><span class="line">   &#123;% else %&#125;</span><br><span class="line">       &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">           function ShowGitment()&#123;</span><br><span class="line">               document.getElementById(&quot;gitment-display-button&quot;).style.display &#x3D; &quot;none&quot;;</span><br><span class="line">               document.getElementById(&quot;gitment-container&quot;).style.display &#x3D; &quot;block&quot;;</span><br><span class="line">               var gitment &#x3D; new Gitment(&#123;</span><br><span class="line">                   id: document.location.href, </span><br><span class="line">                   owner: &#39;&#123;&#123;owner&#125;&#125;&#39;,</span><br><span class="line">                   repo: &#39;&#123;&#123;repo&#125;&#125;&#39;,</span><br><span class="line">                   oauth: &#123;</span><br><span class="line">                       client_id: &#39;&#123;&#123;cid&#125;&#125;&#39;,</span><br><span class="line">                       client_secret: &#39;&#123;&#123;cs&#125;&#125;&#39;,</span><br><span class="line">                   &#125;&#125;);</span><br><span class="line">               gitment.render(&#39;gitment-container&#39;);</span><br><span class="line">           &#125;</span><br><span class="line">       &lt;&#x2F;script&gt;</span><br><span class="line">   &#123;% endif %&#125;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下layout/_third-party/comments/index.swig文件中引入gitment.swig文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% include &#39;gitment.swig&#39; %&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在主题下source-css-common-components-third-party-目录下添加gitment-styl文件"><a href="#在主题下source-css-common-components-third-party-目录下添加gitment-styl文件" class="headerlink" title="在主题下source/css/_common/components/third-party/目录下添加gitment.styl文件"></a>在主题下source/css/_common/components/third-party/目录下添加gitment.styl文件</h3><p>此配置文件为gitment的样式文件，需要修改样式可以在这里进行书写，这里修改一下按钮样式，另外将聊天框于文章框样式统一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#gitment-display-button&#123;</span><br><span class="line">     display: inline-block;</span><br><span class="line">     padding: 0 15px;</span><br><span class="line">     color: #0a9caf;</span><br><span class="line">     cursor: pointer;</span><br><span class="line">     font-size: 14px;</span><br><span class="line">     border: 1px solid #0a9caf;</span><br><span class="line">     border-radius: 4px;</span><br><span class="line"> &#125;</span><br><span class="line"> #gitment-display-button:hover&#123;</span><br><span class="line">     color: #fff;</span><br><span class="line">     background: #0a9caf;</span><br><span class="line"> &#125;</span><br><span class="line">  #comments &#123;</span><br><span class="line">    margin: 0;</span><br><span class="line">    padding: 40px;</span><br><span class="line">    background: #fff;</span><br><span class="line">    box-shadow: 0 2px 2px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.06), 0 1px 5px 0 rgba(0,0,0,0.12);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在主题下source/css/_common/components/third-party/third-party.styl文件中引入相应的CSS样式即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@import &quot;gitment&quot;;</span><br></pre></td></tr></table></figure>
<p>经过以上操作，gitment就被引入到你的博客里了。</p>
<p>现在就可以让大家对你写的文章进行评论啦，怎么样是不是又学到啦，喜欢我的文章就请关注我的github吧。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>blog - hexo - next - npm</tag>
      </tags>
  </entry>
  <entry>
    <title>如何利用GitHub-Hexo-Next搭建一个漂亮的技术博客</title>
    <url>/2017/10/11/use-GitHub-Hexo-Next-make-blog/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>开博客貌似并不是一件难事，现在有很多的方式开博客，而且现在博客貌似也不再流行，但是作为一个开发者，维护一个技术博客对自己的发展是很有好处的，出名者如阮一峰等，所以还是想要做一个技术博客的。</p>
</blockquote>
<blockquote>
<p>开博客可以选择网上现有的博客系统如博客园以及其他各大公司提供的博客系统，也可以选择如wordpress等博客程序自行搭建博客系统，前者省事，但可自定义设置不足不符合一个爱折腾的人的性格，后者复杂些，爱折腾的可以学着搭建，但是服务器域名是个让人头疼的事，还有数据库等操作，着实麻烦，如今又有了另外一个选择，那就是利用GitHub和一些静态的博客系统搭建一个纯静态的博客系统，不花钱又能折腾，而且还是命令行下的，装B感觉棒棒的，另外搭配时下流行的MarkDown语法，做笔记正合我意。</p>
</blockquote>
<a id="more"></a>

<h2 id="技术栈选型"><a href="#技术栈选型" class="headerlink" title="技术栈选型"></a>技术栈选型</h2><blockquote>
<p>这里说是技术栈选型可能并不是很恰当，但又找不到合适的描述，就是把需要的技术介绍一下，如果还不会的，可以自行学习，或者看看我的其他文章。</p>
</blockquote>
<ul>
<li>node（npm），现在node这么火，没用过都不好意思出门，但是如果你还不回的话，就先自行学习安装一下吧。</li>
<li>Hexo 静态博客程序，其实还有很多，只不过这个比较新，而且搭配Next非常漂亮，就选了它。</li>
<li>Next 可以说是Hexo的定制系统，不仅仅是做了个皮肤，简洁美观的配置项和官网说明深得我心。</li>
</ul>
<h2 id="搭建步骤（安装步骤）"><a href="#搭建步骤（安装步骤）" class="headerlink" title="搭建步骤（安装步骤）"></a>搭建步骤（安装步骤）</h2><h3 id="安装Hexo-Hexo官网"><a href="#安装Hexo-Hexo官网" class="headerlink" title="安装Hexo Hexo官网"></a>安装Hexo <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo官网</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-cli -g &#x2F;&#x2F; 安装hexo的脚手架工具</span><br><span class="line">$ hexo init blog &#x2F;&#x2F; 初始化博客</span><br><span class="line">$ cd blog &#x2F;&#x2F; 返回博客目录</span><br><span class="line">$ npm install &#x2F;&#x2F; 安装依赖</span><br><span class="line">$ hexo server &#x2F;&#x2F; 启动博客</span><br></pre></td></tr></table></figure>
<blockquote>
<p>怎么样五行代码就生成并运行了一个博客是不是超简单。<br>下面我们看一下生成的博客的目录</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p><code>_config.yml</code>这是博客的配置文件，比如博客名称，副标题，作者等信息都在这个文件里设置。</p>
<p><code>package.json</code>这是博客的依赖文件可以忽略</p>
<p><code>scaffolds</code>这是博客的模板目录，当你要写一篇文章时，这里会有文章的默认类型。</p>
<p><code>source</code>这是博客的网站资源，包括发布的文章（<code>_posts</code>）、关于、分类还有上传文件等。</p>
<p><code>themes</code>这是博客的皮肤。</p>
<p>更多配置信息请查阅官网手册</p>
<h3 id="安装Next主题-Next官网"><a href="#安装Next主题-Next官网" class="headerlink" title="安装Next主题 Next官网"></a>安装Next主题 <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next官网</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;iissnan&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>

<p>然后到<code>_config.yml</code>配置文件将主题配置改成next就可以使用next的皮肤了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>皮肤也有配置文件，为跟Hexo进行区分Hexo的配置文件称为<code>站点配置文件</code>， 皮肤配置文件称为<code>主题配置文件</code>。</p>
<p>对两个配置文件进行简单配置后，符合需求的博客就搭建而成了，这里有个友好的建议，配置文件如果配置不正确将不能正确运行博客，所以在配置前务必保留好原始配置文件，注意配置时不要缺了空格，不要问我为什么知道这个。</p>
<h3 id="更新博客主题"><a href="#更新博客主题" class="headerlink" title="更新博客主题"></a>更新博客主题</h3><p><a href="https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next/blob/master/docs/zh-CN/UPDATE-FROM-5.1.X.md</a></p>
<h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>博客已经搭建好了，接下来就是写博客了，那么如何开始写博客呢，超级简单一行命令足以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;  </span><br><span class="line">&#x2F;&#x2F; layout 为模板类型可以省略，title为文章标题，通常可以简写为如下</span><br><span class="line">hexo new title</span><br></pre></td></tr></table></figure>
<p>新建命令执行后在<code>_posts</code>的目录下就会生成一个你刚才命名的md后缀的文件，这就是一个MarkDown语法的文件，（如果不了解MarkDown语法的可以去学一下，很简单的符号语言，或者像我一样用支持MarkDown语法的编辑器来写文章。新建的文章打开内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: new-post</span><br><span class="line">date: 2017-10-11 15:01:09</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>非常好理解，title就是标题，date为创建时间，tags是标签方便分类，但是这些并不全，还有些常用的分类没有写上，下面我将常用的进行补充</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: new-post</span><br><span class="line">date: 2017-10-11 15:01:09</span><br><span class="line">categories: </span><br><span class="line">	- node</span><br><span class="line">	- npm</span><br><span class="line">tags:</span><br><span class="line">	- npm</span><br><span class="line">	- node</span><br><span class="line">	- rnpm</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>这样补充后就有了常见博客的分类和标签的功能，是不是很简单。</p>
<p>写完文章以后还要执行下面命令，生成静态页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate &#x2F;&#x2F; 将md后缀文件生成成静态html文件</span><br></pre></td></tr></table></figure>


<p>这样我们就完成了博客的搭建和博客的书写，到现在我们就已经有了一个本地的博客，那么如何将博客上传到GitHub上呢？</p>
<h2 id="将Blog上传至GitHub"><a href="#将Blog上传至GitHub" class="headerlink" title="将Blog上传至GitHub"></a>将Blog上传至GitHub</h2><p>github是一个代码托管的平台，为了方便描述代码功能，它提供了README.md文件进行说明，但是为了更好的展现，也提供了gitpage的功能，博客是基于这个功能进行的扩展，那么如何用gitpage的功能来实现博客系统呢？</p>
<h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>创建一个以你的GitHub账号为开头命名的仓库，格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GitHub账号名称.github.io</span><br><span class="line">&#x2F;&#x2F; 如</span><br><span class="line">lixuguang.github.io</span><br></pre></td></tr></table></figure>
<p>然后到blog系统的配置文件<code>_config.yml</code>里配置一下上传路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt;</span><br><span class="line">  </span><br><span class="line">&#x2F;&#x2F; 我的实例</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:lixuguang&#x2F;lixuguang.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>配置好就可以进行部署了，部署也很简单，只需要执行一下下面的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save &#x2F;&#x2F; 安装上传工具</span><br><span class="line"></span><br><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>稍等一会，如果没有出现什么错误信息，那么你的部署就成功了。之后你就可以访问你的博客了，博客地址如下：<br>https://你的github账号.github.io/<br>我的如下：<br><a href="https://lixuguang.github.io/">https://lixuguang.github.io/</a></p>
<p>现在你是不是已经学会如何利用github搭建一个静态的博客系统了呢，如果你还没有一个自己的技术博客，快来试试吧。</p>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>是不是觉得命令行还是挺麻烦的，要敲那么一大串字母，哈哈实际上这些常用命令是有缩写方式的，下面给大家介绍一下缩写方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">$ hexo s</span><br><span class="line"></span><br><span class="line">$ hexo generate</span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">$ hexo g</span><br><span class="line"></span><br><span class="line">$ hexo deploy</span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">$ hexo d</span><br><span class="line"></span><br><span class="line">$ hexo new</span><br><span class="line">&#x2F;&#x2F; 简写</span><br><span class="line">$ hexo n</span><br></pre></td></tr></table></figure>

<p>另外每次发布之前最好执行以下命令，清理当前内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>以防出现冲突的情况，具体动作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d &#x2F;&#x2F; 文件生成后立即部署网站</span><br><span class="line">$ hexo d -g &#x2F;&#x2F; 部署之前预先生成静态文件</span><br></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol>
<li>SSH问题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;lixuguang316@gmail.com&quot;</span><br><span class="line">&#x2F;&#x2F; 填写你自己的github邮箱</span><br></pre></td></tr></table></figure>
<p>敲三下回车，之后会在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator\.ssh &#x2F;&#x2F; windows下</span><br><span class="line">open ~&#x2F;.ssh &#x2F;&#x2F; Mac下打开ssh文件</span><br></pre></td></tr></table></figure>
<p>文件夹下生成两个文件<code>id_rsa</code>（私钥）、<code>id_rsa.pub</code>（公钥），在github上的SSH处添加新的ssh，然后将<code>公钥</code>内容贴到上面起个名字可以叫hexo，保存，然后在git bash下敲击</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh git@github.com</span><br></pre></td></tr></table></figure>
<p>然后敲<code>yes</code>就可以上传blog代码了<br>怎么样会了么？更多高阶玩法请阅读官方说明文档，文章如有谬误之处请各位指出，如果觉得文章对你有所帮助我将十分开心，如果你喜欢我的文章可以到我的github上点个<code>fork</code>，谢谢你的阅读。</p>
]]></content>
      <categories>
        <category>前端技术</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue基础</title>
    <url>/2017/08/30/Vue-basic/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近公司技术选型选择了VUE，下面就记录一下在学习Vue中遇到的一些知识点，有些在官方手册里已经讲的很详细了，这里就简单带过，主要对cli产生的以及自行添加的一些项目目录进行一下解释，希望对正在学习Vue的同学提供一点帮助，如果本文有谬误之处还请各位指出，谢谢各位支持。</p>
<a id="more"></a>
<h3 id="搭建项目"><a href="#搭建项目" class="headerlink" title="搭建项目"></a>搭建项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --global vue-cli</span><br><span class="line">vue init webpack my-project</span><br><span class="line">cd my-project</span><br><span class="line">npm install（推荐用cnpm install）</span><br><span class="line">如果没有cnpm ，先安装cnpm镜像</span><br><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<h3 id="目录讲解"><a href="#目录讲解" class="headerlink" title="目录讲解"></a>目录讲解</h3><blockquote>
<ul>
<li>build和config ：项目开发和打包时候的相关配置；</li>
<li>node_modules ：项目所需要的依赖文件；</li>
<li>src ：主应用/页面相关文件；<ul>
<li>assets ： 静态资源文件；</li>
<li>components ：组件；</li>
<li>res：资源<ul>
<li>css： 公共css或是css预处理文件；</li>
<li>js：   公共js文件</li>
<li>img：公共图片</li>
</ul>
</li>
<li>router ：路由配置文件；</li>
<li>views ： 视图文件，其实也是vue组件。按照业务功能划分模块；</li>
<li>vuex : 状态管理的配置文件；</li>
<li>App.vue : 主组件；</li>
<li>main.js： 入口文件，初始化vue实例并使用需要的插件</li>
</ul>
</li>
<li>index.html ： 主html页面；</li>
<li>dist：webpack打包生成的文件；</li>
<li>package.json：记录依赖相关信息</li>
</ul>
</blockquote>
<h3 id="文件的加载顺序"><a href="#文件的加载顺序" class="headerlink" title="文件的加载顺序:"></a>文件的加载顺序:</h3><p>当我们执行命令 <code>npm run dev</code>的时候根据配置文件<code>dev-server.js</code>里的相关配置去加载<code>webpack</code>的相关配置文件 在<code>webpack.base.conf</code>里面<code>entry</code>入口文件就配置了<code>app：&#39;./src/main.js&#39;</code> </p>
<p>所以当我们在运行<code>npm run dev</code>的时候就开始通过<code>main.js</code>执行了。<code>main.js</code> 初始化vue实例并且加载相关配置插件，然后通过<code>app.vue</code>文件去访问各个组件</p>
<h3 id="Build-dev-server-js主要完成以下几件事情："><a href="#Build-dev-server-js主要完成以下几件事情：" class="headerlink" title="Build/dev-server.js主要完成以下几件事情："></a>Build/dev-server.js主要完成以下几件事情：</h3><ol>
<li>检查node和npm的版本；</li>
<li>引入相关插件和配置；</li>
<li>创建express服务器和webpack编译器；</li>
<li>配置开发中间件（webpack-dev-middleware）和热重载中间件（webpack-hot-middleware）；</li>
<li>挂载代理服务和中间件；</li>
<li>配置静态资源；</li>
<li>启动服务器监听特定端口（8080）；</li>
<li>自动打开浏览器并打开特定网址（localhost:8080）；</li>
</ol>
<h3 id="Build-huild-js主要完成以下几件事情："><a href="#Build-huild-js主要完成以下几件事情：" class="headerlink" title="Build/huild.js主要完成以下几件事情："></a>Build/huild.js主要完成以下几件事情：</h3><ol>
<li>loading动画；</li>
<li>删除创建目标文件夹；</li>
<li>webpack编译；</li>
<li>输出信息</li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h4><p>设置转码的规则和插件（使用es6语法必须安装插件）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install babel-preset-es2015</span><br></pre></td></tr></table></figure>

<p>presets 字段是用来设定转码规则;</p>
<h4 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h4><p>配置文件编码格式的文件</p>
<ul>
<li>indent_style:  设置缩进风格，tab或者空格;</li>
<li>indent_size:  缩进的宽度;</li>
<li>tab_width:   设置tab的列数。默认是indent_size;</li>
<li>end_of_line： 换行符，lf、cr和crlf;</li>
<li>charset：  编码;</li>
<li>trim_trailing_whitespace： 设为true表示会除去换行行首的任意空白字符;</li>
<li>insert_final_newline:   设为true表明使文件以一个空白行结尾;</li>
<li>root: 表明是最顶层的配置文件，发现设为true时，才会停止查找.editorconfig文件;</li>
</ul>
<h4 id="eslintignore"><a href="#eslintignore" class="headerlink" title=".eslintignore"></a>.eslintignore</h4><p>忽略不符合eslint规范的文件, （一般会忽略掉第三方引用的插件）</p>
<h4 id="eslintrc-js"><a href="#eslintrc-js" class="headerlink" title=".eslintrc.js"></a>.eslintrc.js</h4><p>定义代码规则</p>
<h4 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h4><p>配置文件，用于配置不需要加入版本管理的文件</p>
<h3 id="VUE-文件解释"><a href="#VUE-文件解释" class="headerlink" title=".VUE 文件解释"></a>.VUE 文件解释</h3><ul>
<li>template： 展示模板</li>
<li>import ： 导入组件已经js文件</li>
<li>export default： <ul>
<li>data：数据源；</li>
<li>methods：方法；                </li>
<li>mounted：页面加载之后执行的方法；    </li>
<li>created：页面生成时加载的方法；</li>
</ul>
</li>
<li>style：  样式代码  其中scoped表示样式作用范围为本vue文件</li>
</ul>
<h3 id="网络访问"><a href="#网络访问" class="headerlink" title="网络访问"></a>网络访问</h3><h4 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h4><ol>
<li>发送请求：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios#request(config)；</span><br><span class="line">axios#get(url[, config])；</span><br><span class="line">axios#delete(url[, config])；</span><br><span class="line">axios#head(url[, config])；</span><br><span class="line">axios#post(url[, data[, config]])；</span><br><span class="line">axios#put(url[, data[, config]])；</span><br><span class="line">axios#patch(url[, data[, config]])；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>处理响应：</li>
</ol>
<ul>
<li>Promise语法；</li>
<li>处理结果：then；</li>
<li>处理异常：catch；</li>
</ul>
<ol start="3">
<li>拦截器（use/reject）：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">axios.interceptors.response.use；</span><br><span class="line">axios.interceptors.rquest.use；</span><br><span class="line">reject(移除请求拦截)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>参数：</li>
</ol>
<ul>
<li>json（默认）；</li>
<li>qs；</li>
</ul>
<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><ul>
<li>Prpos：父组件对子组件；</li>
<li>自定义事件：子组件对父组件；</li>
<li>消息总线：任意两个组件；</li>
<li>状态管理：Vuex（适用于大型单页面开发）</li>
</ul>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><ol>
<li>配置</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#39;&#x2F;&#39;,</span><br><span class="line">      name: &#39;Hello&#39;,</span><br><span class="line">      component: Hello</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app&#39;,</span><br><span class="line">  router,</span><br><span class="line">  template: &#39;&lt;App&#x2F;&gt;&#39;,</span><br><span class="line">  components: &#123; App &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>导航</li>
</ol>
<ul>
<li>push</li>
<li>replace</li>
<li>go</li>
</ul>
<ol start="3">
<li>参数传递</li>
</ol>
<ul>
<li>RESTful url参数</li>
<li>参数查询 query</li>
<li>锚点  hash: ‘#data’</li>
</ul>
<ol start="4">
<li>嵌套路由</li>
</ol>
<ul>
<li>Children</li>
</ul>
<ol start="5">
<li>钩子</li>
</ol>
<ul>
<li>beforeRouteEnter</li>
<li>beforeRouteLeave</li>
</ul>
<h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><blockquote>
<p>Vuex是什么？</p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
</blockquote>
<ul>
<li>state里面就是存放的我们所要用到的状态；</li>
<li>mutations就是存放如何更改状态的方法 ，同步操作；</li>
<li>getters就是从state中派生出状态，比如将state中的某个状态进行过滤然后获取新的状态。</li>
<li>actions就是mutation的加强版，它可以通过commit</li>
<li>mutations中的方法来改变状态，最重要的是它可以进行异步操作。 </li>
<li>modules顾名思义，就是当用这个容器来装这些状态还是显得混乱的时候，我们就可以把容器分成几块，把状态和管理规则分类来装。这和我们创建js模块是一个目的，让代码结构更清晰。</li>
</ul>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue VSCode Snippets 自动生成Vue代码片段的VSCode扩展</title>
    <url>/2017/08/30/Vue-VSCode-Snippets/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现代化的IDE已经把开发者变得越来越懒，但是我觉得这样挺好的，让工具完成手工反复重复的工作，提高工作效率的同时降低开发者的疲劳感，Vue VSCode Snippets就是这样一个VSC插件，它可以用简单的几个字母就敲出一整块代码片段，在学习和做VUE项目时可以极大地提高工作效率，下面就介绍一下插件的常见命令。</p>
<a id="more"></a>

<p>此插件可用比较简单的写法生成代码片段，非常适合开发工作，减少代码工作量。</p>
<p>Script</p>
<table>
<thead>
<tr>
<th>Snippet</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>vbase</td>
<td>Single file component base</td>
</tr>
<tr>
<td>vbase</td>
<td>Single file component base</td>
</tr>
<tr>
<td>vdata</td>
<td>Component data as a function</td>
</tr>
<tr>
<td>vmethod</td>
<td>Vue method</td>
</tr>
<tr>
<td>vcomputed</td>
<td>Vue computed property</td>
</tr>
<tr>
<td>vwatcher</td>
<td>Vue watcher with new and old value args</td>
</tr>
<tr>
<td>vprops</td>
<td>Props with type and default</td>
</tr>
<tr>
<td>vimport</td>
<td>Import one component into another</td>
</tr>
<tr>
<td>vimport-c</td>
<td>Import one component into another within the export statement</td>
</tr>
<tr>
<td>vimport-export</td>
<td>Import one component into another and use it within the export statement</td>
</tr>
<tr>
<td>vfilter</td>
<td>Vue filter</td>
</tr>
<tr>
<td>vmixin</td>
<td>Create a Vue Mixin</td>
</tr>
<tr>
<td>vmixin-use</td>
<td>Bring a mixin into a component to use</td>
</tr>
<tr>
<td>vc-direct</td>
<td>Vue create a custom directive</td>
</tr>
<tr>
<td>vimport-lib</td>
<td>Import a library</td>
</tr>
<tr>
<td>vimport-gsap</td>
<td>Import GreenSock with Timeline and Eases</td>
</tr>
<tr>
<td>vanimhook-js</td>
<td>Using the Transition component JS hooks in methods</td>
</tr>
<tr>
<td><!-- more --></td>
<td></td>
</tr>
<tr>
<td>Template</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Snippet</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>vfor</td>
<td>v-for directive</td>
</tr>
<tr>
<td>vmodel</td>
<td>Semantic v-model directive</td>
</tr>
<tr>
<td>vmodel-num</td>
<td>Semantic v-model number directive</td>
</tr>
<tr>
<td>von</td>
<td>v-on click handler with arguments</td>
</tr>
<tr>
<td>vel-props</td>
<td>Component element with props</td>
</tr>
<tr>
<td>vsrc</td>
<td>Image src binding</td>
</tr>
<tr>
<td>vstyle</td>
<td>Inline style binding</td>
</tr>
<tr>
<td>vstyle-obj</td>
<td>Inline style binding with objects</td>
</tr>
<tr>
<td>vclass</td>
<td>Class binding</td>
</tr>
<tr>
<td>vclass-obj</td>
<td>Class binding with objects</td>
</tr>
<tr>
<td>vclass-obj-mult</td>
<td>Multiple conditional class bindings</td>
</tr>
<tr>
<td>vanim</td>
<td>Transition component with JS hooks</td>
</tr>
</tbody></table>
<p>Vuex</p>
<table>
<thead>
<tr>
<th>Snippet</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>vstore</td>
<td>Base for Vuex store.js</td>
</tr>
<tr>
<td>vgetters</td>
<td>Vuex Getter</td>
</tr>
<tr>
<td>vmutation</td>
<td>Vuex Mutation</td>
</tr>
<tr>
<td>vaction</td>
<td>Vuex Action</td>
</tr>
<tr>
<td>vstore-import</td>
<td>Import vuex store into main.js</td>
</tr>
</tbody></table>
<p>Extra (plaintext)</p>
<table>
<thead>
<tr>
<th>Snippet</th>
<th>Purpose</th>
</tr>
</thead>
<tbody><tr>
<td>gitignore</td>
<td>.gitignore file presets</td>
</tr>
<tr>
<td>vinc</td>
<td>incrementer</td>
</tr>
<tr>
<td>vdec</td>
<td>decrementer</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>VUE</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>npm相关资料</title>
    <url>/2017/08/30/npm-source/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近两年前端突然呈爆发增长之势，node的出现起了重要的作用，而node之中有一个重要的功能就是npm包管理工具，下面就记录一下我学习npm之中遇到的一些问题及解决方案，仅供各位参考。</p>
<a id="more"></a>

<blockquote>
<p>npm全称Node Package Manager，是node.js的模块依赖管理工具。由于npm的源在国外，所以国内用户使用起来各种不方便。下面整理出了一部分国内优秀的npm镜像资源，国内用户可以选择使用。</p>
</blockquote>
<h2 id="国内优秀npm镜像"><a href="#国内优秀npm镜像" class="headerlink" title="国内优秀npm镜像"></a>国内优秀npm镜像</h2><h3 id="淘宝npm镜像"><a href="#淘宝npm镜像" class="headerlink" title="淘宝npm镜像"></a>淘宝npm镜像</h3><ul>
<li>搜索地址：<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a></li>
<li>registry地址：<a href="http://registry.npm.taobao.org/" target="_blank" rel="noopener">http://registry.npm.taobao.org/</a></li>
</ul>
<h3 id="cnpmjs镜像"><a href="#cnpmjs镜像" class="headerlink" title="cnpmjs镜像"></a>cnpmjs镜像</h3><ul>
<li>搜索地址：<a href="http://cnpmjs.org/" target="_blank" rel="noopener">http://cnpmjs.org/</a></li>
<li>registry地址：<a href="http://r.cnpmjs.org/" target="_blank" rel="noopener">http://r.cnpmjs.org/</a></li>
</ul>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>有很多方法来配置npm的registry地址，下面根据不同情境列出几种比较常用的方法。以淘宝npm镜像举例：</p>
<h3 id="1-临时使用"><a href="#1-临时使用" class="headerlink" title="1.临时使用"></a>1.临时使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install express</span><br></pre></td></tr></table></figure>
<h3 id="2-持久使用"><a href="#2-持久使用" class="headerlink" title="2.持久使用"></a>2.持久使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 配置后可通过下面方式来验证是否成功</span><br><span class="line">npm config get registry</span><br><span class="line">&#x2F;&#x2F; 或</span><br><span class="line">npm info express</span><br></pre></td></tr></table></figure>
<h3 id="3-通过cnpm使用"><a href="#3-通过cnpm使用" class="headerlink" title="3.通过cnpm使用"></a>3.通过cnpm使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用</span><br><span class="line">cnpm install express</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>node</category>
        <category>npm</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>node</tag>
        <tag>rnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器兼容性问题解决方案</title>
    <url>/2017/08/29/browser-incompatibility-problem-solution/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为前端，浏览器就是你的战场，而不同的浏览器就是不同的敌人，敌人有相同之处，也各有特点，这不同的特点就是不同浏览器的兼容性，下面就聊聊浏览器的兼容问题，如何解决不同浏览器的兼容性。</p>
<a id="more"></a>
<p><strong>普及</strong>：浏览器的兼容性问题，往往是个别浏览器（没错，就是那个与众不同的浏览器）对于一些标准的定义不一致导致的。俗话说：没有IE就没有伤害。</p>
<p><strong>贴士</strong>：内容都是自己总结的，不免会出现错误或者bug，欢迎更正和补充，本帖也会不断更新。</p>
<h4 id="Normalize-css"><a href="#Normalize-css" class="headerlink" title="Normalize.css"></a>Normalize.css</h4><p>不同浏览器的默认样式存在差异，可以使用 <code>Normalize.css</code>抹平这些差异。当然，你也可以定制属于自己业务的 <code>reset.css</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;link href&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;normalize&#x2F;7.0.0&#x2F;normalize.min.css&quot; rel&#x3D;&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>简单粗暴法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* &#123; margin: 0; padding: 0; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="html5shiv-js"><a href="#html5shiv-js" class="headerlink" title="html5shiv.js"></a>html5shiv.js</h4><p>解决 ie9 以下浏览器对 html5 新增标签不识别的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--[if lt IE 9]&gt;</span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;html5shiv&#x2F;3.7.3&#x2F;html5shiv.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;![endif]--&gt;</span><br></pre></td></tr></table></figure>
<!-- more -->
<h4 id="respond-js"><a href="#respond-js" class="headerlink" title="respond.js"></a>respond.js</h4><p>解决 ie9 以下浏览器不支持 CSS3 Media Query 的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;picturefill&#x2F;3.0.3&#x2F;picturefill.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="IE-条件注释"><a href="#IE-条件注释" class="headerlink" title="IE 条件注释"></a>IE 条件注释</h4><p>IE 的条件注释仅仅针对IE浏览器，对其他浏览器无效<br><img src="https://user-gold-cdn.xitu.io/2017/8/28/31714eaf3a9bc272c50dbf1e1279f14b?imageView2/0/w/1280/h/960" alt="image"></p>
<h4 id="IE-属性过滤器（较为常用的hack方法）"><a href="#IE-属性过滤器（较为常用的hack方法）" class="headerlink" title="IE 属性过滤器（较为常用的hack方法）"></a>IE 属性过滤器（较为常用的hack方法）</h4><p>针对不同的 IE 浏览器，可以使用不同的字符来对特定的版本的 IE 浏览器进行样式控制<br><img src="https://user-gold-cdn.xitu.io/2017/8/28/e8c1a14cca725798b5aaa88bf5d23de8?imageView2/0/w/1280/h/960" alt="image"><br><img src="https://user-gold-cdn.xitu.io/2017/8/28/ad406608b75744baa6f89ae3c26ba69d?imageView2/0/w/1280/h/960" alt="image"></p>
<h4 id="浏览器-CSS-兼容前缀"><a href="#浏览器-CSS-兼容前缀" class="headerlink" title="浏览器 CSS 兼容前缀"></a>浏览器 CSS 兼容前缀</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-o-transform:rotate(7deg); &#x2F;&#x2F; Opera</span><br><span class="line"></span><br><span class="line">-ms-transform:rotate(7deg); &#x2F;&#x2F; IE</span><br><span class="line"></span><br><span class="line">-moz-transform:rotate(7deg); &#x2F;&#x2F; Firefox</span><br><span class="line"></span><br><span class="line">-webkit-transform:rotate(7deg); &#x2F;&#x2F; Chrome</span><br><span class="line"></span><br><span class="line">transform:rotate(7deg); &#x2F;&#x2F; 统一标识语句</span><br></pre></td></tr></table></figure>
<p><strong><em>补充：</em></strong> 目前可以采用自动化插件完成，插件名称叫做 <code>Autoprefixer</code>，他可以解析css文件并且添加前缀到css内容里。</p>
<p>把 <code>Auroprefixer</code> 添加到资源构建工具如：<code>webpack</code>后，就可以不用再手动补全浏览器前缀了，这里只需要你按照W3C的标准来书写css代码，剩下的工作就交给插件完成，目前<code>webpack</code>、<code>gulp</code>、<code>grunt</code>都有相应的插件，是不是开心啊。</p>
<h4 id="a-标签的几种-CSS-状态的顺序"><a href="#a-标签的几种-CSS-状态的顺序" class="headerlink" title="a 标签的几种 CSS 状态的顺序"></a>a 标签的几种 CSS 状态的顺序</h4><p>很多新人在写 a 标签的样式，会疑惑为什么写的样式没有效果，或者点击超链接后，hover、active 样式没有效果，其实只是写的样式被覆盖了。</p>
<p>正确的a标签顺序应该是：<code>==love hate==</code></p>
<ol>
<li>link:平常的状态</li>
<li>visited:被访问过之后</li>
<li>hover:鼠标放到链接上的时候</li>
<li>active:链接被按下的时候</li>
</ol>
<h4 id="完美解决-Placeholder"><a href="#完美解决-Placeholder" class="headerlink" title="完美解决 Placeholder"></a>完美解决 <code>Placeholder</code></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;Name *&quot; onFocus&#x3D;&quot;this.value &#x3D; &#39;&#39;;&quot; onBlur&#x3D;&quot;if (this.value &#x3D;&#x3D; &#39;&#39;) &#123;this.value &#x3D; &#39;Name *&#39;;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="清除浮动-最佳实践"><a href="#清除浮动-最佳实践" class="headerlink" title="清除浮动 最佳实践"></a>清除浮动 最佳实践</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.fl &#123; float: left; &#125;</span><br><span class="line">.fr &#123; float: right; &#125;</span><br><span class="line">.clearfix:after &#123; display: block; clear: both; content: &quot;&quot;; visibility: hidden; height: 0; &#125;</span><br><span class="line">.clearfix &#123; zoom: 1; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="BFC-解决边距重叠问题"><a href="#BFC-解决边距重叠问题" class="headerlink" title="BFC 解决边距重叠问题"></a>BFC 解决边距重叠问题</h4><p>当相邻元素都设置了 margin 边距时，margin 将取最大值，舍弃小值。为了不让边距重叠，可以给子元素加一个父元素，并设置该父元素为 BFC：<code>overflow: hidden</code>;</p>
<div class="box" id="box">
  <p>Lorem ipsum dolor sit.</p>

  <div style="overflow: hidden;">
    <p>Lorem ipsum dolor sit.</p>
  </div>

  <p>Lorem ipsum dolor sit.</p>
</div>

<h4 id="IE6-双倍边距的问题"><a href="#IE6-双倍边距的问题" class="headerlink" title="IE6 双倍边距的问题"></a>IE6 双倍边距的问题</h4><p>设置 ie6 中设置浮动，同时又设置 <code>margin</code>，会出现双倍边距的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display: inline;</span><br></pre></td></tr></table></figure>
<h4 id="解决-IE9-以下浏览器不能使用-opacity"><a href="#解决-IE9-以下浏览器不能使用-opacity" class="headerlink" title="解决 IE9 以下浏览器不能使用 opacity"></a>解决 IE9 以下浏览器不能使用 opacity</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">opacity: 0.5;</span><br><span class="line">filter: alpha(opacity &#x3D; 50);</span><br><span class="line">filter: progid:DXImageTransform.Microsoft.Alpha(style &#x3D; 0, opacity &#x3D; 50);</span><br></pre></td></tr></table></figure>
<h4 id="解决-IE6-不支持-fixed-绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题"><a href="#解决-IE6-不支持-fixed-绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题" class="headerlink" title="解决 IE6 不支持 fixed 绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题"></a>解决 IE6 不支持 fixed 绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* IE6 hack *&#x2F;</span><br><span class="line">*html, *html body &#123;</span><br><span class="line">  background-image: url(about:blank);</span><br><span class="line">  background-attachment: fixed;</span><br><span class="line">&#125;</span><br><span class="line">*html #menu &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: expression(((e&#x3D;document.documentElement.scrollTop) ? e : document.body.scrollTop) + 100 + &#39;px&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IE6-背景闪烁的问题"><a href="#IE6-背景闪烁的问题" class="headerlink" title="IE6 背景闪烁的问题"></a>IE6 背景闪烁的问题</h4><p>问题：链接、按钮用 CSSsprites 作为背景，在 ie6 下会有背景图闪烁的现象。原因是 IE6 没有将背景图缓存，每次触发 hover 的时候都会重新加载</p>
<p>解决：可以用 JavaScript 设置 ie6 缓存这些图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.execCommand(&quot;BackgroundImageCache&quot;, false, true);</span><br></pre></td></tr></table></figure>
<h4 id="解决在-IE6-下，列表与日期错位的问题"><a href="#解决在-IE6-下，列表与日期错位的问题" class="headerlink" title="解决在 IE6 下，列表与日期错位的问题"></a>解决在 IE6 下，列表与日期错位的问题</h4><p>日期<span> 标签放在标题 <a> 标签之前即可<br><img src="https://user-gold-cdn.xitu.io/2017/8/28/6797c276197029d941ee577d877d6be3?imageView2/0/w/1280/h/960" alt="image"></p>
<h4 id="解决-IE6-不支持-min-height-属性的问题"><a href="#解决-IE6-不支持-min-height-属性的问题" class="headerlink" title="解决 IE6 不支持 min-height 属性的问题"></a>解决 IE6 不支持 min-height 属性的问题</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">min-height: 350px;</span><br><span class="line">_height: 350px;</span><br></pre></td></tr></table></figure>

<h4 id="让-IE7-IE8-支持-CSS3-background-size属性"><a href="#让-IE7-IE8-支持-CSS3-background-size属性" class="headerlink" title="让 IE7 IE8 支持 CSS3 background-size属性"></a>让 IE7 IE8 支持 CSS3 background-size属性</h4><p>由于 background-size 是 CSS3 新增的属性，所以 IE 低版本自然就不支持了，但是老外写了一个 htc 文件，名叫 background-size polyfill，使用该文件能够让 IE7、IE8 支持 background-size 属性。其原理是创建一个 img 元素插入到容器中，并重新计算宽度、高度、left、top 等值，模拟 background-size 的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">body &#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  margin: 0;</span><br><span class="line">  padding: 0;</span><br><span class="line">  background-image: url(&#39;img&#x2F;37.png&#39;);</span><br><span class="line">  background-repeat: no-repeat;</span><br><span class="line">  background-size: cover;</span><br><span class="line">  -ms-behavior: url(&#39;css&#x2F;backgroundsize.min.htc&#39;);</span><br><span class="line">  behavior: url(&#39;css&#x2F;backgroundsize.min.htc&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IE6-7-line-height-失效的问题"><a href="#IE6-7-line-height-失效的问题" class="headerlink" title="IE6-7 line-height 失效的问题"></a>IE6-7 line-height 失效的问题</h4><p>问题：在ie 中 img 与文字放一起时，line-height 不起作用</p>
<p>解决：都设置成 float</p>
<h4 id="td-自动换行的问题"><a href="#td-自动换行的问题" class="headerlink" title="td 自动换行的问题"></a>td 自动换行的问题</h4><p>问题：table 宽度固定，td 自动换行</p>
<p>解决：设置 <code>Tabl</code>e 为 <code>table-layout: fixed</code>，<code>td</code> 为 <code>word-wrap: break-word</code></p>
<h4 id="让层显示在-FLASH-之上"><a href="#让层显示在-FLASH-之上" class="headerlink" title="让层显示在 FLASH 之上"></a>让层显示在 FLASH 之上</h4><p>想让层的内容显示在 flash 上，把 FLASH 设置透明即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、&lt;param name&#x3D;&quot; wmode &quot; value&#x3D;&quot;transparent&quot; &#x2F;&gt;</span><br><span class="line">2、&lt;param name&#x3D;&quot;wmode&quot; value&#x3D;&quot;opaque&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="键盘事件-keyCode-兼容性写法"><a href="#键盘事件-keyCode-兼容性写法" class="headerlink" title="键盘事件 keyCode 兼容性写法"></a>键盘事件 keyCode 兼容性写法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var inp &#x3D; document.getElementById(&#39;inp&#39;)</span><br><span class="line">var result &#x3D; document.getElementById(&#39;result&#39;)</span><br><span class="line"></span><br><span class="line">function getKeyCode(e) &#123;</span><br><span class="line">  e &#x3D; e ? e : (window.event ? window.event : &quot;&quot;)</span><br><span class="line">  return e.keyCode ? e.keyCode : e.which</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inp.onkeypress &#x3D; function(e) &#123;</span><br><span class="line">  result.innerHTML &#x3D; getKeyCode(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求窗口大小的兼容写法"><a href="#求窗口大小的兼容写法" class="headerlink" title="求窗口大小的兼容写法"></a>求窗口大小的兼容写法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 浏览器窗口可视区域大小（不包括工具栏和滚动条等边线）</span><br><span class="line">&#x2F;&#x2F; 1600 * 525</span><br><span class="line">var client_w &#x3D; document.documentElement.clientWidth || document.body.clientWidth;</span><br><span class="line">var client_h &#x3D; document.documentElement.clientHeight || document.body.clientHeight;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 网页内容实际宽高（包括工具栏和滚动条等边线）</span><br><span class="line">&#x2F;&#x2F; 1600 * 8</span><br><span class="line">var scroll_w &#x3D; document.documentElement.scrollWidth || document.body.scrollWidth;</span><br><span class="line">var scroll_h &#x3D; document.documentElement.scrollHeight || document.body.scrollHeight;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 网页内容实际宽高 (不包括工具栏和滚动条等边线）</span><br><span class="line">&#x2F;&#x2F; 1600 * 8</span><br><span class="line">var offset_w &#x3D; document.documentElement.offsetWidth || document.body.offsetWidth;</span><br><span class="line">var offset_h &#x3D; document.documentElement.offsetHeight || document.body.offsetHeight;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 滚动的高度</span><br><span class="line">var scroll_Top &#x3D; document.documentElement.scrollTop||document.body.scrollTop;</span><br></pre></td></tr></table></figure>
<h4 id="DOM-事件处理程序的兼容写法（能力检测）"><a href="#DOM-事件处理程序的兼容写法（能力检测）" class="headerlink" title="DOM 事件处理程序的兼容写法（能力检测）"></a>DOM 事件处理程序的兼容写法（能力检测）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var eventshiv &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; event兼容</span><br><span class="line">    getEvent: function(event) &#123;</span><br><span class="line">        return event ? event : window.event;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; type兼容</span><br><span class="line">    getType: function(event) &#123;</span><br><span class="line">        return event.type;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; target兼容</span><br><span class="line">    getTarget: function(event) &#123;</span><br><span class="line">        return event.target ? event.target : event.srcelem;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加事件句柄</span><br><span class="line">    addHandler: function(elem, type, listener) &#123;</span><br><span class="line">        if (elem.addEventListener) &#123;</span><br><span class="line">            elem.addEventListener(type, listener, false);</span><br><span class="line">        &#125; else if (elem.attachEvent) &#123;</span><br><span class="line">            elem.attachEvent(&#39;on&#39; + type, listener);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F; 在这里由于.与&#39;on&#39;字符串不能链接，只能用 []</span><br><span class="line">            elem[&#39;on&#39; + type] &#x3D; listener;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 移除事件句柄</span><br><span class="line">    removeHandler: function(elem, type, listener) &#123;</span><br><span class="line">        if (elem.removeEventListener) &#123;</span><br><span class="line">            elem.removeEventListener(type, listener, false);</span><br><span class="line">        &#125; else if (elem.detachEvent) &#123;</span><br><span class="line">            elem.detachEvent(&#39;on&#39; + type, listener);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            elem[&#39;on&#39; + type] &#x3D; null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 添加事件代理</span><br><span class="line">    addAgent: function (elem, type, agent, listener) &#123;</span><br><span class="line">        elem.addEventListener(type, function (e) &#123;</span><br><span class="line">            if (e.target.matches(agent)) &#123;</span><br><span class="line">                listener.call(e.target, e); &#x2F;&#x2F; this 指向 e.target</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 取消默认行为</span><br><span class="line">    preventDefault: function(event) &#123;</span><br><span class="line">        if (event.preventDefault) &#123;</span><br><span class="line">            event.preventDefault();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            event.returnValue &#x3D; false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 阻止事件冒泡</span><br><span class="line">    stopPropagation: function(event) &#123;</span><br><span class="line">        if (event.stopPropagation) &#123;</span><br><span class="line">            event.stopPropagation();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            event.cancelBubble &#x3D; true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>IE兼容性问题</category>
      </categories>
      <tags>
        <tag>浏览器兼容问题</tag>
      </tags>
  </entry>
  <entry>
    <title>《晨间日记的奇迹》读书笔记</title>
    <url>/2016/10/27/Read-The-miracle-of-the-morning-journal/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>昨天花了1天的时间读了《晨间日记的奇迹》，感觉整个人的认识发生了一些变化，下面把重要内容做一下摘抄总结。</p>
<h1 id="早上写日记的好处-——-提升效率"><a href="#早上写日记的好处-——-提升效率" class="headerlink" title="早上写日记的好处 —— 提升效率"></a>早上写日记的好处 —— 提升效率</h1><ul>
<li>可以做好一天的准备 — 计划性</li>
<li>可以正确的写出昨天发生的事 — 效率性&amp;忠诚性</li>
<li>可以中立的看待昨天 — 中立性</li>
<li>相对自由的时间 — 持续性</li>
<li>总结经验 — 活用性</li>
</ul>
<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>日记 不等于 日志<br>日记 要记录 时间 天气 心情 — 因为这些有助于回忆和记录<br>不要投入过长时间 — 3分钟 — 日记私密性<br>晨间日记前7天只写好事 — 反省固然重要，但是成长更重要，持续性很重要 — 巴普洛夫的狗</p>
<h1 id="晨间日记2部分"><a href="#晨间日记2部分" class="headerlink" title="晨间日记2部分"></a>晨间日记2部分</h1><h2 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h2><p>客观记录已经发生的事（昨天）— 经验智慧</p>
<h2 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h2><ul>
<li>今天应做的事 — 具体行动（来自昨天的总结</li>
<li>今天一定要做的事（紧急重要的事）— 变得更积极更主动</li>
<li>未来要做的事 — 不紧急但重要的事</li>
<li>连用日记 — 历史上的今天（过去一年同一天的事）</li>
</ul>
<h1 id="夜晚日记-VS-晨间日记"><a href="#夜晚日记-VS-晨间日记" class="headerlink" title="夜晚日记 VS 晨间日记"></a>夜晚日记 VS 晨间日记</h1><p>受当天情绪影响 — 更冷静</p>
<h1 id="梦想成真表"><a href="#梦想成真表" class="headerlink" title="梦想成真表"></a>梦想成真表</h1><table>
<thead>
<tr>
<th></th>
<th>过去</th>
<th>未来</th>
</tr>
</thead>
<tbody><tr>
<td>事实</td>
<td>IQ 智慧指数</td>
<td>NQ 人际关系指数</td>
</tr>
<tr>
<td>感情</td>
<td>EQ 情感指数</td>
<td>DQ 梦想指数</td>
</tr>
</tbody></table>
<ul>
<li>IQ — 晨间日记冷静回忆分析 — 提高决策正确性 IQ up</li>
<li>EQ — 冷静记录昨日的情绪／自省 — 变积极 EQ up</li>
<li>NQ — 总结昨天给今天设立“对／为XXX做某事” 很重要 NQ up</li>
<li>DQ — 不能只有眼前的事 每天都要确定一下自己的梦想 脸皮厚点没关系 重复或只有一句话也没关系 铭记于心最重要</li>
</ul>
<p>“忙碌”只是借口！“决心”才是问题！ 对未来充满期待的人才有行动力</p>
<h1 id="如何早起"><a href="#如何早起" class="headerlink" title="如何早起"></a>如何早起</h1><ul>
<li>设定起床音乐／用气味（精油）刺激起床／光线-电动窗帘早起自动拉开</li>
<li>早起后淋浴 — 配合音乐／冥想／呐喊 — 让自己充满动力保持清醒</li>
</ul>
<h1 id="写日记的五大好处"><a href="#写日记的五大好处" class="headerlink" title="写日记的五大好处"></a>写日记的五大好处</h1><ul>
<li>提升写作能力</li>
<li>谈话题材源源不断</li>
<li>提高贵人运</li>
<li>返现自我肉体和精神的状态与模式</li>
<li>在自己身上挖宝，彻底改变人生</li>
</ul>
<h1 id="记录的日记要常拿出来看看"><a href="#记录的日记要常拿出来看看" class="headerlink" title="记录的日记要常拿出来看看"></a>记录的日记要常拿出来看看</h1><p>记录日记时 — 问问自己的灵魂 然后写下真心话 — 灵魂日记<br><code>六度空间理论</code></p>
<h1 id="七种成功者的习惯"><a href="#七种成功者的习惯" class="headerlink" title="七种成功者的习惯"></a>七种成功者的习惯</h1><ul>
<li>习惯之一：积极主动别指望谁能推你走 — 主动行动，迈出第一步</li>
<li>习惯之二：以终为始忠于自己的人生计划。— 设立人生目标并坚持</li>
<li>习惯之三：要事第一选择当前该做的事</li>
<li>习惯之四：追求双赢远离角斗场</li>
<li>习惯之五：善于沟通换位思考的原则</li>
<li>习惯之六：统合综效 1+1可以大于2</li>
<li>习惯之七：不断更新全方位平衡自我</li>
</ul>
<p>早睡是为了身体，早起是为了我们的内心。— sugiponn</p>
<h1 id="晨间日记的格式"><a href="#晨间日记的格式" class="headerlink" title="晨间日记的格式"></a>晨间日记的格式</h1><p>晨间日记必须要设立的栏目 — 工作／金钱／健康／人际关系<br>要记下当日的日期／天气／温度／湿度</p>
<p>纬度标签<br>工作方面：</p>
<ul>
<li>能力开发／经营／管理／进货／工作人员／学习／资格／活动／企划案／想法／推广<br>金钱方面：</li>
<li>收入／指出／购入／股票／资产／储蓄／家用<br>健康方面：</li>
<li>饮食／运动／性／减肥／身体状况／锻炼身体／体重／脂肪<br>人际关系方面：</li>
<li>父母／家人／小孩／亲戚／情人／工作伙伴／朋友／熟人／联络事项／人脉网络<br>兴趣方面以及其他：</li>
<li>义工活动／阅读／运动／打扮／电影／音乐／游戏／喜欢的物品／今天必须要注意的事／美容／开心的事／购物</li>
</ul>
<p>劳动 — 职业 — 工作 — <em>乐趣</em></p>
<h1 id="三大原则和七大作战守则"><a href="#三大原则和七大作战守则" class="headerlink" title="三大原则和七大作战守则"></a>三大原则和七大作战守则</h1><ul>
<li><p>原则1:时间不超过3分钟 — 减少养成习惯的成本</p>
</li>
<li><p>原则2:决定好写晨间日记的地方 — 为了养成习惯</p>
</li>
<li><p>原则3:只写一个字也没关系 — 不要有压力</p>
</li>
<li><p>作战守则1:开心写日记 — 反省固然重要，鼓励更有作用 — 开始写晨间日记前七天只写好事</p>
</li>
<li><p>作战守则2:ONE-TWO作战 — 把动作分布容易养成习惯 — 形成固定动作</p>
</li>
<li><p>作战守则3:巴普洛夫的狗 — 开始写日记时候要有一个仪式 — 心理暗示</p>
</li>
<li><p>作战守则4:奖励自己 — 当习惯养成并坚持到一定时间，给自己一个奖励</p>
</li>
<li><p>作战守则5:宣告天下 — 借由他人的鼓励或压力形成动力／也可找到同志</p>
</li>
<li><p>作战守则6:一千日作战法 — 不管什么样的习惯坚持1000日就会成为永远的习惯 — 具体做法为记录 第XXX篇 晨间日记</p>
</li>
<li><p>作战守则7:为了别人 — 写晨间日记不只是为了自己，而且更是为了别人，身边人的幸福最终会影响到自己</p>
</li>
</ul>
<h1 id="应该先肯定自己，给自己打100分"><a href="#应该先肯定自己，给自己打100分" class="headerlink" title="应该先肯定自己，给自己打100分"></a>应该先肯定自己，给自己打100分</h1><ul>
<li>“总之，先… 病” 没有目标／没有梦想 — 回顾时一定会后悔！</li>
<li>“假如…，应该 病” 无法满足／没有动力 — 焦躁不安</li>
<li>共同点：失落感／空虚／</li>
</ul>
<h2 id="解决办法—-设立一个情境"><a href="#解决办法—-设立一个情境" class="headerlink" title="解决办法— 设立一个情境"></a>解决办法— 设立一个情境</h2><p>例：我要建立一个幸福的家庭 —&gt; 因此我要创造很多快乐的回忆 —&gt; 为了制造很多快乐的回忆 —&gt; 我必须要到很多的地方去看看 —&gt; 为了去很多地方看看，我觉得有辆车会更方便 —&gt; 买车 —&gt; 考驾照</p>
<p>不要总想自己哪里欠缺，要想自己想要得到什么，并且为了目标努力，你就会变的更完美。<br>拥有一个敢于大声喊出的梦想，不要羞涩，要为了梦想一步步的前进，最终达到梦想。</p>
<h1 id="提到的另外的书"><a href="#提到的另外的书" class="headerlink" title="提到的另外的书"></a>提到的另外的书</h1><p>《培育梦想种子》《日记的力量》《成功人士的七个习惯》</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>成长</tag>
      </tags>
  </entry>
  <entry>
    <title>《让老板提拔你》读书笔记</title>
    <url>/2015/12/31/Read-Let-your-boss-promote-you/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近读了《让老板提拔你》，下面将书中觉得有用的内容进行摘抄，放在下方。</p>
<h1 id="定位自己"><a href="#定位自己" class="headerlink" title="定位自己"></a>定位自己</h1><p>正确认识自己，确定社会定位、职业定位。 定位-决定-定价</p>
<h2 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h2><p><strong><em>核心竞争力</em></strong> 与 <strong><em>职位</em></strong> <strong><em>契合度</em></strong> 是高薪关键所在</p>
<h3 id="契合度"><a href="#契合度" class="headerlink" title="契合度"></a>契合度</h3><ul>
<li>技能、专长、经历与职位要求的契合度</li>
<li>专业资质和等级与职位要求的契合度</li>
<li>综合素质与职位要求的契合度<h3 id="七大秘诀"><a href="#七大秘诀" class="headerlink" title="七大秘诀"></a>七大秘诀</h3></li>
<li>了解同行业薪酬的平均水平</li>
<li>赢得未来单位的心</li>
<li>先让对方开口</li>
<li>勇敢地开口要求</li>
<li>不要轻言放弃</li>
<li>把握时机很重要</li>
<li>说实话，别撒谎<h3 id="如何谈薪资"><a href="#如何谈薪资" class="headerlink" title="如何谈薪资"></a>如何谈薪资</h3></li>
<li>商洽薪酬的关键在于把握好谈话时机，切勿开门见山。<blockquote>
<p>只要有发展机会，我愿意接受贵单位的薪酬标准，不知道按规定这个工作岗位的薪酬标准是多少。</p>
</blockquote>
</li>
</ul>
<h3 id="将知识卖个好价钱"><a href="#将知识卖个好价钱" class="headerlink" title="将知识卖个好价钱"></a>将知识卖个好价钱</h3><p>推销自己既推销自己所掌握的知识即智慧，正确认识自己的价值是关键。</p>
<h3 id="高薪是因为“物有所值”"><a href="#高薪是因为“物有所值”" class="headerlink" title="高薪是因为“物有所值”"></a>高薪是因为“物有所值”</h3><ul>
<li>用业绩、用能力说话，是人才坦然面对高薪的心态。</li>
<li>高薪人才的求职方式 —- 圈内朋友引见、定向投简历、行业论坛、交流活动等。</li>
<li>高级人才不能经常跳槽要保持相对的职业稳定。—- 在一家公司少则3年多则6年 —- 接受挑战，把握机会。</li>
</ul>
<h3 id="失败丰富走向成功经验"><a href="#失败丰富走向成功经验" class="headerlink" title="失败丰富走向成功经验"></a>失败丰富走向成功经验</h3><p>强调在失败中吸取的经验，在未来中可以避免的损失。</p>
<h3 id="能为企业带来丰厚的利润才是人才"><a href="#能为企业带来丰厚的利润才是人才" class="headerlink" title="能为企业带来丰厚的利润才是人才"></a>能为企业带来丰厚的利润才是人才</h3><p>企业招聘员工的唯一目的：追求公司业绩最大化、利润最大化。</p>
<h1 id="高质高效工作全攻略"><a href="#高质高效工作全攻略" class="headerlink" title="高质高效工作全攻略"></a>高质高效工作全攻略</h1><ul>
<li>进行正确的自我评价</li>
<li>做最擅长做的事<ul>
<li>三个经济原则 —- 发挥人才优势。<ol>
<li>比较利益原则—–自己的专长对自己才是最有利的，勿与他人作比较。</li>
<li>机会成本原则—–选择一份工作放弃其他工作就是机会成本。</li>
<li>效率原则——–工作的成功不在于时间有多长，而在于成效有多少，附加值有多少。</li>
</ol>
</li>
</ul>
</li>
<li>马上行动</li>
<li>做事情要雷厉风行 ——— 成功属于踏实肯干的人</li>
<li>有条不紊地开展工作 ——- 制定时间计划</li>
<li>善于利用现代办公工具</li>
<li>给自己最大的工作空间</li>
<li>建立高效有序的办公环境</li>
<li>不要忘记最初想去的方向</li>
<li>“聪明”的向上级提出建议</li>
<li>专心做事，避免浮躁</li>
<li>多而不专，一事难成</li>
<li>“专”才有高质工作——–人才主要指专才–某个领域的高精尖人才–勿做全才，一专多能</li>
<li>做事要有条理</li>
</ul>
<h1 id="不要只把自己当成一个打工仔"><a href="#不要只把自己当成一个打工仔" class="headerlink" title="不要只把自己当成一个打工仔"></a>不要只把自己当成一个打工仔</h1><blockquote>
<p>要把工作当成事业</p>
</blockquote>
<ul>
<li>工作不仅仅是为了钱</li>
<li>对工作要有明确的价值取向<ol>
<li>认清人生的方向</li>
<li>开始学会醉卧探索和认知</li>
<li>认清工作价值与成就的关系</li>
<li>长期的工作规划</li>
<li>在生命的天平上衡量自身的价值</li>
</ol>
</li>
<li>巧妙应对与上司看法向左时的三条准则<ol>
<li>遇事考虑全局</li>
<li>辩证地看待问题</li>
<li>切记感情用事</li>
</ol>
</li>
<li>把单位的事当成自家的事</li>
<li>认真负责地用心工作</li>
<li>珍惜岗位，热爱自己的职业</li>
<li>永远是在为自己工作</li>
<li>敬重自己的工作</li>
<li>不要轻视薪水微薄的工作</li>
<li>永远对工作充满激情</li>
<li>以自己的工作为荣</li>
<li>不要被他人的观点所束缚</li>
<li>暂时的胜负并不会决定人生的最后走向</li>
<li>将弱势转化为优势</li>
<li>全力以赴做好每一天的工作</li>
<li>和优秀的人士在一起—见贤思齐、借梯爬楼<ul>
<li>如何争取跟优秀的人在一起<ol>
<li>不断的抛头露面</li>
<li>帮助可以帮助自己成就事业的人做事</li>
<li>与上司和比自己优秀的人士一起合作</li>
</ol>
</li>
</ul>
<ol>
<li>尊重对方，严谨有致</li>
<li>切记奉承，要不卑不亢</li>
<li>态度自然，不必拘谨</li>
<li>陪衬得当，不可狂妄</li>
<li>主动真诚，做出姿态</li>
<li>求助求教，接受呵护</li>
</ol>
</li>
<li>挑战自我，承担责任<ul>
<li>三条忠告<ol>
<li>全心全意工作</li>
<li>把自己视为合伙人</li>
<li>迎接变革的需求</li>
</ol>
</li>
</ul>
</li>
<li>自信独立，不随波逐流</li>
<li>敢于显示自己很重要</li>
<li>千万不能只知道抱怨上司</li>
<li>保持严谨认真的做事习惯</li>
<li>自主地做好手中的工作</li>
<li>踏踏实实地做好本职工作</li>
<li>丢掉工作散漫的坏习惯</li>
<li>不要让浮躁的性格困扰自己</li>
<li>不推诿，勇于承担责任</li>
<li>无论如何都不要拖延工作</li>
<li>糊弄工作只能是在糊弄自己</li>
<li>逊色的工作只会淘汰自己</li>
<li>千万别丢掉“得宠”之资</li>
<li>“一步登天”只会摔疼自己</li>
<li>别让“差不多”贻误了自己</li>
<li>能完成100%，就决不做99%</li>
</ul>
<h1 id="与上司相处"><a href="#与上司相处" class="headerlink" title="与上司相处"></a>与上司相处</h1><ul>
<li>不要做上司的“心腹”</li>
<li>适时恰当的赞美上司<ul>
<li>赞美上司，还要善于选择适当的场合</li>
<li>赞美上司，要学会巧借公众语言称赞</li>
<li>赞美上司，还要善于赞美不得志的上司</li>
</ul>
</li>
<li>主动与领导沟通</li>
<li>主动和上司保持联系 </li>
<li>用“心机”主动接近上司<ul>
<li>尽可能详细的了解上司</li>
<li>选择一个与领导尽可能近的位置</li>
<li>赢得上司青睐的方法 </li>
</ul>
</li>
<li>更有效的和上司沟通<ul>
<li>与上司沟通要简洁</li>
<li>与上司沟通要大度大气大方</li>
<li>与上司沟通，就要把自己先放一边 ——– 说话对事不对人</li>
</ul>
</li>
<li>四种和上司进行沟通的方法<ol>
<li>开诚布公式———提出问题，说出自己的理解认识，给出解决方案，寻求领导意思，执行领导的命令</li>
<li>先斩后奏式———因主客观原因导致的没有先汇报而是先解决的事，事后要将问题的分析方法，解决方法，实施方案以及结果做一份详尽的总结报告上交给领导</li>
<li>“含情脉脉”式——-通过交流一些工作上的问题来含蓄表达出个人的建议、需要</li>
<li>巧设比喻式———通过典型案例来暗示自己的意见和要求</li>
</ol>
</li>
<li>把话说到上司的心坎上</li>
<li>巧妙地为领导拾遗补缺<ol>
<li>诠释领导讲话的难点</li>
<li>强调领导的才干</li>
<li>化严肃为幽默</li>
<li>稳定情绪，委婉暗示</li>
</ol>
</li>
<li>工作中勤于请示汇报<ol>
<li>听懂上司的意图</li>
<li>探讨、磨合，达成共识</li>
<li>制定尽可能详尽的工作计划</li>
<li>随时向上司汇报任务的关键点</li>
<li>总结汇报</li>
</ol>
</li>
<li>用成功赢得上司的信任</li>
<li>工作中不要冲撞上司</li>
<li>处理好同上司之间的分歧<ol>
<li>圆融协调——领导不懂，下达了错误的指令<ol>
<li>私下向上司陈述意见，帮助上司做出正确的决策</li>
<li>如果上司采纳了下属的建议或意见，该下属有责任长期保守秘密</li>
<li>如果上司固执己见，那么无条件服从</li>
</ol>
</li>
<li>装聋作哑——不涉及到原则问题</li>
<li>棘手难题多权衡<ol>
<li>立刻插话纠正</li>
<li>提醒上司</li>
<li>暗示</li>
<li>事后补救</li>
<li>事后提醒</li>
</ol>
</li>
</ol>
</li>
<li>正确对待上司的批评</li>
<li>要善于服从自己的上司</li>
<li>正确化解来自上司的压力</li>
</ul>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>博观约取，多读书读好书，丰富自己，变得睿智。</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>职场</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS border三角、圆角图形生成技术详解</title>
    <url>/2013/06/26/CSS-Triangle-Circle/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>利用CSS的border属性可以生成一些图形，例如三角或是圆角。纯粹的CSS2的内容，没有兼容性的问题，我之前在纯CSS实现各类气球泡泡对话框效果一文中算是比较详细的讲述了CSS border属性生成三角的原理，以及实例。我觉得此技术相当实用的，故本文再次简单叙述一下，另外，本文还将展示可能并不为众人所知的CSS border圆角生成技术。好了，裹脚布的话就不说了，直接进入正题。</p>
<a id="more"></a>

<h1 id="CSS-border生成三角技术简介"><a href="#CSS-border生成三角技术简介" class="headerlink" title="CSS border生成三角技术简介"></a>CSS border生成三角技术简介</h1><h2 id="效果抢鲜"><a href="#效果抢鲜" class="headerlink" title="效果抢鲜"></a>效果抢鲜</h2><p>下图为使用CSS的border属性实现的三角效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; css 代码</span><br><span class="line">.test&#123;</span><br><span class="line">  width: 0; </span><br><span class="line">  height: 0; </span><br><span class="line">  border-width: 20px 10px; </span><br><span class="line">  border-style: solid; </span><br><span class="line">  border-color: #ff3300 #ff3300 #ffffff #ffffff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如何实现的，为何会有这样的效果，不急，take it easy!</p>
<h2 id="梯形图案"><a href="#梯形图案" class="headerlink" title="梯形图案"></a>梯形图案</h2><p>看下面这段样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width: 10px; </span><br><span class="line">  height: 10px; </span><br><span class="line">  border: 10px solid; </span><br><span class="line">  border-color: #ff3300 #0000ff #339966 #00ff00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当某个div应用了上面这个样式后，结果会如何？见下图（截自Firefox3.5，IE浏览器有细节上的差异）：</p>
<h2 id="更进一步-–-部分边框透明"><a href="#更进一步-–-部分边框透明" class="headerlink" title="更进一步 – 部分边框透明"></a>更进一步 – 部分边框透明</h2><p>现在，设想一下，如果我们现在只保留一个一个上边框，其余边框均transparent透明（或与背景色同色），那么是不是就只显示一个上面红色的边框了，我们测试下，与上面类似的代码，只是修改下其余三个边框的颜色。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width:10px; </span><br><span class="line">  height:10px; </span><br><span class="line">  border:10px solid; </span><br><span class="line">  border-color:#ff3300 #ffffff #ffffff #ffffff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下图（截自Firefox3.5）：</p>
<h2 id="从梯形到三角"><a href="#从梯形到三角" class="headerlink" title="从梯形到三角"></a>从梯形到三角</h2><p>上面的是梯形，我要想得到一个三角图案该怎么办呢？显然，很简单，把div的高宽都变成0，只留一边，不就是三角了吗？如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width: 0; </span><br><span class="line">  height: 0; </span><br><span class="line">  border: 10px solid; </span><br><span class="line">  border-color: #ff3300 #ffffff #ffffff #ffffff;&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下（依旧截图自Firefox3.5）：</p>
<h2 id="从等腰直角三角形到普通等腰三角"><a href="#从等腰直角三角形到普通等腰三角" class="headerlink" title="从等腰直角三角形到普通等腰三角"></a>从等腰直角三角形到普通等腰三角</h2><p>上图为等腰直角三角形，之所以为等腰直角，是因为所有的边框宽度是一样的，如果我们将边框宽度设置为不同，那会怎样？则会形成等腰三角形。如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width: 0; </span><br><span class="line">  height: 0; </span><br><span class="line">  border-width: 20px 10px; </span><br><span class="line">  border-style: solid; </span><br><span class="line">  border-color: #ff3300 #ffffff #ffffff #ffffff;&#125;</span><br></pre></td></tr></table></figure>
<p>得到的结果如下图：</p>
<h2 id="从等腰到不等腰"><a href="#从等腰到不等腰" class="headerlink" title="从等腰到不等腰"></a>从等腰到不等腰</h2><p>我们可以不局限于保留一条边框，我们可以保留两条，于是我们可以告别等腰，得到更加锐利的三角，正如一开始所展示的那个三角：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.test&#123;</span><br><span class="line">  width: 0; </span><br><span class="line">  height: 0; </span><br><span class="line">  border-width: 20px 10px; </span><br><span class="line">  border-style: solid; </span><br><span class="line">  border-color: #ff3300 #ff3300 #ffffff #ffffff;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实际的应用"><a href="#实际的应用" class="headerlink" title="实际的应用"></a>实际的应用</h2><p>关于应用，不多说，直接看图：<br>说明：<br>以上的测试代码纯粹为了说明原理，所以使用#ffffff白色边框，通过于背景融合来隐藏边框。在实际的操作中，应该使用transparent透明属性，例如border-color:#ff3300 #ff3300 transparent transparent;，这同样会有问题，IE6浏览器不支持transparent透明属性，不过没有关系，就border生成三角技术而言，直接设置对应的透明边框的border-style属性为dotted或是dashed即可解决这一问题，为什么使用dotted和dashed可以修复此问题呢？您有兴趣可以参见默尘的这篇文章Dotted&amp;Dashed终极分析及IE6透明边框。</p>
<h1 id="CSS-border圆角生成技术简介"><a href="#CSS-border圆角生成技术简介" class="headerlink" title="CSS border圆角生成技术简介"></a>CSS border圆角生成技术简介</h1><h2 id="我看圆角"><a href="#我看圆角" class="headerlink" title="我看圆角"></a>我看圆角</h2><p>一提到圆角，我脑中闪过的词就是“定位”，“嵌套”，“模拟”，“渐进增强”，“滥用”。</p>
<ul>
<li>定位，也就是切四个角上下左右定位，这是淘宝首页的做法，但是面对IE6的奇偶bug只能当作看客；</li>
<li>使用“嵌套”则不会有此问题，“嵌套”分图片背景嵌套和CSS边框嵌套，使用图片嵌套则图片的重用性，大小优化有待加强，边框嵌套则技术实现上有些难度；</li>
<li>或使用“渐进增强”，CSS3 border-radius属性，而不要去鸟IE这类自我感觉良好的浏览器；</li>
<li>或是学习Google使用CSS模拟，而一般的CSS模拟都是使用左右边框+背景色的方式1像素1像素的拼合成的。这类方法各有优缺点，需根据实际情况采用。对于满眼圆角的设计图我是很不喜欢的，该用则用，切勿为了圆角而圆角。</li>
</ul>
<h2 id="border圆角图案生成法"><a href="#border圆角图案生成法" class="headerlink" title="border圆角图案生成法"></a>border圆角图案生成法</h2><p>这里介绍的实现圆角的得到与上面提到的都是不一样的，虽然也属于CSS模拟的范畴，但是其高效的程度确实相当惊人的，可谓最佳实践之一。<br>我们先看看效果，见下图，截自Firefox3.6：<br>上述效果的实现仅仅使用了三个标签，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; html 代码</span><br><span class="line">&lt;div class&#x3D;&quot;box&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;top&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;center&quot;&gt;我是一只小小鸟、小小鸟！&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;bot&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; css 代码</span><br><span class="line">.box&#123;</span><br><span class="line">  width:500px;</span><br><span class="line">&#125;</span><br><span class="line">.top&#123;</span><br><span class="line">  border-bottom:3px solid; </span><br><span class="line">  border-top-color:#cc0000; </span><br><span class="line">  border-bottom-color:#cc0000; </span><br><span class="line">  border-left:3px dotted transparent; </span><br><span class="line">  border-right:3px dotted transparent;</span><br><span class="line">&#125;</span><br><span class="line">.center&#123;</span><br><span class="line">  padding:10px 20px; </span><br><span class="line">  color:white; </span><br><span class="line">  font-size:14px; </span><br><span class="line">  background:#cc0000;</span><br><span class="line">&#125;</span><br><span class="line">.bot&#123;</span><br><span class="line">  border-top:3px solid; </span><br><span class="line">  border-top-color:#cc0000; </span><br><span class="line">  border-bottom-color:#cccccc; </span><br><span class="line">  border-left:3px dotted transparent; </span><br><span class="line">  border-right:3px dotted transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看看这段代码在IE6下的效果：</p>
<p>这里的高效在于，仅仅使用了一层标签就模拟了3像素的圆角，按照曾经我对CSS圆角模拟的理解，模拟1像素的圆角需要一层标签(background+borderLeft+borderRight)，两像素的需要两层标签，三像素的需要三层标签。</p>
<p>有点神奇，但是就像看刘谦的魔术一样，说穿了也就那么回事，其实这里的圆角模拟在本文的上面已经展示了，就是这样图片：</p>
<p>您可能会疑问，是不是搞错图片啦，这显然不是一个模样的，非也非也，就本质上而言，圆角的实现与上面的梯形图就是同样的东西。现在，盯着上面这张图，我们想象一下，用力的想象，用想花姑娘的那番劲头想象——上面的梯形宽度越来越宽（不是拉伸），一直宽到500像素，是不是与上面实现的圆角的下边缘一致啊？</p>
<p>也就是说，那个含有“我是一只小小鸟……”文字的圆角图形是有一个上梯形+矩形+下梯形组成的。参见下面的分离效果图：<br>您可以狠狠地点击这里：CSS border圆角生成demo</p>
<h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>人无完人，金无足赤，此方法虽然简洁高效，兼容性上佳，但是依然有局限性，在实现实色背景的圆角效果时，此方法可谓首选；如果是纯粹的圆角边框，此方法也可以实现，需要用到边框重叠，但是标签数几乎要翻倍，其权衡效用将大打折扣，反不如其他圆角方法来的实在。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>如果在web制作中，需要用的一些直接可以使用CSS+单标签模拟的图片，我的建议是“毫不犹豫使用CSS模拟”，例如实色的三角，或是实现实色的圆角效果，这可以说是最高效，最利于扩展维护的前端实现方法了。我们需要开阔的思维，而不要仅仅局限于眼前的技术，武侠中所谓的“无招胜有招”还是有着一定的哲学道理的，长远来看，意识与海纳百川的心态比当下的一点技术更来得重要。</p>
]]></content>
      <categories>
        <category>CSS技巧</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>《高性能JAVASCRIPT》读书笔记</title>
    <url>/2013/06/17/Read-High-Performance-JavaScript/</url>
    <content><![CDATA[<blockquote>
<p>作者：李旭光<br>引用请标明出处</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近读了《高性能JAVASCRIPT》，下面将书中觉得有用的内容进行摘抄，放在下方。</p>
<h1 id="如何从小事提升JAVASCRIPT性能。"><a href="#如何从小事提升JAVASCRIPT性能。" class="headerlink" title="如何从小事提升JAVASCRIPT性能。"></a>如何从小事提升JAVASCRIPT性能。</h1><ol>
<li><p>将<code>&lt;script&gt;</code>标签写在<code>&lt;/body&gt;</code>之前——将脚本放在底部。</p>
</li>
<li><p>尽量少的<code>&lt;script&gt;</code>标签，减少页面中的外链数量，减少请求次数。</p>
</li>
<li><p>使用打包工具如：Yahoo！combo handler</p>
</li>
<li><p>使用动态延迟加载技术如：LazyLoad类库,LABjs</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;lazyload-min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">  LazyLoad.js([],function()&#123;</span><br><span class="line">    Application.init();</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在javascript中存储位置十分重要，尽量用局部变量代替对象成员的访问。</p>
</li>
<li><p>集合变数组提高查询效率</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; js代码</span><br><span class="line">function toArray(coll)&#123;</span><br><span class="line">  for(var i &#x3D; 0, a&#x3D;[], len&#x3D;coll.length; i&lt;len; i++)&#123;</span><br><span class="line">    a[i]&#x3D;col[i];</span><br><span class="line">  &#125;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用局部变量缓存访问多次的成员<br>当便利一个集合时，首要优化原则是把集合存储在局部变量中，并把length缓存在循环外部，然后使用局部变量访问这些需要多次访问的元素。</p>
</li>
<li><p>使用原生DOM方法querySelectorAll（）遍历查找元素。</p>
</li>
<li><p>让元素脱离动画流，页面重排次数越多，程序响应越慢，要尽量减少重拍<br>方法：<br>9.1. 使用绝对定位使元素脱离文档流</p>
</li>
<li><p>IE：hover<br>在大量元素使用：hover这个伪css选择器时，程序会降低响应速率，在大表格或列表的情况下</p>
</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
